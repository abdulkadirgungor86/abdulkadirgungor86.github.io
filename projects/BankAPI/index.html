<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Katmanlı Mimari ile Banka API'si: Kredi Kartı Yönetim Sistemi (.NET/C#)</title>
    
    <!-- SEO Meta Etiketleri -->
    <meta name="description" content="Katmanlı mimari kullanılarak C# ve .NET ile geliştirilmiş Banka API'si projesinin detaylı incelemesi. Kredi kartı bilgilerini yönetme (oluşturma, okuma, güncelleme, silme - CRUD) operasyonları. Proje yapısı, bileşenler, API tasarımı, güvenlik, veri yönetimi ve en iyi uygulamalar.">
    <meta name="keywords" content="Banka API, Kredi Kartı Yönetimi, Credit Card API, Layered Architecture, Katmanlı Mimari, C#, .NET, ASP.NET Core, Web API, RESTful API, FinTech API, Bankacılık API, CRUD Operasyonları, Yazılım Mimarisi, API Tasarımı, Veri Erişim Katmanı (DAL), İş Mantığı Katmanı (BLL), Sunum Katmanı, API Güvenliği, Kimlik Doğrulama, Yetkilendirme, JWT, OAuth 2.0, API Anahtarı, Veritabanı Tasarımı, Entity Framework Core, EF Core, SQL Server, PostgreSQL, Repository Pattern, Unit of Work, Dependency Injection (DI), SOLID Prensipleri, DTO (Data Transfer Object), Hata Yönetimi, Günlükleme (Logging), Serilog, Swagger, OpenAPI, Postman, API Testi, Birim Testi (Unit Test), Entegrasyon Testi, Docker, CI/CD, Finansal Teknoloji, Güvenli Yazılım Geliştirme, PCI DSS Farkındalığı, Veri Şifreleme, Veri Maskeleme, Türkçe API Rehberi, .NET API Projesi, Banka Sistemi API">
    <meta name="author" content="Abdulkadir Güngör">
    <link rel="sitemap" type="application/xml" title="Sitemap" href="https://abdulkadirgungor86.github.io/sitemap.xml"> 
    
    <!-- CSS Dosyası Bağlantısı -->
    <link rel="stylesheet" href="../assets/css/style.css">

    <!-- Ek Head İçerikleri (Varsa Favicon, Fontlar vb.) -->

</head>
<body>

    <header class="site-header">
        <h1>Katmanlı Mimari ile Geliştirilmiş Banka API'si</h1>
        <p class="subtitle">Kredi Kartı Yönetim Sistemi: Detaylı Bir .NET/C# Proje İncelemesi</p>
    </header>

    <main class="container">
        <article>
            
            <section id="giris">
                <h2>Giriş: Projeye Genel Bakış ve Önemi</h2>
                <p>Finansal teknolojilerin (FinTech) hızla geliştiği günümüz dünyasında, bankacılık hizmetlerinin dijitalleşmesi ve modern API'ler (Uygulama Programlama Arayüzleri) aracılığıyla sunulması büyük önem taşımaktadır. Bu belge, **katmanlı mimari** prensipleri kullanılarak C# programlama dili ve modern .NET platformu üzerinde geliştirilmiş bir **Banka API** projesini detaylı bir şekilde incelemektedir. API'nin temel odak noktası, **kredi kartı bilgilerinin yönetimi** olup, verilerin oluşturulması (Create), okunması (Retrieve), güncellenmesi (Update) ve silinmesi (Delete) gibi temel **CRUD** operasyonlarını kapsamaktadır.</p>
                <p>Bu proje, sağlam, sürdürülebilir, güvenli ve ölçeklenebilir API'ler geliştirmenin önemini vurgulamakta ve katmanlı mimarinin bu hedeflere ulaşmada nasıl kritik bir rol oynadığını göstermeyi amaçlamaktadır. Katmanlı mimari, kodun modülerliğini artırarak, farklı sorumlulukları birbirinden ayırarak (Separation of Concerns - SoC) test edilebilirliği ve bakım kolaylığını önemli ölçüde iyileştirir.</p>
                <p>Bu detaylı inceleme, aşağıdaki konuları kapsayacaktır:</p>
                <ul>
                    <li>Projenin genel yapısı ve bileşenleri.</li>
                    <li>Katmanlı mimarinin prensipleri ve projeye uygulanışı.</li>
                    <li>Kullanılan teknolojiler ve araçlar.</li>
                    <li>API tasarımı, endpoint tanımları ve veri modelleri.</li>
                    <li>Kredi kartı yönetimi ile ilgili iş mantığı detayları.</li>
                    <li>Veri erişimi ve veritabanı yönetimi stratejileri.</li>
                    <li>API güvenliği mekanizmaları ve en iyi uygulamalar.</li>
                    <li>Hata yönetimi ve günlükleme yaklaşımları.</li>
                    <li>Test stratejileri ve dağıtım süreçleri.</li>
                </ul>
                <p>Bu belge, hem .NET ile API geliştirme konusunda bilgi sahibi olmak isteyen geliştiricilere hem de katmanlı mimari prensiplerini finansal uygulamalar bağlamında anlamak isteyen yazılım mimarlarına ve teknik liderlere yönelik kapsamlı bir kaynak niteliğindedir.</p>
            </section>

            <section id="proje-yapisi">
                <h2>Proje Yapısı ve Bileşenleri</h2>
                <p>Sağlam bir API geliştirmenin temeli, iyi organize edilmiş bir proje yapısına dayanır. Katmanlı mimari, bu organizasyonu sağlamak için kanıtlanmış bir yaklaşımdır. Projemiz, tipik olarak aşağıdaki ana katmanlardan (veya proje/klasörlerden) oluşur:</p>
                <ul>
                    <li><strong>Core / Domain (Çekirdek / Alan Katmanı):</strong> Projenin kalbidir. İş alanına özgü temel varlıkları (Entities - örn: `CreditCard`), arayüzleri (Interfaces - örn: `ICreditCardRepository`, `ICreditCardService`), DTO'ları (Data Transfer Objects), enum'ları ve özel istisnaları içerir. Bu katman, diğer tüm katmanlar tarafından referans alınabilir ve en az bağımlılığa sahip olmalıdır (ideal olarak hiçbir dış teknolojiye bağımlı olmamalıdır).</li>
                    <li><strong>Infrastructure (Altyapı Katmanı):** Uygulamanın çalışması için gerekli olan ancak doğrudan iş mantığıyla ilgili olmayan teknik detayları barındırır. Veritabanı erişimi (EF Core DbContext implementasyonu), dış servis entegrasyonları (varsa), günlükleme (logging) konfigürasyonu, e-posta gönderimi gibi altyapısal görevlerin implementasyonlarını içerir. Genellikle Core katmanındaki arayüzleri uygular.</li>
                    <li><strong>Persistence / DataAccess (Kalıcılık / Veri Erişim Katmanı):** (Bazen Altyapı katmanının bir parçası olarak da düşünülebilir) Veritabanı ile doğrudan etkileşimden sorumludur. Repository pattern implementasyonlarını (`CreditCardRepository` vb.) ve Entity Framework Core gibi ORM araçlarının konfigürasyonunu içerir. Verilerin nasıl saklandığı ve erişildiği detaylarını diğer katmanlardan soyutlar.</li>
                    <li><strong>Business / Application (İş Mantığı / Uygulama Katmanı):** Uygulamanın ana iş kurallarını, süreçlerini ve mantığını içerir. Servis sınıfları (örn: `CreditCardService`) burada yer alır. Sunum/API katmanından gelen istekleri işler, gerekli doğrulamaları yapar, veri erişim katmanındaki repository'leri kullanarak veritabanı operasyonlarını koordine eder ve sonuçları sunum katmanına döndürür.</li>
                    <li><strong>Presentation / API (Sunum / API Katmanı):** Uygulamanın dış dünyaya açılan kapısıdır. Bu projede, RESTful API endpoint'lerini barındırır. ASP.NET Core Web API projesi genellikle bu katmanı temsil eder. Controller sınıfları (örn: `CreditCardsController`), istek/cevap modelleri (request/response models - genellikle DTO'lar), API yapılandırması ve yönlendirme (routing) kuralları burada bulunur. İş mantığı katmanındaki servisleri çağırır.</li>
                    <li><strong>Tests (Test Katmanı):** Uygulamanın farklı katmanları için birim testleri (Unit Tests) ve entegrasyon testleri (Integration Tests) içeren ayrı projelerden oluşur (örn: `BankAPI.Tests.Unit`, `BankAPI.Tests.Integration`).</li>
                </ul>
                <p>Bu yapı, her bir bileşenin kendi sorumluluğuna odaklanmasını sağlayarak kodun daha yönetilebilir, test edilebilir ve ölçeklenebilir olmasına yardımcı olur. Bağımlılıklar genellikle tek yönlüdür (örn: API -> Business -> DataAccess -> Core).</p>
            </section>

            <section id="katmanli-mimari-detay">
                <h2>Katmanlı Mimarinin Derinlemesine İncelenmesi</h2>
                <p>Katmanlı mimari, yazılım geliştirme dünyasında uzun yıllardır kullanılan ve kendini kanıtlamış bir tasarım desenidir. Temel amacı, bir uygulamanın farklı sorumluluklarını mantıksal katmanlara ayırmaktır.</p>
                
                <h3>Neden Katmanlı Mimari?</h3>
                <ul>
                    <li><strong>Sorumlulukların Ayrılması (Separation of Concerns - SoC):** Her katman belirli bir göreve odaklanır (örn: kullanıcı arayüzü, iş mantığı, veri erişimi). Bu, kodun anlaşılmasını ve yönetilmesini kolaylaştırır.</li>
                    <li><strong>Modülerlik:** Her katman nispeten bağımsızdır. Bir katmandaki değişiklikler (eğer arayüzler korunuyorsa) diğer katmanları minimum düzeyde etkiler.</li>
                    <li><strong>Bakım Kolaylığı:** Hata ayıklama ve yeni özellik ekleme süreçleri basitleşir. İlgili kod belirli bir katmanda bulunur.</li>
                    <li><strong>Test Edilebilirlik:** Her katman (özellikle iş mantığı ve veri erişim katmanları) bağımlılıkları soyutlayarak (arayüzler ve dependency injection ile) izole bir şekilde test edilebilir.</li>
                    <li><strong>Teknoloji Bağımsızlığı (Kısmen):** Örneğin, veri erişim katmanını değiştirerek (örn: EF Core'dan Dapper'a geçiş) veya sunum katmanını yeniden yazarak (örn: MVC'den Blazor'a geçiş) iş mantığı katmanını büyük ölçüde etkilemeden değişiklik yapmak mümkün olabilir.</li>
                    <li><strong>Tekrar Kullanılabilirlik:** Özellikle Core ve Business katmanlarındaki bileşenler, farklı sunum katmanları (örn: Web API, Masaüstü Uygulaması) tarafından potansiyel olarak tekrar kullanılabilir.</li>
                </ul>

                <h3>Katmanların Rolleri (Banka API Bağlamında)</h3>
                <ul>
                    <li><strong>API Katmanı (`CreditCardsController`):** HTTP isteklerini (GET, POST, PUT, DELETE) alır, gelen veriyi (JSON) DTO'lara dönüştürür, temel istek doğrulaması yapar (model state validation), ilgili `ICreditCardService` metodunu çağırır, servisten dönen sonucu (başarı veya hata) uygun HTTP durum kodu ve cevap gövdesi (JSON) ile istemciye döndürür.</li>
                    <li><strong>İş Mantığı Katmanı (`CreditCardService`):** API katmanından gelen istekleri alır (genellikle DTO'lar aracılığıyla). Kredi kartı oluşturma/güncelleme için karmaşık iş kurallarını uygular (örn: kart numarası geçerliliği kontrolü - Luhn algoritması, son kullanma tarihi kontrolü, limit kontrolleri vb.). Gerekli operasyonlar için `ICreditCardRepository` arayüzünü kullanır. Veri tutarlılığını sağlamak için Unit of Work desenini kullanabilir. Sonuçları (başarılıysa DTO, hatalıysa özel istisna) API katmanına iletir.</li>
                    <li><strong>Veri Erişim Katmanı (`CreditCardRepository`):** İş mantığı katmanından gelen talepler doğrultusunda veritabanı ile etkileşime girer. EF Core kullanarak kredi kartı verilerini sorgular (GET), yeni kart ekler (POST), mevcut kartı günceller (PUT) veya siler (DELETE). Veritabanına özgü kodlar burada bulunur.</li>
                    <li><strong>Core Katmanı:** `CreditCard` entity sınıfını, `ICreditCardRepository` ve `ICreditCardService` arayüzlerini, API ve İş Mantığı arasında veri taşımak için `CreditCardDto`, `CreateCreditCardDto`, `UpdateCreditCardDto` gibi DTO'ları, `CreditCardNotFoundException` gibi özel istisnaları tanımlar.</li>
                    <li><strong>Altyapı Katmanı:** Veritabanı bağlantı yönetimi (`DbContext`), loglama mekanizması (Serilog konfigürasyonu), varsa dış API çağrıları (örn: kart geçerliliği için harici bir servise istek) gibi destekleyici işlevleri sağlar.</li>
                </ul>
                <p>Bu net ayrım, projenin karmaşıklığı arttıkça bile kod tabanının düzenli ve yönetilebilir kalmasını sağlar.</p>
            </section>

            <section id="teknolojiler">
                <h2>Kullanılan Teknolojiler ve Araçlar</h2>
                <p>Bu Banka API projesini hayata geçirmek için modern .NET ekosistemindeki aşağıdaki temel teknolojiler ve araçlar kullanılmaktadır (veya kullanılması önerilir):</p>
                <ul>
                    <li><strong>.NET 8.0 (veya .NET 6+ LTS):** Microsoft'un güncel, yüksek performanslı ve platformlar arası (cross-platform) geliştirme platformu.</li>
                    <li><strong>C#:** .NET platformunun ana programlama dili. Güçlü, nesne yönelimli ve modern özelliklere sahip.</li>
                    <li><strong>ASP.NET Core:** Web uygulamaları ve özellikle RESTful API'ler geliştirmek için kullanılan açık kaynaklı framework. Yüksek performans, yerleşik dependency injection, middleware pipeline gibi özellikler sunar.</li>
                    <li><strong>Entity Framework Core (EF Core):** Popüler ORM (Object-Relational Mapper). Veritabanı işlemlerini C# nesneleri üzerinden yapmayı kolaylaştırır. LINQ desteği, migrasyon yönetimi gibi güçlü yeteneklere sahiptir.</li>
                    <li><strong>SQL Server / PostgreSQL:** İlişkisel veritabanı yönetim sistemleri. EF Core her ikisini de ve daha fazlasını destekler. Proje gereksinimlerine ve altyapı tercihlerine göre seçilir.</li>
                    <li><strong>RESTful Prensipleri:** API tasarımında kullanılan standart yaklaşım. Kaynak tabanlı URL'ler, standart HTTP metotları (GET, POST, PUT, DELETE, PATCH), durum kodları ve JSON formatında veri alışverişi.</li>
                    <li><strong>Swagger / OpenAPI:** API'leri belgelemek ve interaktif olarak test etmek için kullanılan standart. `Swashbuckle.AspNetCore` NuGet paketi ile ASP.NET Core projelerine kolayca entegre edilebilir.</li>
                    <li><strong>JSON (JavaScript Object Notation):** API'ler arasında veri alışverişi için kullanılan hafif ve okunabilir veri formatı. ASP.NET Core'da varsayılan format olarak desteklenir.</li>
                    <li><strong>Dependency Injection (DI):** ASP.NET Core'un temel bir parçası. Sınıflar arasındaki bağımlılıkları gevşek bağlamak (loose coupling) için kullanılır. Test edilebilirliği ve modülerliği artırır. Arayüzlerin (örn: `ICreditCardService`) ve somut sınıfların (`CreditCardService`) eşleştirilmesi IoC (Inversion of Control) konteyneri tarafından yönetilir.</li>
                    <li><strong>DTO (Data Transfer Object):** Katmanlar arasında (özellikle API ve İş Mantığı) veri taşımak için kullanılan basit sınıflar. API kontratını tanımlar ve iç domain modellerinin dışarı sızmasını engeller.</li>
                    <li><strong>AutoMapper / Mapster:** Varlıklar (Entities) ve DTO'lar arasındaki dönüşümleri otomatikleştiren kütüphaneler. Tekrarlayan map'leme kodunu azaltır.</li>
                    <li><strong>FluentValidation:** Nesneler (özellikle DTO'lar) için akıcı (fluent) bir arayüzle karmaşık doğrulama kuralları tanımlamayı sağlayan popüler bir kütüphane.</li>
                    <li><strong>Serilog / NLog:** Esnek ve yapılandırılabilir yapısal günlükleme (structured logging) kütüphaneleri. Uygulama olaylarını, hataları ve performans metriklerini çeşitli hedeflere (dosya, konsol, veritabanı, Seq, Application Insights vb.) loglamak için kullanılır.</li>
                    <li><strong>JWT (JSON Web Tokens) / OAuth 2.0 / API Keys:** API güvenliği için kullanılan kimlik doğrulama ve yetkilendirme mekanizmaları. Projenin güvenlik gereksinimlerine göre biri veya birkaçı tercih edilir.</li>
                    <li><strong>xUnit / NUnit / MSTest:** .NET için popüler birim testi (unit testing) framework'leri.</li>
                    <li><strong>Moq / NSubstitute:** Birim testlerinde bağımlılıkları taklit etmek (mocking/stubbing) için kullanılan kütüphaneler.</li>
                    <li><strong>Docker:** Uygulamayı ve bağımlılıklarını konteyner içinde paketleyerek taşınabilirliği ve dağıtım kolaylığını artırır.</li>
                    <li><strong>Git:** Kod versiyon kontrol sistemi (GitHub, GitLab, Azure Repos ile birlikte).</li>
                    <li><strong>Postman / Insomnia:** API'leri manuel olarak test etmek ve istek göndermek için kullanılan popüler araçlar.</li>
                    <li><strong>CI/CD Araçları (Azure DevOps, GitHub Actions, Jenkins):** Sürekli Entegrasyon ve Sürekli Dağıtım süreçlerini otomatikleştirmek için kullanılır.</li>
                </ul>
                <p>Bu araçlar ve teknolojiler, modern, güvenli ve sürdürülebilir bir Banka API'si geliştirmek için sağlam bir temel oluşturur.</p>
            </section>

             <section id="api-tasarimi">
                <h2>API Tasarımı: Endpoint'ler ve Veri Modelleri</h2>
                <p>İyi tasarlanmış bir API, anlaşılması, kullanılması ve entegre edilmesi kolay olandır. RESTful prensiplerine bağlı kalarak Banka API'miz için temel endpoint'leri ve veri modellerini (DTO'ları) tanımlayabiliriz.</p>

                <h3>RESTful Prensipleri</h3>
                <ul>
                    <li><strong>Kaynak Odaklılık:** Her URL bir kaynağı (resource) temsil eder (örn: `/api/creditcards`).</li>
                    <li><strong>Standart HTTP Metotları:** Kaynak üzerinde yapılacak işlemler için standart HTTP fiilleri kullanılır:
                        <ul>
                            <li>`GET`: Kaynakları okumak için (Liste veya tekil).</li>
                            <li>`POST`: Yeni bir kaynak oluşturmak için.</li>
                            <li>`PUT`: Mevcut bir kaynağı tamamen güncellemek için.</li>
                            <li>`DELETE`: Bir kaynağı silmek için.</li>
                            <li>`PATCH`: Bir kaynağı kısmen güncellemek için (opsiyonel).</li>
                        </ul>
                    </li>
                    <li><strong>Durumsuzluk (Statelessness):** Sunucu, istemciden gelen her isteği, önceki isteklerden bağımsız olarak anlayabilmelidir. Oturum bilgisi genellikle istemci tarafında (örn: token ile) tutulur.</li>
                    <li>**İstemci-Sunucu Mimarisi:** İstemci ve sunucu birbirinden bağımsızdır, bu da her ikisinin de ayrı ayrı geliştirilebilmesini sağlar.</li>
                    <li><strong>Tutarlı Arayüz:** Kaynakların nasıl temsil edileceği (genellikle JSON), hataların nasıl bildirileceği (HTTP durum kodları ve hata mesajları) konusunda tutarlı bir yaklaşım benimsenir.</li>
                </ul>

                <h3>Örnek Endpoint'ler (`/api/creditcards`)</h3>
                <ul>
                    <li><strong>`POST /api/creditcards`:**
                        <ul>
                            <li>**Açıklama:** Yeni bir kredi kartı oluşturur.</li>
                            <li>**İstek Gövdesi (Request Body):** `CreateCreditCardDto` (örn: CardHolderName, CardNumber, ExpiryMonth, ExpiryYear, CVV).</li>
                            <li>**Başarılı Cevap:** `201 Created` durum kodu, `Location` başlığında yeni oluşturulan kaynağın URL'si ve cevap gövdesinde `CreditCardDto`.</li>
                            <li>**Hatalı Cevap:** `400 Bad Request` (geçersiz veri), `409 Conflict` (kart zaten mevcutsa).</li>
                        </ul>
                    </li>
                    <li><strong>`GET /api/creditcards`:**
                        <ul>
                            <li>**Açıklama:** Tüm kredi kartlarını (veya sayfalanmış listeyi) getirir. (Genellikle admin veya özel yetki gerektirir).</li>
                            <li>**Başarılı Cevap:** `200 OK` durum kodu ve cevap gövdesinde `List<CreditCardDto>`. (Güvenlik notu: Genellikle tüm kartları listelemek yerine ID ile getirme tercih edilir).</li>
                            <li>**Hatalı Cevap:** `401 Unauthorized`, `403 Forbidden`.</li>
                        </ul>
                    </li>
                    <li><strong>`GET /api/creditcards/{id}`:**
                        <ul>
                            <li>**Açıklama:** Belirtilen ID'ye sahip kredi kartını getirir.</li>
                            <li>**Başarılı Cevap:** `200 OK` durum kodu ve cevap gövdesinde `CreditCardDto`.</li>
                            <li>**Hatalı Cevap:** `404 Not Found` (kart bulunamazsa), `401 Unauthorized`, `403 Forbidden`.</li>
                        </ul>
                    </li>
                    <li><strong>`PUT /api/creditcards/{id}`:**
                        <ul>
                            <li>**Açıklama:** Belirtilen ID'ye sahip kredi kartını günceller. `PUT` genellikle kaynağın tamamını güncellemeyi ima eder.</li>
                            <li>**İstek Gövdesi:** `UpdateCreditCardDto` (güncellenecek tüm alanları içerir).</li>
                            <li>**Başarılı Cevap:** `200 OK` veya `204 No Content`.</li>
                            <li>**Hatalı Cevap:** `400 Bad Request` (geçersiz veri), `404 Not Found`, `401 Unauthorized`, `403 Forbidden`.</li>
                        </ul>
                    </li>
                     <li><strong>`DELETE /api/creditcards/{id}`:**
                        <ul>
                            <li>**Açıklama:** Belirtilen ID'ye sahip kredi kartını siler (veya pasifize eder).</li>
                            <li>**Başarılı Cevap:** `204 No Content` veya `200 OK`.</li>
                            <li>**Hatalı Cevap:** `404 Not Found`, `401 Unauthorized`, `403 Forbidden`.</li>
                        </ul>
                    </li>
                </ul>

                <h3>Veri Modelleri (DTO - Data Transfer Objects)</h3>
                <p>API katmanı ile iş mantığı katmanı arasında ve API'nin dış dünya ile iletişiminde DTO'lar kullanılır. Bu, iç varlık (entity) yapısını gizler ve API kontratını netleştirir.</p>
                ```csharp
                // Örnek DTO'lar (Core katmanında tanımlanır)

                // Kart bilgilerini döndürmek için kullanılan DTO (Hassas veriler maskelenmiş veya çıkarılmış olabilir)
                public class CreditCardDto
                {
                    public Guid Id { get; set; }
                    public string CardHolderName { get; set; }
                    public string MaskedCardNumber { get; set; } // Örn: **** **** **** 1234
                    public int ExpiryMonth { get; set; }
                    public int ExpiryYear { get; set; }
                    public DateTime CreatedAt { get; set; }
                }

                // Yeni kart oluşturma isteği için DTO
                public class CreateCreditCardDto
                {
                    [Required]
                    [StringLength(100)]
                    public string CardHolderName { get; set; }

                    [Required]
                    [CreditCard] // .NET'in yerleşik veya özel bir validator olabilir
                    public string CardNumber { get; set; }

                    [Required]
                    [Range(1, 12)]
                    public int ExpiryMonth { get; set; }

                    [Required]
                    [Range(2024, 2034)] // Örnek aralık
                    public int ExpiryYear { get; set; }

                    [Required]
                    [StringLength(3, MinimumLength = 3)] // veya 4 (Amex)
                    public string CVV { get; set; }
                }

                // Kart güncelleme isteği için DTO (Güncellenmesine izin verilen alanlar)
                public class UpdateCreditCardDto
                {
                    [Required]
                    [StringLength(100)]
                    public string CardHolderName { get; set; }

                    // Kart Numarası genellikle güncellenmez, ancak örnek olarak eklenebilir
                    // [CreditCard]
                    // public string? CardNumber { get; set; } 

                    [Required]
                    [Range(1, 12)]
                    public int ExpiryMonth { get; set; }

                    [Required]
                    [Range(2024, 2034)]
                    public int ExpiryYear { get; set; }
                    
                    // CVV genellikle güncellenmez veya saklanmaz, doğrulamada kullanılır
                }
                ```
                <p>Bu DTO'lar, API'nin ne beklediğini ve ne döndüreceğini açıkça tanımlar. Veri doğrulama (validation) için Data Annotations (`[Required]`, `[StringLength]`) veya FluentValidation kullanılabilir.</p>

                 <h3>API Versiyonlama</h3>
                 <p>API'ler zamanla değişebilir. Mevcut istemcileri bozmadan API'yi geliştirmek için versiyonlama stratejileri kullanılır:</p>
                 <ul>
                     <li><strong>URL Versiyonlama:** `/api/v1/creditcards`, `/api/v2/creditcards`</li>
                     <li>**Header Versiyonlama:** HTTP başlığında versiyon bilgisi gönderme (örn: `X-Api-Version: 2.0`).</li>
                     <li>**Query String Versiyonlama:** `/api/creditcards?api-version=1.0`</li>
                 </ul>
                 <p>ASP.NET Core API Versioning kütüphanesi bu stratejileri uygulamayı kolaylaştırır.</p>

                 <h3>API Dokümantasyonu (Swagger/OpenAPI)</h3>
                 <p>Swagger UI, API endpoint'lerini, beklenen istek/cevap formatlarını ve parametreleri listeleyen interaktif bir dokümantasyon sayfası oluşturur. Geliştiricilerin API'yi anlamasını ve test etmesini kolaylaştırır. `Swashbuckle.AspNetCore` paketi ile Controller'lar ve DTO'lar üzerindeki XML yorumları veya Data Annotations kullanılarak otomatik olarak oluşturulabilir.</p>

            </section>


            <section id="is-mantigi">
                <h2>Kredi Kartı Yönetimi: İş Mantığı Detayları</h2>
                <p>İş Mantığı Katmanı (BLL), uygulamanın çekirdek işlevselliğini barındırır. Kredi kartı yönetimi API'sinde bu katman, CRUD operasyonlarının ötesinde önemli doğrulamalar ve iş kuralları içerir:</p>
                <ul>
                    <li><strong>Veri Doğrulama (Validation):**
                        <ul>
                            <li>**Kart Numarası Geçerliliği:** Sadece format değil, Luhn algoritması gibi sağlama toplamı (checksum) algoritmaları ile kart numarasının matematiksel olarak geçerli olup olmadığını kontrol etmek.</li>
                            <li>**Son Kullanma Tarihi Geçerliliği:** Geçmiş bir tarih olmamasını ve mantıklı bir gelecekte olmasını sağlamak.</li>
                            <li>**CVV Formatı:** Kart tipine göre doğru uzunlukta (genellikle 3 veya 4 haneli) olmasını kontrol etmek.</li>
                            <li>**Kart Sahibi Adı:** Boş olmamasını ve makul bir uzunlukta olmasını sağlamak.</li>
                            <li>**Benzersizlik Kontrolleri:** Gerekirse, aynı kart numarasının sisteme tekrar eklenmesini engellemek (iş gereksinimlerine bağlı).</li>
                        </ul>
                    </li>
                    <li><strong>İş Kuralları:**
                        <ul>
                            <li>**Limit Kontrolleri:** (Eğer API bakiye veya işlem yönetimi de içeriyorsa) Yeni bir işlem öncesi kart limitinin yeterli olup olmadığını kontrol etmek.</li>
                            <li>**Kart Durumu Yönetimi:** Kartın aktif, bloke edilmiş, süresi dolmuş gibi durumlarını yönetmek ve işlemleri bu duruma göre kısıtlamak.</li>
                            <li>**Güvenlik Kuralları:** Belirli sayıda hatalı CVV girişinden sonra kartı geçici olarak bloke etmek gibi dolandırıcılık önleme kuralları.</li>
                        </ul>
                    </li>
                    <li><strong>Veri Dönüşümleri:** Veri Erişim Katmanı'ndan gelen Varlık (Entity) nesnelerini, API katmanına döndürülecek DTO'lara dönüştürmek. Bu sırada hassas verilerin (tam kart numarası, CVV) maskelenmesi veya tamamen çıkarılması gerekir. CVV gibi veriler genellikle saklanmaz, sadece doğrulama anında kullanılır.</li>
                    <li><strong>İşlem Yönetimi (Transaction Management):** Birden fazla veritabanı operasyonu gerektiren iş akışlarında (örn: kart oluşturma ve ilgili hesapla ilişkilendirme), tüm adımların başarılı olmasını veya başarısızlık durumunda tüm değişikliklerin geri alınmasını (rollback) sağlamak için Unit of Work deseni kullanılır.</li>
                    <li><strong>Dış Servis Entegrasyonları:** Gerekirse, kart geçerliliğini doğrulamak veya risk analizi yapmak için harici finansal servislerle iletişim kurmak.</li>
                </ul>
                <p>Bu mantık, genellikle `CreditCardService` gibi servis sınıfları içinde implemente edilir ve bu servisler Dependency Injection ile API Controller'larına enjekte edilir.</p>
                 ```csharp
                 // Örnek Servis Arayüzü (Core Katmanı)
                 public interface ICreditCardService
                 {
                     Task<CreditCardDto?> GetCreditCardByIdAsync(Guid id);
                     Task<IEnumerable<CreditCardDto>> GetAllCreditCardsAsync(); // Dikkat: Genellikle önerilmez
                     Task<CreditCardDto> CreateCreditCardAsync(CreateCreditCardDto createDto);
                     Task<bool> UpdateCreditCardAsync(Guid id, UpdateCreditCardDto updateDto);
                     Task<bool> DeleteCreditCardAsync(Guid id);
                     // Muhtemelen ek metotlar: ValidateCardAsync, BlockCardAsync etc.
                 }

                 // Örnek Servis Implementasyonu (İş Mantığı Katmanı)
                 public class CreditCardService : ICreditCardService
                 {
                     private readonly ICreditCardRepository _repository;
                     private readonly IUnitOfWork _unitOfWork; // Veya DbContext doğrudan
                     private readonly IMapper _mapper; // AutoMapper örneği
                     // private readonly ILogger<CreditCardService> _logger; // Loglama için

                     public CreditCardService(ICreditCardRepository repository, IUnitOfWork unitOfWork, IMapper mapper /*, ILogger<CreditCardService> logger*/)
                     {
                         _repository = repository;
                         _unitOfWork = unitOfWork;
                         _mapper = mapper;
                         //_logger = logger;
                     }

                     public async Task<CreditCardDto> CreateCreditCardAsync(CreateCreditCardDto createDto)
                     {
                         // 1. Gelişmiş Doğrulama (FluentValidation ile yapılabilir veya burada)
                         if (!IsValidLuhn(createDto.CardNumber))
                         {
                             throw new ArgumentException("Geçersiz kredi kartı numarası.");
                         }
                         if (IsExpired(createDto.ExpiryYear, createDto.ExpiryMonth))
                         {
                             throw new ArgumentException("Kredi kartının son kullanma tarihi geçmiş.");
                         }
                         
                         // 2. DTO'yu Varlığa Dönüştürme (AutoMapper veya manuel)
                         var newCard = _mapper.Map<CreditCard>(createDto);
                         
                         // Önemli: Gerçek kart numarasını ve CVV'yi doğrudan saklama!
                         // Genellikle sadece son 4 hane veya tokenizasyon gibi yöntemler kullanılır.
                         // Bu örnekte basitleştirilmiştir. CVV ASLA SAKLANMAMALIDIR.
                         // newCard.MaskedNumber = MaskCardNumber(createDto.CardNumber); 
                         // newCard.HashedCVV = HashCVV(createDto.CVV); // CVV hash'lenmez, saklanmaz.

                         newCard.Id = Guid.NewGuid();
                         newCard.CreatedAt = DateTime.UtcNow;

                         // 3. Repository aracılığıyla ekleme
                         await _repository.AddAsync(newCard);

                         // 4. Değişiklikleri Kaydetme (Unit of Work)
                         await _unitOfWork.SaveChangesAsync(); 
                         //_logger.LogInformation("Yeni kredi kartı oluşturuldu: {CardId}", newCard.Id);

                         // 5. Sonucu DTO olarak döndürme (Hassas veriler hariç)
                         return _mapper.Map<CreditCardDto>(newCard);
                     }

                     // ... Diğer CRUD metot implementasyonları ...

                     private bool IsValidLuhn(string cardNumber) { /* ... Luhn algoritması implementasyonu ... */ return true; }
                     private bool IsExpired(int year, int month) { /* ... Tarih kontrolü ... */ return false; }
                     // private string MaskCardNumber(string cardNumber) { /* ... Maskeleme ... */ }
                 }
                 ```
            </section>

            <section id="veri-erisim">
                <h2>Veri Erişimi ve Veritabanı Yönetimi</h2>
                <p>Veri Erişim Katmanı (DAL), uygulamanın veritabanı ile olan tüm etkileşimlerini yönetir ve bu detayları üst katmanlardan soyutlar.</p>
                <ul>
                    <li><strong>ORM Kullanımı (Entity Framework Core):**
                        <ul>
                            <li><strong>DbContext:** Veritabanı oturumunu temsil eder. Veritabanı bağlantısını, varlıkların (Entities) veritabanı tablolarıyla eşleşmesini (mapping) ve değişiklik takibini yönetir. `OnModelCreating` metodu, varlık yapılandırmaları (Fluent API) için kullanılır.</li>
                            <li><strong>DbSet<T>:** Veritabanındaki bir tabloyu temsil eden koleksiyonlardır (örn: `DbSet<CreditCard> CreditCards`). LINQ sorguları bu nesneler üzerinden yapılır.</li>
                            <li><strong>LINQ (Language Integrated Query):** EF Core, LINQ sorgularını (örn: `context.CreditCards.Where(c => c.Id == id).FirstOrDefaultAsync()`) veritabanının anlayacağı SQL sorgularına çevirir.</li>
                            <li><strong>Asenkron Operasyonlar:** Performans ve ölçeklenebilirlik için veritabanı operasyonlarının (`SaveChangesAsync`, `ToListAsync`, `FirstOrDefaultAsync` vb.) asenkron (`async`/`await`) olarak yapılması şiddetle tavsiye edilir.</li>
                            <li><strong>Migrasyonlar (Migrations):** Veritabanı şemasını kod tabanlı olarak (C#) yönetmeyi sağlar. Model (Entity) sınıflarında yapılan değişiklikleri veritabanına uygulamak için kullanılır (`dotnet ef migrations add`, `dotnet ef database update`).</li>
                        </ul>
                    </li>
                    <li><strong>Repository Pattern:**
                        <ul>
                            <li>**Amaç:** Veri erişim mantığını merkezileştirmek ve iş mantığı katmanını belirli bir ORM veya veritabanı teknolojisine doğrudan bağımlılıktan kurtarmak.</li>
                            <li>**Uygulama:** Her bir ana varlık (Aggregate Root) için bir arayüz (örn: `ICreditCardRepository`) ve onun somut implementasyonu (`CreditCardRepository`) oluşturulur. Repository, temel CRUD operasyonları (`GetByIdAsync`, `GetAllAsync`, `AddAsync`, `UpdateAsync`, `DeleteAsync`) ve özel sorgular için metotlar içerir.</li>
                            <li>**Generic Repository (Opsiyonel):** Tekrarlayan CRUD operasyonları için soyut bir `IRepository<T>` ve `Repository<T>` sınıfı oluşturulabilir.</li>
                        </ul>
                    </li>
                    <li><strong>Unit of Work Pattern:**
                        <ul>
                            <li>**Amaç:** Tek bir iş işlemi (business transaction) sırasında yapılan birden fazla veritabanı değişikliğini (ekleme, güncelleme, silme) tek bir atomik birim olarak yönetmek.</li>
                            <li>**Uygulama:** Genellikle `DbContext`'in `SaveChangesAsync()` metodu bu görevi üstlenir. Ayrı bir `IUnitOfWork` arayüzü ve implementasyonu oluşturularak, `SaveChangesAsync` çağrısının kontrolü merkezileştirilebilir ve birden fazla repository'nin aynı `DbContext` instance'ını paylaşması sağlanabilir.</li>
                        </ul>
                    </li>
                    <li><strong>Veritabanı Şeması Tasarımı:**
                        <ul>
                            <li>`CreditCards` tablosu temel alanları (Id, CardHolderName, MaskedNumber, ExpiryMonth, ExpiryYear, CreatedAt vb.) içerir.</li>
                            <li>İlişkiler (varsa, örn: Müşteri tablosu ile) Foreign Key'ler ile kurulur.</li>
                            <li>İndeksler (Indexes), sık kullanılan sorgu alanları (örn: Id, belki CardHolderName) üzerinde performans artışı için tanımlanmalıdır.</li>
                            <li>**Hassas Veri Saklama:** Tam kredi kartı numarası ve CVV **asla** veritabanında saklanmamalıdır. PCI DSS (Payment Card Industry Data Security Standard) uyumluluğu kritik öneme sahiptir. Genellikle kart numarası yerine bir token saklanır (tokenization) veya sadece son 4 hane gibi maskelenmiş veriler tutulur.</li>
                        </ul>
                    </li>
                </ul>
                 ```csharp
                  // Örnek Repository Arayüzü (Core Katmanı)
                 public interface ICreditCardRepository
                 {
                     Task<CreditCard?> GetByIdAsync(Guid id);
                     Task<IEnumerable<CreditCard>> GetAllAsync(); // Dikkat!
                     Task AddAsync(CreditCard creditCard);
                     void Update(CreditCard creditCard); // EF Core değişiklik takibi yapar
                     void Delete(CreditCard creditCard); // EF Core değişiklik takibi yapar
                     // Task<CreditCard?> FindByCardNumberAsync(string cardNumber); // Özel sorgu örneği
                 }

                 // Örnek Repository Implementasyonu (Persistence/DataAccess Katmanı)
                 public class CreditCardRepository : ICreditCardRepository
                 {
                     private readonly BankApiDbContext _context; // DbContext DI ile alınır

                     public CreditCardRepository(BankApiDbContext context)
                     {
                         _context = context;
                     }

                     public async Task<CreditCard?> GetByIdAsync(Guid id)
                     {
                         return await _context.CreditCards.FindAsync(id);
                     }

                     public async Task<IEnumerable<CreditCard>> GetAllAsync()
                     {
                         // Dikkat: Büyük tablolar için bu tehlikeli olabilir, sayfalama gerekir.
                         return await _context.CreditCards.ToListAsync(); 
                     }

                     public async Task AddAsync(CreditCard creditCard)
                     {
                         await _context.CreditCards.AddAsync(creditCard);
                     }

                     public void Update(CreditCard creditCard)
                     {
                         // EF Core, varlığı takip ettiği için 'Update' metodu çağrısı
                         // bazen gerekmeyebilir, sadece özellikler değiştirilir.
                         // Ancak açıkça belirtmek için:
                         _context.CreditCards.Update(creditCard);
                         // Veya sadece durumunu değiştirme:
                         // _context.Entry(creditCard).State = EntityState.Modified;
                     }

                      public void Delete(CreditCard creditCard)
                     {
                         _context.CreditCards.Remove(creditCard);
                     }
                 }

                 // Örnek Unit of Work Arayüzü (Core Katmanı - Opsiyonel ama önerilir)
                 public interface IUnitOfWork : IDisposable
                 {
                     ICreditCardRepository CreditCards { get; }
                     // Diğer repository'ler (varsa)
                     // ICustomerRepository Customers { get; } 
                     Task<int> SaveChangesAsync(CancellationToken cancellationToken = default);
                 }

                 // Örnek Unit of Work Implementasyonu (Persistence/DataAccess Katmanı)
                 public class UnitOfWork : IUnitOfWork
                 {
                     private readonly BankApiDbContext _context;
                     private ICreditCardRepository? _creditCardRepository;
                     // Diğer repository field'ları

                     public UnitOfWork(BankApiDbContext context)
                     {
                         _context = context;
                     }

                     public ICreditCardRepository CreditCards => _creditCardRepository ??= new CreditCardRepository(_context);
                     // Diğer repository property'leri

                     public async Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
                     {
                         return await _context.SaveChangesAsync(cancellationToken);
                     }

                     public void Dispose()
                     {
                         _context.Dispose();
                         GC.SuppressFinalize(this);
                     }
                 }
                 ```
            </section>

            <section id="guvenlik-mekanizmalari">
                <h2>API Güvenliği Mekanizmaları</h2>
                <p>Finansal verilerle çalışan bir API için güvenlik en üst düzeyde öncelik taşır. Aşağıdaki mekanizmalar ve prensipler dikkate alınmalıdır:</p>
                <ul>
                    <li><strong>Kimlik Doğrulama (Authentication):** API'yi çağıran istemcinin veya kullanıcının kim olduğunu doğrulamak.
                        <ul>
                            <li><strong>API Anahtarları (API Keys):** Basit senaryolar ve sunucudan sunucuya iletişim için kullanılabilir. Anahtar, HTTP başlığında (`X-API-Key`) gönderilir. Yönetimi ve güvenli saklanması önemlidir.</li>
                            <li><strong>OAuth 2.0:** Yetkilendirme için endüstri standardı bir framework. Farklı akışları (Authorization Code, Client Credentials vb.) destekler. Kullanıcıların veya uygulamaların belirli kaynaklara erişim izni vermesini sağlar. Daha karmaşık ama daha güvenlidir.</li>
                            <li><strong>JWT (JSON Web Tokens):** Kimliği doğrulanmış kullanıcılar için erişim token'ları oluşturmakta yaygın olarak kullanılır. Token, kullanıcının kimliğini ve yetkilerini (claims) içerir ve her istekte `Authorization: Bearer <token>` başlığında gönderilir. Sunucuda oturum bilgisi tutmayı gerektirmez (stateless).</li>
                            <li><strong>ASP.NET Core Identity:** Eğer API, doğrudan son kullanıcılarla (web/mobil uygulama üzerinden) etkileşimde bulunacaksa, kullanıcı yönetimi, parola hash'leme, token üretimi gibi konularda yardımcı olabilir.</li>
                        </ul>
                    </li>
                    <li><strong>Yetkilendirme (Authorization):** Kimliği doğrulanmış bir kullanıcının veya istemcinin hangi kaynaklara ve işlemlere erişebileceğini kontrol etmek.
                        <ul>
                            <li><strong>Rol Bazlı Yetkilendirme (RBAC):** Kullanıcılara roller (örn: Admin, User, Viewer) atanır ve endpoint'lere `[Authorize(Roles = "Admin")]` gibi attribute'lar eklenerek erişim kısıtlanır.</li>
                            <li><strong>Politika Bazlı Yetkilendirme (Policy-Based):** Daha esnek bir modeldir. Belirli taleplere (claims) veya özel gereksinimlere dayalı politikalar tanımlanır (`[Authorize(Policy = "CanManageCreditCards")]`).</li>
                        </ul>
                    </li>
                    <li><strong>HTTPS Zorunluluğu:** Tüm API iletişiminin şifrelenmesi (TLS/SSL) hayati öneme sahiptir. ASP.NET Core'da HTTPS yönlendirmesi (redirect) ve HSTS (HTTP Strict Transport Security) yapılandırılmalıdır.</li>
                    <li><strong>Girdi Doğrulama (Input Validation):** API'ye gelen tüm verilerin (parametreler, başlıklar, istek gövdeleri) titizlikle doğrulanması. Beklenmeyen veya zararlı girdileri reddetmek (örn: SQL Injection, XSS önleme). DTO'larda Data Annotations veya FluentValidation kullanmak.</li>
                    <li><strong>Veri Maskeleme ve Şifreleme:** Cevaplarda hassas verilerin (örn: tam kart numarası) maskelenmesi. Saklanması gereken hassas konfigürasyon verilerinin (örn: veritabanı bağlantı dizeleri, API anahtarları) şifrelenmesi (Azure Key Vault, AWS Secrets Manager, .NET User Secrets).</li>
                    <li><strong>Hız Sınırlama (Rate Limiting):** Belirli bir zaman diliminde bir istemcinin yapabileceği istek sayısını sınırlayarak kötüye kullanımı (brute-force saldırıları, DoS) önlemek. `AspNetCoreRateLimit` gibi kütüphaneler kullanılabilir.</li>
                    <li><strong>Güvenlik Başlıkları (Security Headers):** Tarayıcı tabanlı saldırıları azaltmak için `X-Content-Type-Options: nosniff`, `X-Frame-Options: DENY`, `Content-Security-Policy (CSP)` gibi HTTP başlıklarını ayarlamak.</li>
                    <li><strong>Hata Mesajları:** Üretim ortamında detaylı sistem veya veritabanı hata mesajlarını istemciye göstermemek. Genel hata mesajları kullanılmalı, detaylar güvenli bir şekilde loglanmalıdır.</li>
                    <li><strong>PCI DSS Uyumluluğu:** Kredi kartı verilerini işleyen veya saklayan sistemler için Payment Card Industry Data Security Standard'ına uyum sağlamak zorunludur. Bu, güvenli ağ yapılandırması, kart sahibi verilerinin korunması, güvenlik açığı yönetimi, güçlü erişim kontrolü, düzenli izleme ve test etme gibi birçok gereksinimi içerir. **Tam kart numarasını ve CVV'yi saklamamak bu uyumluluğun temel adımıdır.**</li>
                    <li><strong>Düzenli Güvenlik Taramaları ve Güncellemeler:** Kullanılan kütüphanelerin ve .NET platformunun güvenlik açıklarına karşı güncel tutulması ve düzenli olarak güvenlik taramalarından geçirilmesi.</li>
                </ul>
            </section>

            <section id="hata-yonetimi-loglama">
                <h2>Hata Yönetimi ve Günlükleme (Logging)</h2>
                <p>Sağlam bir API, hataları zarif bir şekilde yönetmeli ve sorunları teşhis etmek için yeterli bilgiyi loglamalıdır.</p>
                <h3>Hata Yönetimi</h3>
                <ul>
                    <li><strong>Tutarlı Hata Cevapları:** API, hatalı durumlarda standart bir JSON formatında cevap dönmelidir. Bu format genellikle bir hata kodu (uygulamaya özgü), bir hata mesajı ve bazen ek detaylar içerir.</li>
                    <li><strong>HTTP Durum Kodları:** REST prensiplerine uygun olarak doğru HTTP durum kodları kullanılmalıdır:
                        <ul>
                            <li>`2xx` (Başarılı): `200 OK`, `201 Created`, `204 No Content`.</li>
                            <li>`4xx` (İstemci Hataları): `400 Bad Request` (geçersiz girdi), `401 Unauthorized` (kimlik doğrulama gerekli/başarısız), `403 Forbidden` (yetki yok), `404 Not Found` (kaynak bulunamadı), `409 Conflict` (çakışma), `429 Too Many Requests` (hız sınırı aşıldı).</li>
                            <li>`5xx` (Sunucu Hataları): `500 Internal Server Error` (beklenmedik sunucu hatası), `503 Service Unavailable` (servis geçici olarak devre dışı).</li>
                        </ul>
                    </li>
                    <li><strong>Global Exception Handling:** Beklenmeyen hataları yakalamak ve tutarlı bir hata cevabı döndürmek için ASP.NET Core'da bir middleware kullanılabilir. Bu middleware, yakalanan istisnaları (exceptions) loglar ve istemciye güvenli bir hata mesajı gönderir.</li>
                    <li><strong>Özel İstisnalar (Custom Exceptions):** İş mantığı katmanında belirli hata durumları için özel istisnalar tanımlamak (örn: `CreditCardNotFoundException`, `InsufficientFundsException`). Global exception handler bu özel istisnaları yakalayıp uygun HTTP durum kodlarına çevirebilir.</li>
                </ul>
                <h3>Günlükleme (Logging)</h3>
                <ul>
                    <li><strong>Yapısal Günlükleme (Structured Logging):** Log mesajlarını sadece metin olarak değil, anahtar-değer çiftleri içeren yapısal bir formatta (genellikle JSON) kaydetmek. Bu, logların daha kolay sorgulanmasını ve analiz edilmesini sağlar. Serilog ve NLog popüler yapısal günlükleme kütüphaneleridir.</li>
                    <li><strong>Log Seviyeleri:** Farklı önem derecelerine göre loglama yapmak (Verbose, Debug, Information, Warning, Error, Fatal). Üretim ortamında genellikle Information ve üzeri seviyeler loglanır.</li>
                    <li><strong>Ne Loglanmalı:**
                        <ul>
                            <li>İstek başlangıç ve bitişleri (süre, durum kodu, endpoint bilgisi).</li>
                            <li>Önemli iş olayları (örn: yeni kart oluşturuldu, kart bloke edildi).</li>
                            <li>Hatalar ve istisnalar (stack trace dahil).</li>
                            <li>Güvenlik olayları (başarılı/başarısız girişler, yetkilendirme hataları).</li>
                            <li>Performans metrikleri (veritabanı sorgu süreleri vb.).</li>
                        </ul>
                    </li>
                    <li><strong>Ne Loglanmamalı:** **Kesinlikle hassas veriler (tam kredi kartı numaraları, CVV'ler, parolalar, kişisel kimlik bilgileri) loglanmamalıdır.**</li>
                    <li><strong>Log Hedefleri:** Loglar dosyaya, konsola, merkezi log yönetim sistemlerine (Seq, ELK Stack, Splunk, Azure Application Insights, AWS CloudWatch Logs) gönderilebilir. Merkezi sistemler, logların toplanmasını, aranmasını ve analiz edilmesini kolaylaştırır.</li>
                    <li>**Korelasyon ID'si (Correlation ID):** Bir isteğin farklı katmanlar veya servisler arasındaki yolculuğunu takip etmek için her isteğe benzersiz bir ID atamak ve bu ID'yi tüm ilgili log mesajlarına eklemek. Sorun gidermeyi kolaylaştırır.</li>
                </ul>
                 ```csharp
                 // Örnek Serilog Yapılandırması (Program.cs veya Startup.cs)
                 // using Serilog;
                 // ...

                 // Log.Logger = new LoggerConfiguration()
                 //     .MinimumLevel.Information() // Minimum log seviyesi
                 //     .MinimumLevel.Override("Microsoft.AspNetCore", LogEventLevel.Warning) // ASP.NET Core loglarını azaltma
                 //     .Enrich.FromLogContext() // Log context'inden gelen bilgileri ekle
                 //     .Enrich.WithCorrelationId() // Korelasyon ID'si ekle (nuget paketi gerekir)
                 //     .WriteTo.Console() // Konsola yaz
                 //     .WriteTo.File("logs/bankapi-.txt", rollingInterval: RollingInterval.Day, // Günlük dosyaya yaz
                 //         outputTemplate: "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u3}] {CorrelationId} {Message:lj}{NewLine}{Exception}") 
                 //     // .WriteTo.Seq("http://your-seq-instance:5341") // Merkezi log sunucusuna gönder
                 //     .CreateLogger();

                 // builder.Host.UseSerilog(); // Serilog'u host ile entegre etme

                 // Örnek Log Kullanımı (Controller veya Servis içinde)
                 // private readonly ILogger<CreditCardsController> _logger;
                 // ... DI ile logger alınır ...
                 // _logger.LogInformation("Kredi kartı getiriliyor: {CardId}", id); 
                 // try { ... } catch(Exception ex) { _logger.LogError(ex, "Kredi kartı getirilirken hata oluştu: {CardId}", id); }
                 ```
            </section>

            <section id="test-dagitim">
                <h2>Test Stratejileri ve Dağıtım</h2>
                <p>API'nin doğruluğunu, performansını ve güvenilirliğini sağlamak için kapsamlı testler ve otomatikleştirilmiş dağıtım süreçleri kritik öneme sahiptir.</p>
                <h3>Test Stratejileri</h3>
                <ul>
                    <li><strong>Birim Testleri (Unit Tests):** İş mantığı katmanındaki servislerin, yardımcı sınıfların ve doğrulama kurallarının izole bir şekilde test edilmesi. Bağımlılıklar (örn: Repository'ler) mock/stub nesnelerle (Moq, NSubstitute) taklit edilir. Metotların beklenen çıktıyı verip vermediği, doğru istisnaları fırlatıp fırlatmadığı kontrol edilir. Hızlı çalışırlar ve CI sürecinin önemli bir parçasıdır.</li>
                    <li><strong>Entegrasyon Testleri (Integration Tests):** API endpoint'lerinin gerçek (veya in-memory) veritabanı ve diğer altyapı bileşenleriyle birlikte çalışmasını test eder. ASP.NET Core'un `WebApplicationFactory` sınıfı, API'yi bellek içinde barındırarak HTTP istekleri gönderip cevapları doğrulamayı kolaylaştırır. Veritabanı etkileşimleri, middleware'ler ve katmanlar arası entegrasyon test edilir.</li>
                    <li><strong>API Kontrat Testleri (Contract Tests):** API'nin belirlediği kontrata (istek/cevap formatları, durum kodları) uyup uymadığını doğrular. Genellikle entegrasyon testlerinin bir parçası olarak veya Postman/Newman gibi araçlarla yapılabilir.</li>
                    <li><strong>Yük ve Performans Testleri:** API'nin beklenen yük altında nasıl performans gösterdiğini (cevap süreleri, saniyedeki istek sayısı - RPS, kaynak kullanımı) ölçmek için yapılır. K6, JMeter gibi araçlar kullanılabilir.</li>
                    <li><strong>Güvenlik Testleri:** Yetkilendirme, kimlik doğrulama mekanizmalarının doğru çalışıp çalışmadığını, bilinen güvenlik açıklarına (örn: OWASP Top 10) karşı zafiyet olup olmadığını test etmek. Manuel (penetrasyon testi) ve otomatik araçlarla yapılabilir.</li>
                </ul>
                <h3>Dağıtım (Deployment)</h3>
                <ul>
                    <li><strong>Konteynerleştirme (Docker):** Uygulamayı bir Docker imajı olarak paketlemek, ortam bağımlılıklarını ortadan kaldırır ve dağıtımı standartlaştırır. `Dockerfile` ile imaj oluşturma süreci tanımlanır.</li>
                    <li><strong>Ortam Yönetimi:** Geliştirme (Development), Test (Staging) ve Üretim (Production) ortamları için farklı yapılandırma ayarları (`appsettings.json`, environment variables) kullanılır. Hassas veriler güvenli bir şekilde yönetilir (Azure Key Vault, AWS Secrets Manager vb.).</li>
                    <li><strong>CI/CD (Sürekli Entegrasyon / Sürekli Dağıtım):**
                        <ul>
                            <li><strong>CI:** Kod Git deposuna gönderildiğinde otomatik olarak derleme, birim ve entegrasyon testlerini çalıştırma, kod analizi yapma ve Docker imajını oluşturup bir registry'ye (Docker Hub, Azure Container Registry, AWS ECR) gönderme süreci.</li>
                            <li>**CD:** CI süreci başarılı olduğunda, oluşturulan imajın otomatik olarak Test ortamına ve onay sonrası Üretim ortamına dağıtılması süreci.</li>
                            <li>**Araçlar:** Azure DevOps Pipelines, GitHub Actions, Jenkins, GitLab CI/CD.</li>
                        </ul>
                    </li>
                    <li><strong>Barındırma (Hosting):**
                        <ul>
                            <li><strong>Bulut Platformları (PaaS/IaaS/Containers):** Azure (App Service, AKS, Container Apps), AWS (Elastic Beanstalk, EKS, Fargate), Google Cloud (App Engine, GKE) gibi platformlar ölçeklenebilirlik, yönetilebilirlik ve güvenlik özellikleri sunar.</li>
                            <li><strong>On-Premise:** Gerekirse kendi sunucularınızda da barındırılabilir (IIS, Kestrel).</li>
                        </ul>
                    </li>
                    <li><strong>Veritabanı Migrasyonları:** EF Core migrasyonlarının CD pipeline'ı sırasında kontrollü bir şekilde hedef veritabanına uygulanması.</li>
                    <li><strong>İzleme ve Uyarı (Monitoring & Alerting):** Uygulama dağıtıldıktan sonra performansını (CPU, bellek, cevap süreleri), hata oranlarını ve sistem sağlığını sürekli izlemek (Application Insights, CloudWatch, Datadog, Prometheus/Grafana) ve anormal durumlarda (yüksek hata oranı, servis kesintisi) uyarılar oluşturmak.</li>
                </ul>
            </section>

            <section id="sonuc">
                <h2>Sonuç ve Gelecek Geliştirmeler</h2>
                <p>Bu belge, katmanlı mimari kullanılarak .NET ve C# ile bir Banka API'si (Kredi Kartı Yönetim Sistemi) geliştirme sürecine kapsamlı bir bakış sunmuştur. Katmanlı mimarinin sağladığı modülerlik, test edilebilirlik ve bakım kolaylığı, özellikle finansal uygulamalar gibi karmaşık ve hassas sistemler için büyük avantajlar sunmaktadır. Proje yapısı, API tasarımı, iş mantığı, veri erişimi, güvenlik ve test stratejileri gibi temel konular ele alınmıştır.</p>
                <p>Başarılı bir API geliştirmenin anahtarları şunlardır:</p>
                <ul>
                    <li>İyi düşünülmüş ve tutarlı bir mimari tasarım.</li>
                    <li>Net ve anlaşılır API kontratları (REST, DTO'lar, OpenAPI).</li>
                    <li>Sağlam iş mantığı ve veri doğrulama kuralları.</li>
                    <li>Katı güvenlik önlemleri ve PCI DSS gibi standartlara uyum.</li>
                    <li>Kapsamlı test stratejileri (birim, entegrasyon, güvenlik).</li>
                    <li>Otomatikleştirilmiş CI/CD süreçleri ve etkin izleme.</li>
                </ul>
                <h3>Gelecek Geliştirmeler İçin Fikirler:</h3>
                <ul>
                    <li>Daha fazla kredi kartı işlemi eklemek (Bakiye sorgulama, işlem geçmişi, kart bloke etme/açma).</li>
                    <li>Müşteri yönetimi modülü eklemek ve kartlarla ilişkilendirmek.</li>
                    <li>Daha gelişmiş yetkilendirme senaryoları (Örn: Kullanıcı sadece kendi kartlarını görebilir).</li>
                    <li>Asenkron işlemler için mesajlaşma kuyrukları (RabbitMQ, Azure Service Bus) entegrasyonu (örn: kart oluşturma sonrası hoş geldin e-postası gönderme).</li>
                    <li>API ağ geçidi (API Gateway - Ocelot, Azure API Management, AWS API Gateway) kullanarak yönlendirme, hız sınırlama, kimlik doğrulama gibi görevleri merkezileştirmek.</li>
                    <li>Belirli modüllerin (eğer çok büyürse) mikroservislere ayrılması.</li>
                    <li>Gelişmiş izleme ve analitik için daha detaylı metrikler toplama.</li>
                    <li>Farklı veritabanı teknolojileri (örn: NoSQL) veya önbellekleme (Redis) entegrasyonu.</li>
                </ul>
                <p>Bu proje, modern API geliştirme prensiplerini ve .NET ekosisteminin yeteneklerini sergileyen sağlam bir temel oluşturmaktadır ve daha karmaşık finansal çözümler geliştirmek için bir başlangıç noktası olabilir.</p>
            </section>

        </article>
    </main>

    <footer class="site-footer">
        <p>
            <a class="footer-a" href="https://abdulkadirgungor86.github.io" target="_blank" rel="noopener noreferrer">Website</a> |
            <a class="footer-a" href="https://abdulkadirgungor86.github.io/sitemap.xml" target="_blank" rel="noopener noreferrer">Sitemap</a> |
            <a class="footer-a" href="https://abdulkadirgungor86.github.io/cv/" target="_blank" rel="noopener noreferrer">© 2025 Abdulkadir Güngör</a>
        </p>
    </footer>

</body>
</html>