<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="siteTitle">Kapsamlı C# ve .NET Öğrenme Rehberi: Modern Uygulamalar Geliştirme</title>
    <meta name="description" content="C# programlama dili ve .NET platformu hakkında temelden ileri seviyeye uzanan kapsamlı bir rehber. C# sözdizimi, veri tipleri, OOP, .NET Core, ASP.NET Core, Entity Framework Core, LINQ, asenkron programlama ve en iyi uygulamalar hakkında detaylı bilgi ve örnekler içerir. Abdulkadir Güngör tarafından hazırlanmıştır.">
    <meta name="keywords" content="C#, C Sharp, .NET, DotNET, .NET Core, ASP.NET Core, Entity Framework Core, EF Core, C# Öğren, .NET Öğren, C# Dersleri, .NET Dersleri, Yazılım Geliştirme, Programlama, OOP, Nesne Yönelimli Programlama, CLR, CTS, LINQ, async, await, Task, MVC, Web API, Microsoft, Visual Studio, C# Temelleri, .NET Platformu, C# Rehberi, .NET Kılavuzu, Abdulkadir Güngör, C# Tutorial Türkçe">
    <meta name="author" content="Abdulkadir Güngör">
    <link rel="canonical" href="https://abdulkadirgungor.com/blog/blog_page_11.html" />

    <link rel="icon" type="image/png" href="../assets/images/icons/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="../assets/images/icons/favicon.svg" />
    <link rel="shortcut icon" href="../assets/images/icons/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="../assets/images/icons/apple-touch-icon.png" />
    <link rel="manifest" href="../assets/images/icons/site.webmanifest" />

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="../assets/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <link rel="sitemap" type="application/xml" title="Sitemap" href="https://abdulkadirgungor.com/sitemap.xml">
    <link rel="sitemap" type="text/html" title="HTML Sitemap" href="https://abdulkadirgungor.com/sitemap.html">
    
    <script type="application/ld+json" id="siteData">
    {
      "@context": "https://schema.org",
      "@type": "BlogPosting",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://abdulkadirgungor.com/blog/blog_page_11.html"
      },
      "headline": "Kapsamlı C# ve .NET Öğrenme Rehberi: Modern Uygulamalar Geliştirme",
      "name": "Kapsamlı C# ve .NET Öğrenme Rehberi | Abdulkadir Güngör", 
  "author": {
    "@type": "Person",
    "name": "Abdulkadir Güngör",
    "url": "https://abdulkadirgungor.com/",
    "image": "https://abdulkadirgungor.com/assets/images/cv-profile.jpg",
    "sameAs": [
      "https://www.linkedin.com/in/abdulkadir-güngör/",
      "https://github.com/abdulkadirgungor86",
      "https://github.com/abdulkadir-gungor",
      "https://scholar.google.com/citations?user=1Ov789YAAAAJ",
      "https://polen.itu.edu.tr/bitstreams/f268d04c-e4a9-49bd-b336-929c1e52e4b9/download",
      "https://books.google.com.tr/books?id=GWMhEAAAQBAJ",
      "https://books.google.com.tr/books?id=u0CLEAAAQBAJ",
      "https://www.wikidata.org/wiki/Q134932691",
      "https://www.imdb.com/name/nm17368974"
    ]
  },
      "publisher": {
        "@type": "Organization",
        "name": "Abdulkadir Güngör",
        "logo": {
          "@type": "ImageObject",
          "url": "https://abdulkadirgungor.com/assets/images/icons/favicon-96x96.png" 
        }
      },
      "datePublished": "2025-05-13", 
      "dateModified": "2025-05-13", 
      "description": "C# programlama dili ve .NET platformu hakkında temelden ileri seviyeye uzanan kapsamlı bir rehber.",
      "isPartOf": {
        "@type": "WebSite",
        "@id": "https://abdulkadirgungor.com/"
      }
    }
    </script>

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-5GFQC3DYZF"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-5GFQC3DYZF');
    </script>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-5L6M34JW');</script>
    
</head>
<body id="pageTop"> 
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5L6M34JW"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    
    <main class="section-padding">
        <div class="container">
            <article id="giris" class="content-section intro-section">
                <h1>C# ve .NET: Güçlü ve Çok Yönlü Uygulamalar İçin Bir Arada</h1>
                <p>
                    Yazılım geliştirme dünyasında, sağlam, ölçeklenebilir ve performanslı uygulamalar oluşturmak için kullanılan birçok teknoloji ve platform bulunmaktadır. Bu ekosistem içinde, Microsoft tarafından geliştirilen C# (C Sharp olarak okunur) programlama dili ve .NET platformu, özellikle kurumsal düzeyde uygulamalar, web servisleri, masaüstü yazılımları, mobil uygulamalar ve oyun geliştirmede öne çıkan güçlü bir ikilidir. C#, modern, nesne yönelimli ve tip güvenli bir dil olarak geliştiricilere esnek ve verimli bir çalışma ortamı sunarken, .NET platformu bu dilde yazılan kodların çalıştırılması, yönetilmesi ve farklı uygulama türlerine uyarlanması için kapsamlı bir altyapı ve kütüphane seti sağlar.
                </p>
                <p>
                    C#, Java'nın sözdizimine benzerliği ve C++'ın gücünden ilham alarak tasarlanmıştır, ancak daha basit, daha güvenli ve daha üretken olmayı hedefler. Otomatik bellek yönetimi (Garbage Collection), tip güvenliği, zengin standart kütüphaneler ve modern dil özellikleri (LINQ, async/await, pattern matching vb.) sayesinde geliştiricilerin karmaşık görevleri daha kolay bir şekilde yerine getirmesine olanak tanır. .NET platformu ise, C# (ve F#, VB.NET gibi diğer .NET dillerinde) yazılan kodları Ortak Dil Çalışma Zamanı (Common Language Runtime - CLR) üzerinde çalıştırarak platform bağımsızlığı (belirli ölçüde), dil birlikte çalışabilirliği ve güvenlik gibi önemli avantajlar sunar.
                </p>
                 <p>
                    Başlangıçta sadece Windows platformuna odaklanan .NET Framework'ten, açık kaynaklı, çapraz platform (Windows, macOS, Linux) desteği sunan .NET Core'a ve nihayetinde tüm .NET dünyasını tek bir çatı altında birleştiren modern .NET (NET 5, .NET 6, .NET 7 ve sonrası) sürümlerine evrilen bu platform, sürekli olarak gelişmekte ve modern yazılım geliştirme ihtiyaçlarına cevap vermektedir. ASP.NET Core ile yüksek performanslı web uygulamaları ve API'ler, Entity Framework Core ile kolaylaştırılmış veri erişimi, Xamarin (ve şimdi .NET MAUI) ile platformlar arası mobil uygulama geliştirme gibi yetenekler, C# ve .NET'i günümüzün en popüler ve aranan teknoloji yığınlarından biri haline getirmiştir. Bu rehber, C# dilinin temellerinden başlayarak .NET platformunun mimarisine, nesne yönelimli programlama prensiplerine, temel kütüphanelere, web geliştirmeye ve ileri seviye konulara kadar geniş bir perspektif sunarak bu güçlü ikiliyi öğrenme yolculuğunuzda size kapsamlı bir kaynak olmayı hedeflemektedir.
                </p>
            </article>

            <section id="csharp-temeller" class="content-section">
                <h2>C# Temelleri: Dilin Yapı Taşları</h2>
                <p>
                    C# ile programlamaya başlamak için dilin temel sözdizimini, verileri nasıl temsil ettiğini (veri tipleri), bu verileri nasıl sakladığını (değişkenler), veriler üzerinde nasıl işlem yaptığını (operatörler) ve program akışını nasıl kontrol ettiğini (kontrol yapıları) anlamak gerekir.
                </p>

                <details class="question-block">
                    <summary><h3>Temel Sözdizimi, "Merhaba Dünya" ve Yorumlar</h3></summary>
                    <p>C#, C ve C++ gibi dillerden türediği için süslü parantezler <code>{ }</code> ile blokları, noktalı virgül <code>;</code> ile ifadeleri sonlandırmayı temel alır. Büyük/küçük harfe duyarlıdır.</p>
                    <p>Klasik bir "Merhaba Dünya" örneği:</p>
                    <pre><code class="language-csharp">
using System; // System isim alanını kullanacağımızı belirtiriz

// C# 9 ve sonrası için Top-Level Statements ile daha kısa yazım:
// Console.WriteLine("Merhaba Dünya!");

// Geleneksel Yöntem (C# 8 ve öncesi veya açık sınıf/metot tanımı istendiğinde):
namespace MerhabaApp // Kodumuzu organize etmek için bir isim alanı
{
    class Program // Programımızın ana sınıfı
    {
        static void Main(string[] args) // Programın başlangıç noktası olan ana metot
        {
            Console.WriteLine("Merhaba Dünya!"); // Konsola yazı yazdırır
        }
    }
}
                    </code></pre>
                    <ul>
                        <li><strong><code>using System;</code>:</strong> .NET'in temel kütüphanelerinden biri olan <code>System</code> isim alanındaki sınıfları (örneğin <code>Console</code>) doğrudan kullanmamızı sağlar.</li>
                        <li><strong><code>namespace</code>:</strong> İlgili sınıfları ve diğer türleri mantıksal olarak gruplandırmak için kullanılır, isim çakışmalarını önler.</li>
                        <li><strong><code>class Program</code>:</strong> C#'ta tüm kodlar sınıflar içinde bulunur. <code>Program</code> genellikle konsol uygulamaları için varsayılan sınıf adıdır.</li>
                        <li><strong><code>static void Main(string[] args)</code>:</strong> Bir uygulamanın giriş noktasıdır. Program çalıştırıldığında ilk bu metot çağrılır.
                            <ul>
                                <li><code>static</code>: Metodun, sınıfın bir örneği (nesnesi) oluşturulmadan çağrılabileceğini belirtir.</li>
                                <li><code>void</code>: Metodun bir değer döndürmediğini belirtir.</li>
                                <li><code>Main</code>: Metodun özel adıdır, giriş noktası olduğunu belirtir.</li>
                                <li><code>string[] args</code>: Programa komut satırından argümanlar geçilmesini sağlar.</li>
                            </ul>
                        </li>
                        <li><strong><code>Console.WriteLine(...)</code>:</strong> Konsol penceresine belirtilen metni yazdırır ve bir alt satıra geçer.</li>
                    </ul>
                    <p><strong>Yorumlar:</strong></p>
                    <ul>
                        <li>Tek satır yorumları: <code>//</code></li>
                        <li>Çok satır yorumları: <code>/* ... */</code></li>
                        <li>XML Dökümantasyon Yorumları: <code>///</code> (Metotlar, sınıflar vb. için açıklama oluşturur, IntelliSense tarafından kullanılır).
                            <pre><code class="language-csharp">
/// <summary>
/// İki sayıyı toplayan metot.
/// </summary>
/// <param name="a">İlk sayı.</param>
/// <param name="b">İkinci sayı.</param>
/// <returns>Sayıların toplamı.</returns>
public int Topla(int a, int b)
{
    // Bu tek satır yorumudur
    return a + b;
    /*
       Bu da çok satırlı
       bir yorumdur.
    */
}
                            </code></pre>
                        </li>
                    </ul>
                </details>

                <details class="question-block">
                    <summary><h3>Veri Tipleri: Değer ve Referans Tipleri</h3></summary>
                    <p>C# statik tipli bir dildir, yani değişkenlerin tipleri derleme zamanında bilinmelidir. Veri tipleri temel olarak iki kategoriye ayrılır:</p>
                    <ol>
                        <li><strong>Değer Tipleri (Value Types):</strong> Değişkenin doğrudan veriyi tuttuğu tiplerdir. Belleğin "stack" bölgesinde saklanırlar (genellikle). Bir değer tipi değişkeni başka bir değişkene atandığında, verinin bir kopyası oluşturulur.
                            <ul>
                                <li><strong>Basit Tipler (Simple Types):</strong>
                                    <ul>
                                        <li>Tamsayılar: <code>sbyte</code>, <code>byte</code>, <code>short</code>, <code>ushort</code>, <code>int</code> (varsayılan), <code>uint</code>, <code>long</code>, <code>ulong</code></li>
                                        <li>Ondalıklı Sayılar: <code>float</code> (F veya f son eki), <code>double</code> (varsayılan), <code>decimal</code> (M veya m son eki - finansal hesaplamalar için yüksek hassasiyet)</li>
                                        <li>Karakter: <code>char</code> (tek tırnak içinde tek karakter, örn: <code>'A'</code>)</li>
                                        <li>Mantıksal: <code>bool</code> (<code>true</code> veya <code>false</code>)</li>
                                    </ul>
                                </li>
                                <li><strong><code>struct</code> Tipleri:</strong> Kullanıcı tanımlı değer tipleridir.</li>
                                <li><strong><code>enum</code> Tipleri (Enumerations):</strong> Sabit değerler kümesini temsil eder.</li>
                                <li><strong>Nullable Değer Tipleri (<code>?</code>):</strong> Normalde <code>null</code> olamayan değer tiplerinin (örn: <code>int</code>, <code>bool</code>) <code>null</code> değer alabilmesini sağlar (örn: <code>int?</code>, <code>bool?</code>).</li>
                            </ul>
                        </li>
                        <li><strong>Referans Tipleri (Reference Types):</strong> Değişkenin, verinin bellekteki adresini (referansını) tuttuğu tiplerdir. Verinin kendisi belleğin "heap" bölgesinde saklanır. Bir referans tipi değişkeni başka bir değişkene atandığında, sadece referans kopyalanır, her iki değişken de aynı veriyi işaret eder. Referans tipleri varsayılan olarak <code>null</code> olabilir.
                            <ul>
                                <li><strong><code>class</code> Tipleri:</strong> Kullanıcı tanımlı referans tipleridir (OOP'nin temeli).</li>
                                <li><strong><code>interface</code> Tipleri:</strong> Bir sözleşmeyi tanımlar.</li>
                                <li><strong><code>delegate</code> Tipleri:</strong> Metotlara referans tutar.</li>
                                <li><strong>Diziler (Arrays):</strong> Aynı türden eleman koleksiyonları (örn: <code>int[]</code>, <code>string[]</code>).</li>
                                <li><strong><code>string</code> Tipi:</strong> Metinleri temsil eder. Özel bir durumdur; referans tipi olmasına rağmen karakter dizisi (immutable - değiştirilemez) gibi davranır.</li>
                                <li><strong><code>object</code> Tipi:</strong> Tüm diğer tiplerin türediği temel tiptir. Herhangi bir türden değeri tutabilir (boxing/unboxing gerektirebilir).</li>
                            </ul>
                        </li>
                    </ol>
                    <pre><code class="language-csharp">
// Değer Tipleri
int sayi1 = 10;
int sayi2 = sayi1; // sayi1'in değeri (10) kopyalanır
sayi2 = 20;
Console.WriteLine($"Sayı 1: {sayi1}"); // 10 (değişmedi)
Console.WriteLine($"Sayı 2: {sayi2}"); // 20

bool aktif = true;
decimal fiyat = 99.95m;
char harf = 'C';
int? opsiyonelSayi = null; // Nullable değer tipi

// Referans Tipleri
string isim1 = "Ahmet";
string isim2 = isim1; // Referans kopyalanır (ama string immutable olduğu için farklı davranır)
isim2 = "Mehmet";
Console.WriteLine($"İsim 1: {isim1}"); // Ahmet (string immutable)
Console.WriteLine($"İsim 2: {isim2}"); // Mehmet

int[] dizi1 = { 1, 2, 3 };
int[] dizi2 = dizi1; // Referans kopyalanır, aynı dizi işaret edilir
dizi2[0] = 99;
Console.WriteLine($"Dizi 1[0]: {dizi1[0]}"); // 99 (değişti!)
Console.WriteLine($"Dizi 2[0]: {dizi2[0]}"); // 99

object obj = sayi1; // Boxing: Değer tipini object'e çevirme
int sayi3 = (int)obj; // Unboxing: Object'i tekrar değer tipine çevirme
                    </code></pre>
                </details>

                 <details class="question-block">
                    <summary><h3>Değişken Tanımlama ve Atama</h3></summary>
                    <p>Değişkenler, veri saklamak için kullanılır. Tanımlanırken tipi belirtilir.</p>
                    <pre><code class="language-csharp">
// Tip belirterek tanımlama ve atama
int yas = 30;
string adSoyad = "Ayşe Kaya";
double ortalama = 75.5;
bool gectiMi = true;

// Sadece tanımlama (varsayılan değer atanır: sayılar için 0, bool için false, referans tipleri için null)
int puan; // puan = 0
string sehir; // sehir = null
bool devam; // devam = false

// Sonradan değer atama
puan = 100;
sehir = "İstanbul";
devam = true;

// Sabit tanımlama (değeri değiştirilemez)
const double PI = 3.14159;
// PI = 3.14; // Hata! const değeri değiştirilemez

// var anahtar kelimesi (Tip çıkarımı - Implicit Typing)
// Derleyici, atanan değere göre değişkenin tipini otomatik belirler.
// Tanımlandığı anda değer atanmalıdır.
var mesaj = "Bu bir string"; // Derleyici mesaj'ın tipini string olarak belirler
var sayac = 0;           // Derleyici sayac'ın tipini int olarak belirler
// var durum; // Hata! Başlangıç değeri atanmalı

// mesaj = 10; // Hata! mesaj'ın tipi string olarak belirlendi, int atanamaz
                    </code></pre>
                    <p><code>var</code> kullanımı kodu kısaltabilir ancak tipin açıkça belirtilmesi okunabilirliği artırabilir. Genellikle anonim tipler veya karmaşık generic tiplerle kullanıldığında faydalıdır.</p>
                 </details>

                <details class="question-block">
                    <summary><h3>Operatörler</h3></summary>
                    <p>Değerler üzerinde işlem yapmak için kullanılırlar:</p>
                     <ul>
                        <li><strong>Atama Operatörleri:</strong> <code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code></li>
                        <li><strong>Aritmetik Operatörler:</strong> <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code> (modülüs), <code>++</code> (arttırma), <code>--</code> (azaltma)</li>
                        <li><strong>Karşılaştırma Operatörleri:</strong> İki değeri karşılaştırır ve <code>bool</code> sonuç döndürür (<code>==</code> (eşitlik), <code>!=</code> (eşitsizlik), <code><</code>, <code>></code>, <code><=</code>, <code>>=</code>).</li>
                        <li><strong>Mantıksal Operatörler:</strong> Boolean değerler üzerinde işlem yapar (<code>&&</code> (VE - AND), <code>||</code> (VEYA - OR), <code>!</code> (DEĞİL - NOT)).</li>
                        <li><strong>Bitsel Operatörler:</strong> Sayıların bitleri üzerinde işlem yapar (<code>&</code>, <code>|</code>, <code>^</code> (XOR), <code>~</code> (tümleyen), <code><<</code> (sola kaydırma), <code>>></code> (sağa kaydırma)).</li>
                        <li><strong>Koşul (Ternary) Operatörü:</strong> <code>koşul ? deger_dogruysa : deger_yanlissa</code></li>
                        <li><strong>Null Birleştirme Operatörü (<code>??</code>):</strong> Soldaki operand <code>null</code> değilse onu, <code>null</code> ise sağdaki operandı döndürür.
                             <pre><code class="language-csharp">string kullaniciAdi = gelenAd ?? "Misafir"; // gelenAd null ise "Misafir" atanır</code></pre>
                        </li>
                        <li><strong>Null Koşul Operatörü (<code>?.</code> ve <code>?[]</code>):</strong> Bir nesne veya dizi referansı <code>null</code> ise hata fırlatmak yerine doğrudan <code>null</code> döndürerek null referans hatalarını önlemeye yardımcı olur.
                            <pre><code class="language-csharp">
int? karakterSayisi = musterininAdi?.Length; // musteri veya musterininAdi null ise karakterSayisi null olur, değilse Length'i alır.
string ilkRenk = renkler?[0]; // renkler null ise ilkRenk null olur.
                            </code></pre>
                        </li>
                        <li><strong><code>is</code> Operatörü:</strong> Bir nesnenin belirli bir tipte olup olmadığını kontrol eder.</li>
                        <li><strong><code>as</code> Operatörü:</strong> Bir nesneyi belirli bir tipe dönüştürmeye çalışır, başarısız olursa hata fırlatmak yerine <code>null</code> döndürür.</li>
                        <li><strong><code>typeof</code> Operatörü:</strong> Bir tipin <code>System.Type</code> nesnesini döndürür.</li>
                        <li><strong><code>sizeof</code> Operatörü:</strong> Belirli bir değer tipinin bellekte kapladığı boyutu (byte cinsinden) döndürür (<code>unsafe</code> bağlam gerektirebilir).</li>
                    </ul>
                     <pre><code class="language-csharp">
int a = 10, b = 4;
int toplam = a + b; // 14
int fark = a - b;   // 6
int carpim = a * b; // 40
double bolum = (double)a / b; // 2.5 (Tip dönüşümü önemli)
int kalan = a % b;  // 2

bool esitMi = (a == 10); // true
bool buyukMu = (b > 5);  // false

bool kosul1 = esitMi && !buyukMu; // true && !false => true && true => true
bool kosul2 = (a < 5) || (b == 4); // false || true => true

string durum = (toplam > 15) ? "Büyük" : "Küçük"; // "Küçük"

object obj = "Merhaba";
if (obj is string)
{
    string metin = obj as string; // Güvenli dönüşüm
    if (metin != null)
    {
         Console.WriteLine($"Metin uzunluğu: {metin.Length}");
    }
}
                    </code></pre>
                </details>

                <details class="question-block">
                    <summary><h3>Kontrol Yapıları</h3></summary>
                    <p>Programın akışını kontrol etmek için kullanılır.</p>
                    <ul>
                        <li><strong><code>if-else if-else</code>:</strong> Koşullara göre farklı kod bloklarını çalıştırır.
                             <pre><code class="language-csharp">
int not = 75;
if (not >= 85) {
    Console.WriteLine("Pekiyi");
} else if (not >= 70) {
    Console.WriteLine("İyi");
} else if (not >= 55) {
    Console.WriteLine("Orta");
} else {
    Console.WriteLine("Başarısız");
}
                            </code></pre>
                        </li>
                        <li><strong><code>switch</code>:</strong> Bir ifadenin değerine göre farklı durumları (case) kontrol eder. Genellikle belirli sabit değerlere karşı kontrol yapılırken <code>if-else if</code>'e göre daha okunabilir olabilir. <code>break</code> ifadesi ile durumdan çıkılır.
                             <pre><code class="language-csharp">
char harfNotu = 'B';
switch (harfNotu) {
    case 'A':
        Console.WriteLine("Mükemmel");
        break;
    case 'B':
    case 'C': // Birden fazla case aynı bloğu çalıştırabilir
        Console.WriteLine("Başarılı");
        break;
    case 'D':
        Console.WriteLine("Geçer");
        break;
    default:
        Console.WriteLine("Başarısız");
        break;
}
                            </code></pre>
                        </li>
                        <li><strong><code>for</code> Döngüsü:</strong> Belirli sayıda tekrarlanan işlemler için kullanılır (başlangıç değeri, koşul, artış/azalış adımı).
                             <pre><code class="language-csharp">
for (int i = 0; i < 5; i++) { // 0'dan 4'e kadar (5 kez) döner
    Console.WriteLine($"Döngü Adımı: {i}");
}
                            </code></pre>
                        </li>
                         <li><strong><code>while</code> Döngüsü:</strong> Belirtilen koşul doğru olduğu sürece dönmeye devam eder. Koşul döngü başlamadan kontrol edilir.
                              <pre><code class="language-csharp">
int sayac = 0;
while (sayac < 3) {
    Console.WriteLine($"While Sayaç: {sayac}");
    sayac++;
}
                             </code></pre>
                          </li>
                          <li><strong><code>do-while</code> Döngüsü:</strong> <code>while</code> gibidir ancak koşul döngünün <strong>sonunda</strong> kontrol edilir, bu nedenle döngü gövdesi en az bir kez çalışır.
                               <pre><code class="language-csharp">
int cevap;
do {
    Console.WriteLine("Bir sayı girin (çıkmak için 0):");
    // cevap = Convert.ToInt32(Console.ReadLine()); // Gerçek uygulamada
    cevap = (new Random()).Next(-1, 5); // Simülasyon
    Console.WriteLine($"Girilen: {cevap}");
} while (cevap != 0);
                              </code></pre>
                          </li>
                           <li><strong><code>foreach</code> Döngüsü:</strong> Bir koleksiyonun (dizi, List vb.) tüm elemanları üzerinde gezinmek için kullanılır. Daha basit ve hataya daha az açıktır.
                                <pre><code class="language-csharp">
string[] isimler = { "Ali", "Veli", "Ayşe" };
foreach (string isim in isimler) {
    Console.WriteLine($"Merhaba {isim}");
}
                               </code></pre>
                           </li>
                        <li><strong><code>break</code>:</strong> İçinde bulunduğu döngüden (for, while, do-while, foreach) veya switch bloğundan hemen çıkar.</li>
                        <li><strong><code>continue</code>:</strong> Döngünün mevcut adımını atlar ve bir sonraki adıma geçer.</li>
                    </ul>
                </details>

                 <details class="question-block">
                    <summary><h3>Metotlar (Fonksiyonlar)</h3></summary>
                    <p>Belirli bir işlevi yerine getiren, tekrar kullanılabilir kod bloklarıdır. Parametre alabilir ve bir değer döndürebilirler.</p>
                    <p>Tanımlama: <code>[Erişim Belirleyici] [static] [Dönüş Tipi] MetotAdı([Parametre Listesi]) { // Metot Gövdesi }</code></p>
                    <ul>
                        <li><strong>Erişim Belirleyici (Access Modifier):</strong> Metodun nereden erişilebileceğini belirler (<code>public</code>, <code>private</code>, <code>protected</code>, <code>internal</code>). Varsayılan genellikle <code>private</code>'tır.</li>
                        <li><strong><code>static</code> (İsteğe bağlı):</strong> Metodun sınıfın örneği olmadan doğrudan sınıf üzerinden çağrılıp çağrılamayacağını belirler.</li>
                        <li><strong>Dönüş Tipi:</strong> Metodun geri döndüreceği değerin tipini belirtir. Değer döndürmüyorsa <code>void</code> kullanılır.</li>
                        <li><strong>MetotAdı:</strong> Metodun ismidir (PascalCase kullanılır).</li>
                        <li><strong>Parametre Listesi:</strong> Metodun dışarıdan alacağı değerleri tanımlar (<code>tip parametreAdı</code> şeklinde).</li>
                        <li><strong>Metot Gövdesi:</strong> Metodun çalıştıracağı kodları içerir. <code>return</code> ifadesi ile değer döndürülür (eğer dönüş tipi <code>void</code> değilse).</li>
                    </ul>
                    <pre><code class="language-csharp">
using System;

public class Hesaplayici
{
    // Değer döndürmeyen, parametresiz metot
    public void MesajYazdir()
    {
        Console.WriteLine("Hesaplayıcı sınıfından mesaj.");
    }

    // Değer döndüren, parametreli metot
    public int KareAl(int sayi)
    {
        return sayi * sayi;
    }

    // Birden fazla parametre alan metot
    public double DikdortgenAlan(double uzunKenar, double kisaKenar)
    {
        if (uzunKenar <= 0 || kisaKenar <= 0)
        {
            // Hata yönetimi veya varsayılan değer döndürme
            return 0;
        }
        return uzunKenar * kisaKenar;
    }

    // Static metot (Nesne oluşturmadan çağrılabilir)
    public static void StaticMesaj()
    {
        Console.WriteLine("Bu static bir metottur.");
    }
}

// Metotları kullanma
public class AnaProgram
{
    public static void Calistir() // Main yerine örnek kullanım
    {
        Hesaplayici hesap = new Hesaplayici(); // Nesne oluşturma
        hesap.MesajYazdir();

        int kareSonuc = hesap.KareAl(7); // 49
        Console.WriteLine($"7'nin karesi: {kareSonuc}");

        double alan = hesap.DikdortgenAlan(5.0, 8.0); // 40.0
        Console.WriteLine($"Dikdörtgen alanı: {alan}");

        // Static metot çağırma
        Hesaplayici.StaticMesaj();
    }
}
                    </code></pre>
                 </details>
            </section>

            <section id="dotnet-platformu" class="content-section">
                <h2>.NET Platformu: C# Kodunun Çalışma Ortamı</h2>
                <p>.NET, Microsoft tarafından geliştirilen, çeşitli dillerle (başta C#, F#, VB.NET) uygulama geliştirmeyi sağlayan kapsamlı bir yazılım geliştirme platformudur. Kodun derlenmesi, çalıştırılması, bellek yönetimi ve temel kütüphanelere erişim gibi işlevleri yerine getirir.</p>

                 <details class="question-block">
                    <summary><h3>.NET Evrimi: Framework vs. Core vs. Modern .NET</h3></summary>
                    <ul>
                        <li><strong>.NET Framework (Eski):</strong> .NET'in ilk sürümüdür. Sadece Windows üzerinde çalışır. Windows masaüstü (WinForms, WPF), web (ASP.NET Web Forms, MVC) ve servis uygulamaları geliştirmek için kullanılır. Artık aktif geliştirme almamaktadır, sadece bakım modundadır.</li>
                        <li><strong>.NET Core (Açık Kaynak, Çapraz Platform):</strong> .NET Framework'ün modern, modüler, açık kaynaklı ve çapraz platform (Windows, macOS, Linux) alternatifi olarak geliştirilmiştir. Yüksek performanslı web uygulamaları (ASP.NET Core), mikroservisler, konsol uygulamaları ve bulut tabanlı çözümler için tasarlanmıştır.</li>
                        <li><strong>.NET 5, 6, 7, 8... (Modern .NET):</strong> .NET Core'un devamıdır ve .NET ekosistemini tek bir çatı altında birleştirmeyi hedefler. .NET Framework'ün adı artık kullanılmamaktadır. Her yıl yeni ana sürüm çıkar (Kasım ayında). LTS (Long-Term Support - Uzun Süreli Destek) sürümleri (örn: .NET 6, .NET 8) daha uzun süre desteklenir. Modern .NET, web, bulut, masaüstü (WPF, WinForms - Windows özelinde, MAUI - platformlar arası), mobil (.NET MAUI), oyun (Unity ile), IoT ve AI gibi çok geniş bir yelpazede uygulama geliştirmeyi destekler.</li>
                    </ul>
                    <p>Yeni projeler için kesinlikle modern .NET sürümleri (.NET 6 veya sonrası) tercih edilmelidir.</p>
                 </details>

                <details class="question-block">
                    <summary><h3>Ana Bileşenler: CLR, CTS, CLS</h3></summary>
                    <ul>
                        <li><strong>Ortak Dil Çalışma Zamanı (Common Language Runtime - CLR):</strong> .NET uygulamalarının çalıştığı temel yürütme motorudur. Şu görevleri yerine getirir:
                            <ul>
                                <li><strong>Bellek Yönetimi (Garbage Collection - GC):</strong> Artık kullanılmayan nesnelerin kapladığı belleği otomatik olarak temizler, bellek sızıntılarını önler.</li>
                                <li><strong>Kod Derleme (JIT - Just-In-Time):</strong> C# gibi dillerde yazılan kod önce Ortak Ara Dile (Common Intermediate Language - CIL veya IL) derlenir. CLR, uygulama çalıştırılırken bu CIL kodunu makine koduna (native code) anında (Just-In-Time) derler.</li>
                                <li><strong>Tip Güvenliği (Type Safety):</strong> Kodun tür kurallarına uymasını sağlar, geçersiz tür dönüşümlerini engeller.</li>
                                <li><strong>Güvenlik (Security):</strong> Kod erişim güvenliği (Code Access Security - CAS) gibi mekanizmalarla kodun yetkilerini yönetir.</li>
                                <li><strong>İstisna Yönetimi (Exception Handling):</strong> Hataların yönetilmesi için bir yapı sunar.</li>
                                <li><strong>Thread Yönetimi:</strong> Çoklu iş parçacıklarının yönetilmesine yardımcı olur.</li>
                            </ul>
                        </li>
                        <li><strong>Ortak Tip Sistemi (Common Type System - CTS):</strong> .NET platformunda kullanılan tüm veri tiplerinin (değer/referans tipleri, sınıflar, arayüzler vb.) nasıl tanımlanacağını ve nasıl davranacağını belirleyen standart bir sistemdir. Farklı .NET dillerinin birbirleriyle uyumlu çalışmasını sağlar, çünkü hepsi aynı tip sistemini kullanır.</li>
                        <li><strong>Ortak Dil Şartnamesi (Common Language Specification - CLS):</strong> Farklı .NET dillerinin birbirleriyle sorunsuz bir şekilde etkileşim kurabilmesi için uyması gereken bir dizi kural ve özelliktir. Bir kütüphane CLS uyumlu (CLS-compliant) ise, CLS uyumlu herhangi bir .NET dili tarafından rahatlıkla kullanılabilir. Örneğin, C#'ta büyük/küçük harfe duyarlılık varken VB.NET'te yoktur; CLS, bir public üyenin sadece büyük/küçük harf farkıyla başka bir üyeden ayırt edilmemesi gerektiğini söyler.</li>
                    </ul>
                    <p>Bu bileşenler, .NET'in dil bağımsızlığını, platformlar arası çalışabilirliğini ve geliştirici verimliliğini sağlayan temel yapı taşlarıdır.</p>
                </details>

                 <details class="question-block">
                     <summary><h3>Derleme Süreci ve CIL (MSIL)</h3></summary>
                     <p>.NET'te kodun çalıştırılması iki aşamalı bir derleme süreci içerir:</p>
                     <ol>
                         <li><strong>Kaynak Kodundan CIL'e Derleme:</strong> C# (veya F#, VB.NET) kodunuz, dilin kendi derleyicisi (örn: Roslyn C# derleyicisi) tarafından Ortak Ara Dil'e (CIL - Common Intermediate Language, eski adıyla MSIL - Microsoft Intermediate Language) derlenir. CIL, platformdan bağımsız, düşük seviyeli bir dildir. Bu derleme sonucunda genellikle <code>.dll</code> (kütüphane) veya <code>.exe</code> (uygulama) uzantılı Assembly (bütünleştirilmiş kod) dosyaları oluşur. Bu dosyalar CIL kodunu ve metadata'yı (tipler, üyeler hakkında bilgi) içerir.</li>
                         <li><strong>CIL'den Makine Koduna Derleme (JIT):</strong> Uygulama çalıştırıldığında, CLR'nin JIT (Just-In-Time) derleyicisi devreye girer. JIT derleyici, Assembly dosyasındaki CIL kodunu, uygulamanın çalıştığı belirli platformun (işlemci mimarisi, işletim sistemi) anlayabileceği makine koduna (native code) ihtiyaç duyulduğu anda (genellikle bir metot ilk kez çağrıldığında) derler. Derlenen makine kodu önbelleğe alınır, böylece aynı kod tekrar tekrar derlenmez.</li>
                     </ol>
                     <p>Bu iki aşamalı süreç, .NET'in hem platform bağımsızlığı (CIL sayesinde) hem de yüksek performans (native koda derleme sayesinde) sunmasını sağlar. .NET Core ve sonrası ile birlikte AOT (Ahead-of-Time) derleme gibi alternatifler de sunulmaktadır, bu sayede uygulama dağıtılmadan önce doğrudan makine koduna derlenebilir, bu da başlangıç süresini iyileştirebilir.</p>
                 </details>

                  <details class="question-block">
                     <summary><h3>Çöp Toplama (Garbage Collection - GC)</h3></summary>
                     <p>C# ve .NET, geliştiricinin manuel olarak bellek ayırması (allocate) ve serbest bırakması (deallocate) gerekliliğini ortadan kaldıran otomatik bir bellek yönetimi sistemi sunar. Bu sistemin kalbi Çöp Toplayıcı'dır (Garbage Collector - GC).</p>
                     <p>İşleyişi temel olarak şöyledir:</p>
                     <ol>
                         <li>Referans tipli nesneler oluşturulduğunda (<code>new</code> anahtar kelimesi ile), CLR bu nesneler için belleğin yönetilen yığın (managed heap) bölgesinden yer ayırır.</li>
                         <li>GC, periyodik olarak veya bellek baskısı oluştuğunda çalışır.</li>
                         <li>Çalıştığında, uygulamanın kök referanslarından (global değişkenler, statik alanlar, çalışan metotların yerel değişkenleri ve parametreleri) başlayarak erişilebilir (ulaşılabilir) olan tüm nesneleri işaretler.</li>
                         <li>İşaretlenmeyen (yani artık hiçbir referans tarafından gösterilmeyen) nesnelerin "çöp" olduğuna karar verir.</li>
                         <li>İşaretlenmeyen nesnelerin kapladığı bellek alanını geri kazanır (serbest bırakır).</li>
                         <li>İsteğe bağlı olarak, kalan nesneleri bellekte sıkıştırarak (compaction) boş alanları birleştirebilir ve gelecekteki bellek ayırmalarını hızlandırabilir.</li>
                     </ol>
                     <p>GC, geliştiricinin bellek yönetimi yükünü büyük ölçüde azaltsa da, nasıl çalıştığını anlamak performans optimizasyonu açısından önemlidir. Örneğin, gereksiz yere büyük nesneler oluşturmak veya nesnelere uzun süre referans tutmak GC üzerinde baskı oluşturabilir.</p>
                     <p><code>IDisposable</code> arayüzü ve <code>using</code> ifadesi, dosya akışları, veritabanı bağlantıları gibi yönetilmeyen (unmanaged) kaynakları (bellek dışı kaynaklar) deterministik olarak serbest bırakmak için kullanılır ve GC'nin işini kolaylaştırır.</p>
                  </details>
            </section>

            <section id="oop" class="content-section">
                 <h2>Nesne Yönelimli Programlama (OOP) İlkeleri</h2>
                 <p>C#, tamamen nesne yönelimli bir dildir. OOP, yazılımı yeniden kullanılabilir, yönetilebilir ve anlaşılması kolay "nesneler" etrafında organize etmeyi amaçlayan bir programlama paradigmadır. Temel ilkeleri şunlardır:</p>

                 <details class="question-block">
                     <summary><h3>Sınıflar (Classes) ve Nesneler (Objects)</h3></summary>
                     <ul>
                         <li><strong>Sınıf (Class):</strong> Bir nesnenin planı veya şablonudur. Belirli bir türdeki nesnelerin sahip olacağı özellikleri (verileri - fields, properties) ve davranışları (metotları) tanımlar. Bir veri tipidir (referans tipi).</li>
                         <li><strong>Nesne (Object / Instance):</strong> Bir sınıfın bellekte oluşturulmuş somut bir örneğidir. Sınıf tanımında belirtilen özelliklere ve davranışlara sahiptir. <code>new</code> anahtar kelimesi ile oluşturulur.</li>
                     </ul>
                      <pre><code class="language-csharp">
// Sınıf Tanımı (Şablon)
public class Kedi
{
    // Alanlar (Fields) - Genellikle private olur
    private string renk;
    private int yas;

    // Özellikler (Properties) - Alanlara kontrollü erişim sağlar
    public string Ad { get; set; } // Otomatik Uygulanan Özellik (Auto-Implemented Property)

    public int Yas // Tam Özellik (Full Property)
    {
        get { return yas; } // Değeri okuma
        set // Değeri atama (isteğe bağlı kontrol eklenebilir)
        {
            if (value >= 0)
            {
                yas = value;
            }
            else
            {
                Console.WriteLine("Yaş negatif olamaz!");
            }
        }
    }

    // Yapıcı Metot (Constructor) - Nesne oluşturulduğunda çalışır
    public Kedi(string ad, int baslangicYas)
    {
        this.Ad = ad; // this, mevcut nesneyi referans eder
        this.Yas = baslangicYas;
        this.renk = "Bilinmiyor"; // Varsayılan renk
        Console.WriteLine($"{Ad} isimli kedi oluşturuldu.");
    }

    // Metot (Davranış)
    public void Miyavla()
    {
        Console.WriteLine($"{Ad} miyavlıyor!");
    }

    public void RenkAta(string yeniRenk)
    {
        this.renk = yeniRenk;
    }

     public string RenkGetir()
    {
        return this.renk;
    }
}

// Nesne Oluşturma (Instance Alma)
Kedi kedi1 = new Kedi("Tekir", 2); // Yapıcı metot çağrılır
Kedi kedi2 = new Kedi("Pamuk", 1);

// Nesne Özelliklerine Erişme ve Değiştirme
kedi1.Yas = 3;
kedi2.RenkAta("Beyaz");

// Nesne Metotlarını Çağırma
kedi1.Miyavla(); // Tekir miyavlıyor!
kedi2.Miyavla(); // Pamuk miyavlıyor!

Console.WriteLine($"{kedi1.Ad}'in yaşı: {kedi1.Yas}"); // 3
Console.WriteLine($"{kedi2.Ad}'in rengi: {kedi2.RenkGetir()}"); // Beyaz
                    </code></pre>
                 </details>

                 <details class="question-block">
                     <summary><h3>Kapsülleme (Encapsulation)</h3></summary>
                     <p>Bir nesnenin iç verilerini (alanlarını) gizleyerek ve bu verilere sadece nesnenin kendi metotları (veya özellikleri - properties) aracılığıyla kontrollü bir şekilde erişilmesini sağlama prensibidir. Bu, veri bütünlüğünü korur ve nesnenin iç yapısının dışarıdan doğrudan değiştirilmesini engeller.</p>
                     <p>C#'ta kapsülleme genellikle şu yollarla sağlanır:</p>
                     <ul>
                         <li>Alanları (fields) <code>private</code> yaparak dışarıdan erişimi engellemek.</li>
                         <li>Bu özel alanlara erişmek ve onları değiştirmek için <code>public</code> özellikler (properties - get/set metotları) tanımlamak. Bu özellikler içinde doğrulama veya ek mantık uygulanabilir.</li>
                     </ul>
                     <p>Yukarıdaki <code>Kedi</code> sınıfı örneğinde <code>yas</code> alanı <code>private</code> yapılmış ve erişim <code>Yas</code> özelliği (property) üzerinden kontrollü bir şekilde (negatif değer kontrolü ile) sağlanmıştır. <code>renk</code> alanı da <code>private</code> olup, <code>RenkAta</code> ve <code>RenkGetir</code> metotları ile yönetilmektedir.</p>
                 </details>

                 <details class="question-block">
                     <summary><h3>Kalıtım (Inheritance)</h3></summary>
                     <p>Bir sınıfın (alt sınıf / türetilmiş sınıf / child class) başka bir sınıfın (üst sınıf / temel sınıf / parent class) özelliklerini ve metotlarını miras almasıdır. "bir ...dır" (is-a) ilişkisini modeller (örn: "Kopek bir Hayvan'dır"). Kod tekrarını azaltır ve hiyerarşik ilişkiler kurmayı sağlar.</p>
                     <p>C#'ta kalıtım, sınıf tanımında <code>: UstSinifAdi</code> şeklinde belirtilir. Bir sınıf sadece tek bir sınıftan doğrudan kalıtım alabilir (çoklu kalıtım desteklenmez, ancak arayüzlerle benzer bir yapı kurulabilir).</p>
                     <p>Alt sınıf, üst sınıfın <code>public</code> ve <code>protected</code> üyelerine erişebilir. <code>base</code> anahtar kelimesi ile üst sınıfın üyelerine (özellikle yapıcı metotlarına veya override edilen metotlarına) erişilebilir.</p>
                     <p>Yukarıdaki <code>Kopek</code> sınıfı, <code>Hayvan</code> sınıfından kalıtım alarak <code>ad</code> özelliğini ve <code>Hayvan</code>'ın yapıcı metodunu (<code>super</code> yerine <code>base</code> ile çağırarak) kullanır, ayrıca kendi <code>cins</code> özelliğini ve <code>getir</code> metodunu ekler, <code>konus</code> metodunu ise override eder (geçersiz kılar).</p>
                      <pre><code class="language-csharp">
public class Canli
{
    public int Yas { get; set; }
    public void NefesAl() { Console.WriteLine("Nefes alınıyor..."); }
}

public class Bitki : Canli // Canli sınıfından kalıtım
{
    public void FotosentezYap() { Console.WriteLine("Fotosentez yapılıyor..."); }
}

public class Hayvan : Canli // Canli sınıfından kalıtım
{
    public string Ad { get; set; }
    public virtual void SesCikar() { Console.WriteLine("Bir ses çıkarıyor..."); } // virtual: override edilebilir
}

public class Kedi : Hayvan // Hayvan sınıfından kalıtım
{
    public override void SesCikar() // override: Üst sınıf metodunu ezer
    {
        base.NefesAl(); // Üst sınıfın metodunu çağırabiliriz
        Console.WriteLine($"{Ad} miyavlıyor...");
    }
}
                    </code></pre>
                 </details>

                 <details class="question-block">
                     <summary><h3>Çok Biçimlilik (Polymorphism)</h3></summary>
                     <p>"Çok biçimlilik" anlamına gelir. Aynı arayüzü (metot imzası) paylaşan nesnelerin, bu arayüze farklı şekillerde yanıt vermesi yeteneğidir. Kalıtım ve arayüzler aracılığıyla sağlanır.</p>
                     <ul>
                         <li><strong>Override Etme (Method Overriding):</strong> Alt sınıfın, üst sınıftan miras aldığı bir metodu (<code>virtual</code> veya <code>abstract</code> olarak işaretlenmiş) kendi uygulamasıyla yeniden tanımlamasıdır. Üst sınıf türünden bir referans alt sınıf nesnesini tuttuğunda, çağrılan metot nesnenin gerçek türüne göre belirlenir (geç bağlama - late binding).</li>
                         <li><strong>Overload Etme (Method Overloading):</strong> Aynı sınıf içinde, aynı isimde ancak farklı parametre listelerine (sayı, tür veya sıra olarak farklı) sahip birden fazla metot tanımlanmasıdır. Hangi metodun çağrılacağı derleme zamanında parametrelere göre belirlenir.</li>
                     </ul>
                     <pre><code class="language-csharp">
// Override örneği (Yukarıdaki Hayvan/Kedi örneğinde SesCikar metodu)
Hayvan hayvanRef = new Kedi { Ad = "Boncuk" }; // Üst sınıf referansı, alt sınıf nesnesini tutuyor
hayvanRef.SesCikar(); // Kedi sınıfındaki override edilmiş SesCikar metodu çalışır ("Boncuk miyavlıyor...")

// Overload örneği
public class HesapMakinesi
{
    public int Topla(int a, int b)
    {
        Console.WriteLine("İki int toplandı.");
        return a + b;
    }

    public double Topla(double a, double b)
    {
        Console.WriteLine("İki double toplandı.");
        return a + b;
    }

     public int Topla(int a, int b, int c)
    {
        Console.WriteLine("Üç int toplandı.");
        return a + b + c;
    }
}

HesapMakinesi calc = new HesapMakinesi();
calc.Topla(5, 3);      // İki int toplandı. çağrılır
calc.Topla(2.5, 3.7);  // İki double toplandı. çağrılır
calc.Topla(1, 2, 3);   // Üç int toplandı. çağrılır
                    </code></pre>
                 </details>

                 <details class="question-block">
                     <summary><h3>Soyutlama (Abstraction)</h3></summary>
                     <p>Bir nesnenin karmaşık iç detaylarını gizleyerek sadece gerekli özelliklerini ve davranışlarını dışarıya sunma prensibidir. Kullanıcının nesneyi nasıl kullanacağına odaklanmasını sağlar, iç implementasyon detaylarıyla ilgilenmesini gerektirmez.</p>
                     <p>C#'ta soyutlama şu yollarla sağlanır:</p>
                     <ul>
                         <li><strong>Arayüzler (Interfaces):</strong> Bir sınıfın uygulaması gereken metotları, özellikleri, olayları ve indexer'ları tanımlayan bir sözleşmedir. Hiçbir implementasyon içermez (C# 8.0 ile varsayılan implementasyon eklense de temel amaç sözleşmedir). Bir sınıf birden fazla arayüzü uygulayabilir.
                             <pre><code class="language-csharp">
interface IHareketEdebilir
{
    void HareketEt(); // İmza (implementasyon yok)
    int Hiz { get; set; } // Özellik imzası
}

public class Araba : IHareketEdebilir // Arayüzü uygulama
{
    public int Hiz { get; set; }
    public void HareketEt()
    {
        Console.WriteLine($"Araba {Hiz} km/s hızla hareket ediyor.");
    }
}
                            </code></pre>
                         </li>
                         <li><strong>Soyut Sınıflar (Abstract Classes):</strong> Hem implemente edilmiş (gövdeli) hem de implemente edilmemiş (<code>abstract</code> - gövdesiz) üyeler içerebilen sınıflardır. Doğrudan nesnesi oluşturulamaz (<code>new</code> ile), sadece kalıtım alınabilir. Alt sınıflar, üst sınıftaki tüm <code>abstract</code> üyeleri override etmek zorundadır. Bir sınıf sadece tek bir abstract sınıftan kalıtım alabilir.
                            <pre><code class="language-csharp">
public abstract class Sekil // Soyut sınıf
{
    public string Renk { get; set; }
    public abstract double AlanHesapla(); // Soyut metot (gövdesi yok)
    public void BilgiYazdir() // Somut metot
    {
        Console.WriteLine($"Bu bir {Renk} şekildir.");
    }
}

public class Daire : Sekil
{
    public double YariCap { get; set; }
    public override double AlanHesapla() // Soyut metodu override etme zorunluluğu
    {
        return Math.PI * YariCap * YariCap;
    }
}
                            </code></pre>
                         </li>
                     </ul>
                     <p>Soyutlama, kodun daha esnek, genişletilebilir ve bakımı kolay olmasını sağlar.</p>
                 </details>
            </section>

             <section id="dotnet-kutuphaneler" class="content-section">
                <h2>Temel .NET Kütüphaneleri ve Kavramlar</h2>
                <p>.NET platformu, uygulama geliştirmeyi kolaylaştıran zengin bir Temel Sınıf Kütüphanesi (Base Class Library - BCL) sunar. Ayrıca C#'ın kendine özgü güçlü dil özellikleri bulunur.</p>

                <details class="question-block">
                    <summary><h3>Koleksiyonlar (Collections)</h3></summary>
                    <p>Verileri gruplamak ve yönetmek için çeşitli koleksiyon sınıfları sunulur (<code>System.Collections.Generic</code> isim alanında).</p>
                    <ul>
                        <li><strong><code>List<T></code>:</strong> Dinamik boyutlu, tür güvenli (generic) bir liste. Eleman ekleme (<code>Add</code>), silme (<code>Remove</code>), index ile erişim gibi işlemler için kullanılır. Dizilere göre daha esnektir.
                            <pre><code class="language-csharp">
List<string> isimler = new List<string>();
isimler.Add("Ayşe");
isimler.Add("Fatma");
isimler.Add("Hayriye");
isimler.Remove("Fatma");
Console.WriteLine(isimler[0]); // Ayşe
foreach(string isim in isimler) { Console.WriteLine(isim); }
                            </code></pre>
                        </li>
                        <li><strong><code>Dictionary<TKey, TValue></code>:</strong> Anahtar-değer çiftlerini saklayan bir koleksiyon (hash table tabanlı). Anahtarlar benzersiz olmalıdır. Belirli bir anahtara karşılık gelen değere hızlı erişim sağlar.
                             <pre><code class="language-csharp">
Dictionary<string, int> yaslar = new Dictionary<string, int>();
yaslar.Add("Ali", 30);
yaslar["Veli"] = 40; // Ekleme veya güncelleme
yaslar.Add("Ayşe", 25);

Console.WriteLine($"Veli'nin yaşı: {yaslar["Veli"]}"); // 40

if (yaslar.ContainsKey("Ali")) { /* ... */ }

foreach(KeyValuePair<string, int> cift in yaslar)
{
    Console.WriteLine($"{cift.Key}: {cift.Value}");
}
                            </code></pre>
                        </li>
                        <li><strong><code>Queue<T></code>:</strong> FIFO (First-In, First-Out) mantığıyla çalışan kuyruk yapısı (<code>Enqueue</code> ile eklenir, <code>Dequeue</code> ile çıkarılır).</li>
                        <li><strong><code>Stack<T></code>:</strong> LIFO (Last-In, First-Out) mantığıyla çalışan yığın yapısı (<code>Push</code> ile eklenir, <code>Pop</code> ile çıkarılır).</li>
                        <li><strong><code>HashSet<T></code>:</strong> Benzersiz elemanları sırasız olarak saklayan bir küme. Eleman kontrolü (<code>Contains</code>) çok hızlıdır.</li>
                    </ul>
                    <p>Bunlar dışında <code>SortedList<TKey, TValue></code>, <code>LinkedList<T></code> gibi daha özel ihtiyaçlara yönelik koleksiyonlar da mevcuttur.</p>
                </details>

                <details class="question-block">
                    <summary><h3>LINQ (Language Integrated Query)</h3></summary>
                    <p>LINQ, C# diline doğrudan entegre edilmiş güçlü bir sorgulama yeteneğidir. Farklı veri kaynakları (bellekteki koleksiyonlar, veritabanları, XML vb.) üzerinde SQL benzeri bir sözdizimi veya metot tabanlı (fluent) bir sözdizimi kullanarak filtreleme, sıralama, gruplama, projeksiyon gibi işlemler yapmayı sağlar.</p>
                    <ul>
                        <li><strong>Sorgu Sözdizimi (Query Syntax):</strong> SQL'e benzer, <code>from</code>, <code>where</code>, <code>orderby</code>, <code>select</code>, <code>group by</code> gibi anahtar kelimelerle yazılır.
                             <pre><code class="language-csharp">
List<int> sayilar = new List<int> { 5, 12, 8, 3, 20, 7 };

// Sorgu Sözdizimi: 10'dan küçük sayıları bul ve sırala
var kucukSayilarSorgu = from sayi in sayilar
                          where sayi < 10
                          orderby sayi ascending // veya descending
                          select sayi;

Console.WriteLine("10'dan Küçük Sayılar (Sorgu):");
foreach (int s in kucukSayilarSorgu)
{
    Console.WriteLine(s); // 3, 5, 7, 8
}
                            </code></pre>
                        </li>
                         <li><strong>Metot Sözdizimi (Method Syntax / Fluent Syntax):</strong> Standart sorgu operatörlerini (<code>Where</code>, <code>OrderBy</code>, <code>Select</code>, <code>GroupBy</code>, <code>First</code>, <code>Count</code>, <code>Sum</code> vb.) lambda ifadeleriyle birlikte metot çağrıları şeklinde kullanır. Genellikle daha esnek ve yaygındır.
                             <pre><code class="language-csharp">
List<string> sehirler = new List<string> { "İstanbul", "Ankara", "İzmir", "Bursa", "Antalya" };

// Metot Sözdizimi: 'a' harfi içeren şehirleri büyük harfle al
var aIcerekSehirler = sehirler
                        .Where(sehir => sehir.ToLower().Contains("a"))
                        .OrderBy(sehir => sehir.Length) // Uzunluğa göre sırala
                        .Select(sehir => sehir.ToUpper()); // Büyük harfe çevir

Console.WriteLine("\n'A' İçeren Şehirler (Metot):");
foreach(string s in aIcerekSehirler)
{
    Console.WriteLine(s); // ANKARA, BURSA, ANTALYA, İSTANBUL
}

// İlk elemanı bulma veya varsayılan değeri alma
string ilkSehir = sehirler.FirstOrDefault(); // "İstanbul"
int ondanBuyukIlk = sayilar.FirstOrDefault(s => s > 10); // 12

// Toplam veya ortalama alma
int sayiAdedi = sayilar.Count(); // 6
double ortalama = sayilar.Average();
                            </code></pre>
                        </li>
                    </ul>
                    <p>LINQ, kodun daha okunabilir, kısa ve verimli olmasını sağlar. Özellikle Entity Framework Core ile veritabanı sorguları yazarken çok güçlüdür.</p>
                </details>

                <details class="question-block">
                     <summary><h3>Delegate'ler ve Event'ler</h3></summary>
                     <ul>
                         <li><strong>Delegate (Temsilci):</strong> Bir veya daha fazla metoda referans tutabilen bir tiptir. Metot imzalarını (parametre tipleri ve dönüş tipi) tanımlar. Olay yönetimi (event handling), callback mekanizmaları ve LINQ gibi birçok .NET özelliğinin temelini oluşturur. Belirli bir imzaya uyan herhangi bir metot bir delegate değişkenine atanabilir veya parametre olarak geçilebilir.
                             <pre><code class="language-csharp">
// Bir delegate tanımı: int parametre alıp bool döndüren metotlara referans tutar
public delegate bool SayiKontrolDelegate(int sayi);

public class DelegateOrnek
{
    public bool CiftMi(int n) { return n % 2 == 0; }
    public bool PozitifMi(int n) { return n > 0; }

    public void KontrolEt(int[] dizi, SayiKontrolDelegate kontrolMetodu)
    {
        Console.WriteLine($"\n'{kontrolMetodu.Method.Name}' metodu ile kontrol:");
        foreach (int sayi in dizi)
        {
            if (kontrolMetodu(sayi)) // Delegate üzerinden metodu çağırma
            {
                Console.Write($"{sayi} ");
            }
        }
        Console.WriteLine();
    }

    public void Calistir()
    {
        int[] sayilar = { 1, -2, 3, 4, -5, 6 };

        // Delegate değişkeni oluşturma ve metot atama
        SayiKontrolDelegate ciftKontrol = CiftMi;
        SayiKontrolDelegate pozitifKontrol = PozitifMi;

        KontrolEt(sayilar, ciftKontrol); // CiftMi metodu çalışır
        KontrolEt(sayilar, pozitifKontrol); // PozitifMi metodu çalışır

        // Anonim metot veya lambda ifadesi ile delegate kullanımı
        KontrolEt(sayilar, delegate(int x) { return x < 0; }); // Negatifleri bul
        KontrolEt(sayilar, x => x % 3 == 0); // 3'e bölünenleri bul (Lambda)
    }
}
                             </code></pre>
                             .NET, yaygın kullanılan imzalar için <code>Action<...></code> (değer döndürmeyen) ve <code>Func<..., TResult></code> (değer döndüren) gibi hazır generic delegate'ler sunar.
                         </li>
                         <li><strong>Event (Olay):</strong> Bir sınıfta önemli bir durum değişikliği veya eylem gerçekleştiğinde (örn: butona tıklama, işlem tamamlama) diğer nesneleri bilgilendirmek için kullanılan bir mekanizmadır. Yayıncı-Abone (Publisher-Subscriber) desenini uygular. Event'ler genellikle delegate'ler üzerine kuruludur. Bir sınıf bir event tanımlar (<code>event</code> anahtar kelimesi), diğer sınıflar bu event'e abone olur (<code>+=</code> operatörü ile olay işleyici metotlarını ekler) ve event tetiklendiğinde (yayıncı sınıf tarafından çağrıldığında) abone olan tüm metotlar çalıştırılır. Abonelikten çıkmak için <code>-=</code> kullanılır.
                             <pre><code class="language-csharp">
public class Buton
{
    // Olay tanımı (EventHandler delegate'i yaygın kullanılır)
    public event EventHandler Tiklandi;

    // Olayı tetikleyen metot (genellikle protected virtual olur)
    protected virtual void OnTiklandi(EventArgs e)
    {
        // Abone olan var mı kontrol et
        // EventHandler kopyası alınıp null kontrolü yapılır (thread-safe)
        EventHandler handler = Tiklandi;
        if (handler != null)
        {
            handler(this, e); // Abone olan metotları çağır
        }
    }

    // Butona basılmasını simüle eden metot
    public void Bas()
    {
        Console.WriteLine("Butona basıldı!");
        OnTiklandi(EventArgs.Empty); // Olayı tetikle
    }
}

public class Form
{
    public void ButonTiklandiHandler(object sender, EventArgs e)
    {
        Console.WriteLine("Form: Buton tıklama olayı yakalandı!");
        // Gerekli işlemleri yap...
    }

    public void Calistir()
    {
        Buton btn = new Buton();
        // Event'e abone olma
        btn.Tiklandi += ButonTiklandiHandler;
        btn.Tiklandi += (sender, e) => Console.WriteLine("Lambda ile abone olundu!"); // Lambda ile abone olma

        btn.Bas(); // Olayı tetikle

        // Abonelikten çıkma
        // btn.Tiklandi -= ButonTiklandiHandler;
    }
}
                             </code></pre>
                         </li>
                     </ul>
                 </details>

                <details class="question-block">
                    <summary><h3>İstisna Yönetimi (Exception Handling)</h3></summary>
                    <p>Program çalışırken beklenmedik durumlar veya hatalar (örn: dosyayı bulamama, sıfıra bölme, ağ bağlantı hatası) oluştuğunda programın çökmesini engellemek ve bu durumları yönetmek için istisna yönetimi kullanılır.</p>
                    <p><code>try-catch-finally</code> bloğu kullanılır:</p>
                     <ul>
                         <li><strong><code>try</code> Bloğu:</strong> Hata oluşma potansiyeli olan kodlar buraya yazılır.</li>
                         <li><strong><code>catch (ExceptionType ex)</code> Bloğu:</strong> <code>try</code> bloğunda belirli türde bir istisna (exception) fırlatılırsa bu blok çalışır. Farklı hata türleri için birden fazla <code>catch</code> bloğu olabilir (daha spesifik olan önce yazılmalıdır). <code>ex</code> değişkeni hata hakkında detaylı bilgi içerir. Genel <code>Exception</code> türü tüm hataları yakalar.</li>
                         <li><strong><code>finally</code> Bloğu (İsteğe bağlı):</strong> Hata oluşsa da oluşmasa da her zaman çalıştırılır (kaynakları serbest bırakmak için - dosya kapatma, bağlantı sonlandırma vb.).</li>
                         <li><strong><code>throw</code> İfadesi:</strong> Özel bir istisna fırlatmak veya yakalanan bir istisnayı tekrar fırlatmak için kullanılır.</li>
                     </ul>
                      <pre><code class="language-csharp">
public void DosyaOku(string dosyaYolu)
{
    StreamReader reader = null; // finally bloğunda erişmek için dışarıda tanımla
    try
    {
        reader = new StreamReader(dosyaYolu);
        string satir = reader.ReadLine();
        while (satir != null)
        {
            Console.WriteLine(satir);
            satir = reader.ReadLine();
        }
        Console.WriteLine("Dosya okuma tamamlandı.");

        // Bilerek hata fırlatma örneği (test için)
        // throw new InvalidOperationException("Test hatası!");

    }
    catch (FileNotFoundException ex) // Spesifik Hata Yakalama
    {
        Console.WriteLine($"Hata: Dosya bulunamadı! ({ex.FileName})");
    }
    catch (IOException ex) // Daha genel I/O hatası
    {
         Console.WriteLine($"Hata: Dosya okuma hatası! ({ex.Message})");
    }
    catch (Exception ex) // Diğer tüm hataları yakalama (en sona yazılmalı)
    {
        Console.WriteLine($"Beklenmedik bir hata oluştu: {ex.Message}");
        // throw; // Yakalanan hatayı tekrar fırlatmak isterseniz
    }
    finally
    {
        // Hata olsa da olmasa da çalışır (kaynağı serbest bırak)
        if (reader != null)
        {
            reader.Close(); // veya reader.Dispose();
            Console.WriteLine("StreamReader kapatıldı.");
        }
    }
}

// using ifadesi (IDisposable kaynakları otomatik serbest bırakır)
public void DosyaOkuUsing(string dosyaYolu)
{
    try
    {
        // using bloğu bittiğinde reader.Dispose() otomatik çağrılır
        using (StreamReader reader = new StreamReader(dosyaYolu))
        {
            string icerik = reader.ReadToEnd();
            Console.WriteLine("\nDosya İçeriği (using ile):\n" + icerik);
        } // reader.Dispose() burada çağrılır
    }
    catch (Exception ex)
    {
        Console.WriteLine($"Hata (using): {ex.Message}");
    }
}
                     </code></pre>
                 </details>
            </section>

            <section id="veri-erisim" class="content-section">
                 <h2>Veritabanı İşlemleri: Entity Framework Core</h2>
                 <p>Modern uygulamaların çoğu verileri kalıcı olarak saklamak için veritabanları kullanır. .NET, veritabanlarıyla etkileşim kurmak için çeşitli teknolojiler sunar. Bunlardan en popüler ve modern olanı Entity Framework Core'dur (EF Core).</p>
                 <p>EF Core, nesne ilişkisel eşleyici (Object-Relational Mapper - ORM) bir kütüphanedir. Geliştiricilerin .NET nesnelerini kullanarak (SQL sorguları yazmadan) veritabanı işlemleri (CRUD - Create, Read, Update, Delete) yapmasını sağlar. Veritabanı tablolarını C# sınıflarına (Entities), satırları nesnelere eşler.</p>

                 <details class="question-block">
                     <summary><h3>Temel EF Core Kavramları: DbContext, DbSet, Entity</h3></summary>
                     <ul>
                         <li><strong>Entity (Varlık):</strong> Veritabanındaki bir tabloyu temsil eden basit bir C# sınıfıdır (POCO - Plain Old CLR Object). Genellikle tablodaki sütunlara karşılık gelen özelliklere (properties) sahiptir.</li>
                         <li><strong>DbContext (Veritabanı Bağlamı):</strong> Veritabanı ile uygulama arasındaki ana etkileşim noktasıdır. Veritabanı bağlantısını yönetir, veritabanı şemasını (hangi tabloların olduğu) bilir ve veritabanı sorgularını oluşturup yürütür. Genellikle <code>DbContext</code> sınıfından türetilir.</li>
                         <li><strong>DbSet<TEntity>:</strong> <code>DbContext</code> içinde, belirli bir Entity türü (ve dolayısıyla veritabanı tablosu) için bir koleksiyonu temsil eder. LINQ sorguları bu <code>DbSet</code> nesneleri üzerinden yapılır.</li>
                     </ul>
                      <pre><code class="language-csharp">
using Microsoft.EntityFrameworkCore; // Gerekli using ifadesi
using System.Collections.Generic;

// Entity Sınıfı
public class Urun
{
    public int UrunId { get; set; } // Primary Key (varsayılan olarak Id veya UrunId isminden anlaşılır)
    public string Ad { get; set; }
    public decimal Fiyat { get; set; }
    public int StokAdedi { get; set; }
}

// DbContext Sınıfı
public class UygulamaDbContext : DbContext
{
    // Veritabanındaki 'Urunler' tablosunu temsil eden DbSet
    public DbSet<Urun> Urunler { get; set; }

    // Veritabanı bağlantı ayarları (genellikle appsettings.json'dan alınır)
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        // Örnek: SQL Server bağlantısı (ConnectionString normalde dışarıdan verilir)
        if (!optionsBuilder.IsConfigured) // Eğer dışarıdan konfigüre edilmediyse
        {
             optionsBuilder.UseSqlServer("Server=(localdb)\\mssqllocaldb;Database=EFCoreOrnekDb;Trusted_Connection=True;");
        }
    }

    // İsteğe bağlı: Model yapılandırması (Fluent API)
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<Urun>()
            .Property(u => u.Fiyat)
            .HasColumnType("decimal(18,2)"); // Fiyat sütununun veritabanı tipini belirle
    }
}
                     </code></pre>
                     <p>EF Core'u kullanmak için projenize ilgili NuGet paketlerinin (<code>Microsoft.EntityFrameworkCore</code>, <code>Microsoft.EntityFrameworkCore.SqlServer</code> veya ilgili veritabanı sağlayıcısı, <code>Microsoft.EntityFrameworkCore.Tools</code>) eklenmesi gerekir.</p>
                 </details>

                 <details class="question-block">
                     <summary><h3>CRUD İşlemleri ve LINQ Sorguları</h3></summary>
                     <p><code>DbContext</code> ve <code>DbSet</code> kullanılarak veritabanı üzerinde temel CRUD işlemleri ve LINQ ile sorgulama yapılır.</p>
                      <pre><code class="language-csharp">
using System.Linq; // LINQ için gerekli

public class VeritabaniIslemleri
{
    public void Calistir()
    {
        // DbContext örneği oluştur (using ile otomatik Dispose sağlanır)
        using (var context = new UygulamaDbContext())
        {
            Console.WriteLine("Veritabanı işlemleri başlıyor...");

            // --- CREATE (Oluşturma) ---
            Console.WriteLine("\nYeni ürün ekleniyor...");
            var yeniUrun = new Urun { Ad = "Laptop X", Fiyat = 25000m, StokAdedi = 15 };
            context.Urunler.Add(yeniUrun); // Değişikliği bellekte takip etmeye başla
            context.SaveChanges(); // Değişiklikleri veritabanına kaydet
            Console.WriteLine($"Eklenen ürün ID: {yeniUrun.UrunId}");

            // --- READ (Okuma - LINQ ile Sorgulama) ---
            Console.WriteLine("\nTüm ürünler okunuyor:");
            var tumUrunler = context.Urunler.ToList(); // Tüm ürünleri çek
            foreach (var urun in tumUrunler)
            {
                Console.WriteLine($"- {urun.Ad} ({urun.Fiyat:C}) - Stok: {urun.StokAdedi}");
            }

            Console.WriteLine("\nFiyatı 20000'den yüksek ürünler:");
            var pahaliUrunler = context.Urunler
                                     .Where(u => u.Fiyat > 20000m)
                                     .OrderBy(u => u.Ad)
                                     .ToList();
            foreach (var urun in pahaliUrunler)
            {
                Console.WriteLine($"- {urun.Ad}");
            }

            Console.WriteLine("\nID'si 1 olan ürünü bulma:");
            // FirstOrDefault: Bulamazsa null döner
            var bulunanUrun = context.Urunler.FirstOrDefault(u => u.UrunId == yeniUrun.UrunId);
            // Find: Primary Key ile arama (önce bellekte arar, yoksa DB'ye gider - daha hızlı olabilir)
            // var bulunanUrun = context.Urunler.Find(yeniUrun.UrunId);
            if (bulunanUrun != null)
            {
                Console.WriteLine($"Bulunan: {bulunanUrun.Ad}");

                // --- UPDATE (Güncelleme) ---
                Console.WriteLine("\nÜrün güncelleniyor...");
                bulunanUrun.Fiyat *= 0.9m; // Fiyatı %10 düşür
                bulunanUrun.StokAdedi -= 1;
                context.SaveChanges(); // Değişiklikleri kaydet
                Console.WriteLine($"Güncellenen fiyat: {bulunanUrun.Fiyat:C}, Stok: {bulunanUrun.StokAdedi}");
            }
            else
            {
                Console.WriteLine("Güncellenecek ürün bulunamadı.");
            }

            // --- DELETE (Silme) ---
             if (bulunanUrun != null)
             {
                Console.WriteLine("\nÜrün siliniyor...");
                context.Urunler.Remove(bulunanUrun); // Silme için işaretle
                context.SaveChanges(); // Değişiklikleri kaydet
                Console.WriteLine($"{bulunanUrun.Ad} silindi.");
             }

             // Silindiğini doğrulama
             var silinmisUrun = context.Urunler.Find(yeniUrun.UrunId);
             if(silinmisUrun == null) {
                 Console.WriteLine("Ürün başarıyla silinmiş.");
             }
        } // context.Dispose() burada otomatik çağrılır
    }
}
                    </code></pre>
                     <p><code>SaveChanges()</code> metodu çağrılana kadar yapılan değişiklikler (Add, Update, Remove) sadece bellekte tutulur, veritabanına yansımaz. Bu metot, yapılan tüm değişiklikleri tek bir işlem (transaction) içinde veritabanına gönderir.</p>
                 </details>

                 <details class="question-block">
                     <summary><h3>Migrations (Veritabanı Geçişleri)</h3></summary>
                     <p>Uygulama geliştirme sürecinde Entity sınıflarınız (ve dolayısıyla veritabanı şemanız) zamanla değişebilir (yeni tablo ekleme, sütun değiştirme vb.). EF Core Migrations, bu model değişikliklerini veritabanı şemasına güvenli bir şekilde uygulamak için kullanılan bir araçtır.</p>
                     <p>Temel Adımlar (Package Manager Console veya .NET CLI üzerinden):</p>
                     <ol>
                         <li><strong>Migration Ekleme:</strong> Modelde bir değişiklik yaptıktan sonra, bu değişikliği uygulayacak bir migration betiği oluşturulur.
                            <ul>
                                <li>PMC: <code>Add-Migration MigrationAdi</code></li>
                                <li>CLI: <code>dotnet ef migrations add MigrationAdi</code></li>
                            </ul>
                            Bu komut, projenizde bir "Migrations" klasörü oluşturur ve içine C# koduyla yazılmış, değişiklikleri tanımlayan (<code>Up</code> metodu) ve geri almayı sağlayan (<code>Down</code> metodu) bir migration dosyası ekler.
                         </li>
                         <li><strong>Veritabanını Güncelleme:</strong> Oluşturulan migration betiğini veritabanına uygular.
                             <ul>
                                 <li>PMC: <code>Update-Database</code></li>
                                 <li>CLI: <code>dotnet ef database update</code></li>
                             </ul>
                             Bu komut, bekleyen tüm migration'ları sırayla çalıştırarak veritabanı şemasını güncel hale getirir. Ayrıca veritabanı yoksa oluşturur.
                         </li>
                         <li><strong>Migration Kaldırma (İsteğe Bağlı):</strong> Henüz veritabanına uygulanmamış son migration'ı kaldırmak için.
                             <ul>
                                 <li>PMC: <code>Remove-Migration</code></li>
                                 <li>CLI: <code>dotnet ef migrations remove</code></li>
                             </ul>
                         </li>
                          <li><strong>Belirli Bir Migration'a Dönme (İsteğe Bağlı):</strong>
                             <ul>
                                 <li>PMC: <code>Update-Database MigrationAdi</code></li>
                                 <li>CLI: <code>dotnet ef database update MigrationAdi</code></li>
                             </ul>
                         </li>
                     </ol>
                     <p>Migrations kullanmak, veritabanı şemasını kodla birlikte versiyon kontrol sisteminde (Git vb.) takip etmeyi sağlar ve takım çalışmalarında veya farklı ortamlara (geliştirme, test, üretim) dağıtım yaparken şema uyumluluğunu yönetmeyi kolaylaştırır.</p>
                 </details>
            </section>

            <section id="web-gelistirme" class="content-section">
                <h2>Web Geliştirme: ASP.NET Core</h2>
                <p>ASP.NET Core, .NET platformu üzerinde modern, bulut tabanlı, internete bağlı uygulamalar (web uygulamaları, API'ler, mikroservisler) oluşturmak için tasarlanmış açık kaynaklı, çapraz platform bir framework'tür. Yüksek performans, modülerlik ve esneklik sunar.</p>

                <details class="question-block">
                    <summary><h3>ASP.NET Core Mimarisi: Middleware ve İstek İşleme Hattı</h3></summary>
                    <p>ASP.NET Core uygulamalarında gelen her HTTP isteği, bir "istek işleme hattı" (request pipeline) üzerinden geçer. Bu hat, "middleware" adı verilen bileşenlerden oluşur. Her middleware, gelen isteği işleme, yanıtı değiştirme ve hattaki bir sonraki middleware'e devretme veya isteği kısa devre yaparak doğrudan yanıt döndürme yeteneğine sahiptir.</p>
                    <p>Middleware'ler <code>Startup.cs</code> (veya modern .NET 6+ projelerinde <code>Program.cs</code>) dosyasındaki <code>Configure</code> metodu içinde yapılandırılır. Sıralamaları önemlidir, çünkü istekler ve yanıtlar bu sıraya göre işlenir.</p>
                    <p>Yaygın Middleware'ler:</p>
                    <ul>
                        <li><strong>Exception Handling:</strong> Hataları yakalar ve kullanıcı dostu hata sayfaları gösterir.</li>
                        <li><strong>Static Files:</strong> HTML, CSS, JavaScript, resim gibi statik dosyaların sunulmasını sağlar.</li>
                        <li><strong>Routing:</strong> Gelen isteğin URL'sine göre hangi kodun (Endpoint - Controller Action, Razor Page, Minimal API handler) çalıştırılacağını belirler.</li>
                        <li><strong>Authentication:</strong> Kullanıcının kimliğini doğrular.</li>
                        <li><strong>Authorization:</strong> Kimliği doğrulanmış kullanıcının belirli kaynaklara erişim yetkisini kontrol eder.</li>
                        <li><strong>CORS (Cross-Origin Resource Sharing):</strong> Farklı bir origin'den (domain, protokol, port) gelen istemci tarafı isteklerine izin verilip verilmeyeceğini kontrol eder.</li>
                        <li><strong>HTTPS Redirection:</strong> Gelen HTTP isteklerini otomatik olarak HTTPS'e yönlendirir.</li>
                    </ul>
                    <pre><code class="language-csharp">
// Program.cs (ASP.NET Core 6+) Minimal Hosting Modeli Örneği
var builder = WebApplication.CreateBuilder(args);

// Servisleri ekleme (DI Container'a)
builder.Services.AddControllersWithViews(); // MVC için servisler
builder.Services.AddRazorPages();       // Razor Pages için servisler

var app = builder.Build();

// Middleware'leri yapılandırma (Sıralama Önemli!)
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Home/Error"); // Hata yönetimi (üretim)
    app.UseHsts(); // HTTP Strict Transport Security
} else {
    app.UseDeveloperExceptionPage(); // Geliştirme ortamı hata sayfası
}

app.UseHttpsRedirection(); // HTTPS yönlendirmesi
app.UseStaticFiles();      // Statik dosya sunumu (wwwroot klasörü)

app.UseRouting();          // Yönlendirme middleware'i

// app.UseCors();          // CORS (gerekirse)
// app.UseAuthentication(); // Kimlik doğrulama
app.UseAuthorization();  // Yetkilendirme

// Endpoint'leri (Controller, Razor Page vb.) eşleme
app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}"); // Varsayılan MVC rotası
app.MapRazorPages(); // Razor Pages için endpoint'ler

app.Run(); // Uygulamayı başlat
                    </code></pre>
                </details>

                <details class="question-block">
                    <summary><h3>Uygulama Modelleri: MVC, Razor Pages, Web API, Minimal APIs</h3></summary>
                    <p>ASP.NET Core, farklı ihtiyaçlara yönelik çeşitli uygulama modelleri sunar:</p>
                    <ul>
                        <li><strong>MVC (Model-View-Controller):</strong> Geleneksel ve yaygın kullanılan bir tasarım desenidir. Uygulamayı üç ana bileşene ayırır:
                            <ul>
                                <li><strong>Model:</strong> Uygulamanın verilerini ve iş mantığını temsil eder (genellikle Entity sınıfları ve iş kurallarını içeren servisler).</li>
                                <li><strong>View (Görünüm):</strong> Kullanıcı arayüzünü (HTML) oluşturur. Genellikle Razor sözdizimini kullanır. Verileri Model'den alır ve kullanıcıya gösterir.</li>
                                <li><strong>Controller (Denetleyici):</strong> Gelen istekleri alır, Model ile etkileşime girer (veriyi alır/işler) ve uygun View'ı seçerek kullanıcıya yanıtı döndürür.</li>
                            </ul>
                            Büyük, test edilebilir ve bakımı kolay uygulamalar için uygundur.
                        </li>
                        <li><strong>Razor Pages:</strong> Sayfa odaklı bir yaklaşımdır. Her sayfa kendi <code>.cshtml</code> (Razor görünümü) ve <code>.cshtml.cs</code> (PageModel - C# kodları ve iş mantığı) dosyasına sahiptir. MVC'ye göre daha basit ve daha hızlı geliştirme sağlayabilir, özellikle form tabanlı veya basit CRUD işlemleri içeren uygulamalar için uygundur.</li>
                        <li><strong>Web API:</strong> Kullanıcı arayüzü olmayan, genellikle HTTP üzerinden JSON veya XML formatında veri alışverişi yapan servisler oluşturmak için kullanılır. Tarayıcı tabanlı istemciler (SPA'lar - React, Angular, Vue), mobil uygulamalar veya diğer sunucu uygulamaları tarafından tüketilir. Genellikle Controller tabanlıdır (<code>ControllerBase</code>'den türetilir) ancak Minimal API'ler de kullanılabilir.</li>
                        <li><strong>Minimal APIs (.NET 6+):</strong> API endpoint'lerini çok daha az kodla, doğrudan <code>Program.cs</code> içinde tanımlamayı sağlayan yeni ve basit bir yaklaşımdır. Hızlı prototipleme, mikroservisler veya basit API'ler için idealdir. MVC'nin tüm özelliklerine ihtiyaç duyulmayan durumlar için daha hafiftir.
                            <pre><code class="language-csharp">
// Program.cs içinde Minimal API örneği
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

// Basit GET endpoint'i
app.MapGet("/", () => "Merhaba Minimal API!");

// Parametre alan GET endpoint'i
app.MapGet("/kullanici/{id}", (int id) => $"Kullanıcı ID: {id}");

// POST endpoint'i
app.MapPost("/urunler", (Urun urun) => {
    // Gelen ürünü veritabanına ekleme vb.
    Console.WriteLine($"Yeni ürün eklendi: {urun.Ad}");
    return Results.Created($"/urunler/{urun.UrunId}", urun); // 201 Created yanıtı
});

app.Run();

// Kullanılacak Urun sınıfı (örnek)
public class Urun { public int UrunId { get; set; } public string Ad { get; set; } }
                            </code></pre>
                        </li>
                    </ul>
                    <p>Bir ASP.NET Core projesinde bu modeller bir arada da kullanılabilir.</p>
                </details>

                <details class="question-block">
                    <summary><h3>Bağımlılık Enjeksiyonu (Dependency Injection - DI)</h3></summary>
                    <p>DI, ASP.NET Core'un temel tasarım prensiplerinden biridir. Bir sınıfın (bağımlı sınıf) ihtiyaç duyduğu başka nesneleri (bağımlılıklar - dependencies) kendisinin oluşturması yerine, bu bağımlılıkların dışarıdan (genellikle bir DI konteyneri tarafından) sağlanmasıdır. Bu, "Inversion of Control" (Kontrolün Tersine Çevrilmesi - IoC) ilkesinin bir uygulamasıdır.</p>
                    <p>Faydaları:</p>
                    <ul>
                        <li><strong>Gevşek Bağlılık (Loose Coupling):</strong> Sınıflar arasındaki doğrudan bağımlılıkları azaltır, bir sınıfın değiştirilmesi diğerlerini daha az etkiler.</li>
                        <li><strong>Test Edilebilirlik:</strong> Bağımlılıklar dışarıdan verildiği için, test sırasında gerçek bağımlılıklar yerine sahte (mock) nesneler enjekte edilerek sınıfın izole bir şekilde test edilmesi kolaylaşır.</li>
                        <li><strong>Tekrar Kullanılabilirlik ve Bakım Kolaylığı:</strong> Bileşenlerin değiştirilmesi ve yönetilmesi daha kolay hale gelir.</li>
                    </ul>
                    <p>ASP.NET Core, yerleşik bir DI konteyneri ile gelir. Servisler (bağımlılıklar) <code>Program.cs</code> (veya <code>Startup.cs</code>'teki <code>ConfigureServices</code> metodu) içinde konteynere kaydedilir ve ardından ihtiyaç duyan sınıfların yapıcı metotları (constructor injection - en yaygın yöntem) aracılığıyla otomatik olarak enjekte edilir.</p>
                    <p>Servis Yaşam Süreleri:</p>
                    <ul>
                        <li><strong>Transient (Geçici):</strong> Servis her talep edildiğinde yeni bir örnek oluşturulur.</li>
                        <li><strong>Scoped (Kapsamlı):</strong> Her bir web isteği (request) başına tek bir örnek oluşturulur ve istek boyunca aynı örnek kullanılır.</li>
                        <li><strong>Singleton (Tekil):</strong> Uygulama ömrü boyunca sadece tek bir örnek oluşturulur ve her talepte aynı örnek kullanılır.</li>
                    </ul>
                    <pre><code class="language-csharp">
// Program.cs (veya Startup.cs) içinde servis kaydı
var builder = WebApplication.CreateBuilder(args);

// Servisleri kaydetme
builder.Services.AddDbContext<UygulamaDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection"))); // Scoped (varsayılan DbContext için)

builder.Services.AddScoped<IUrunRepository, SqlUrunRepository>(); // Arayüz ve implementasyonunu kaydet (Scoped)
builder.Services.AddTransient<IEpostaGonderici, SmtpEpostaGonderici>(); // Transient
builder.Services.AddSingleton<IUygulamaAyarlari, UygulamaAyarlari>(); // Singleton

builder.Services.AddControllersWithViews();

var app = builder.Build();
// ... Middleware yapılandırması ...
app.Run();

// ----- Örnek Kullanım (Controller içinde Constructor Injection) -----
// Aşağıdaki IUrunRepository ve SqlUrunRepository tanımlamaları varsayımsaldır.
// public interface IUrunRepository { List<Urun> TumunuGetir(); }
// public class SqlUrunRepository : IUrunRepository { /* Implementasyon */ public List<Urun> TumunuGetir() { return new List<Urun>(); } }
// public interface IEpostaGonderici { void Gonder(string kime, string konu, string mesaj); }
// public class SmtpEpostaGonderici : IEpostaGonderici { public void Gonder(string kime, string konu, string mesaj) { /* ... */ } }
// public interface IUygulamaAyarlari { string GetAyar(string anahtar); }
// public class UygulamaAyarlari : IUygulamaAyarlari { public string GetAyar(string anahtar) { return "deger"; } }


public class UrunlerController : Controller
{
    private readonly IUrunRepository _urunRepository;
    private readonly IEpostaGonderici _epostaGonderici;

    // Bağımlılıklar constructor aracılığıyla enjekte edilir
    public UrunlerController(IUrunRepository urunRepository, IEpostaGonderici epostaGonderici)
    {
        _urunRepository = urunRepository;
        _epostaGonderici = epostaGonderici;
    }

    public IActionResult Index()
    {
        var urunler = _urunRepository.TumunuGetir();
        // _epostaGonderici.Gonder(...); // Diğer bağımlılığı kullan
        return View(urunler);
    }
}
                    </code></pre>
                </details>
            </section>

            <section id="ileri-konular" class="content-section">
                 <h2>İleri C# ve .NET Konuları</h2>
                 <p>Temelleri ve web geliştirmeyi öğrendikten sonra, daha karmaşık problemler çözmek ve daha verimli kod yazmak için bazı ileri konulara hakim olmak faydalıdır.</p>

                 <details class="question-block">
                    <summary><h3>Asenkron Programlama (<code>async</code>, <code>await</code>, <code>Task</code>)</h3></summary>
                    <p>Modern uygulamalarda, özellikle I/O (Input/Output) işlemleri (ağ istekleri, veritabanı erişimi, dosya okuma/yazma) gibi zaman alan operasyonların uygulamanın ana iş parçacığını (thread) bloke etmemesi çok önemlidir. Asenkron programlama, bu tür operasyonların arka planda çalışmasına izin verirken, uygulamanın yanıt vermeye devam etmesini sağlar.</p>
                    <p>C#'ta asenkron programlama <code>async</code> ve <code>await</code> anahtar kelimeleri ile Task Tabanlı Asenkron Desen (Task-based Asynchronous Pattern - TAP) kullanılarak yapılır:</p>
                    <ul>
                        <li><strong><code>async</code>:</strong> Bir metodun asenkron olduğunu ve içinde <code>await</code> kullanılabileceğini belirtir. <code>async</code> metotlar genellikle <code>Task</code>, <code>Task<TResult></code> veya <code>void</code> (olay işleyicileri dışında önerilmez) döndürür.</li>
                        <li><strong><code>await</code>:</strong> Bir <code>Task</code> veya <code>Task<TResult></code> döndüren asenkron bir metodun önüne yazılır. Programın akışını, beklenen işlem tamamlanana kadar <strong>bloke etmeden</strong> duraklatır. İşlem tamamlandığında metot kaldığı yerden devam eder. Eğer beklenen Task bir sonuç döndürüyorsa (<code>Task<TResult></code>), <code>await</code> bu sonucu (<code>TResult</code> tipinde) döndürür.</li>
                        <li><strong><code>Task</code>:</strong> Bir sonuç döndürmeyen asenkron bir işlemi temsil eder.</li>
                        <li><strong><code>Task<TResult></code>:</strong> <code>TResult</code> tipinde bir sonuç döndüren asenkron bir işlemi temsil eder.</li>
                    </ul>
                    <p>EF Core, HttpClient gibi birçok modern .NET kütüphanesi asenkron metotlar (genellikle sonunda 'Async' eki bulunur) sunar.</p>
                     <pre><code class="language-csharp">
using System.Net.Http;
using System.Threading.Tasks; // Task için gerekli

public class AsenkronOrnek
{
    private static readonly HttpClient client = new HttpClient();

    // Task<string> döndüren asenkron metot
    public async Task<string> VeriCekAsync(string url)
    {
        Console.WriteLine($"'{url}' adresinden veri çekiliyor (async)...");
        try
        {
            // await ile ağ isteğinin tamamlanmasını bekle
            HttpResponseMessage response = await client.GetAsync(url);
            response.EnsureSuccessStatusCode(); // Başarısızsa hata fırlatır

            // await ile içeriğin okunmasını bekle
            string responseBody = await response.Content.ReadAsStringAsync();
            Console.WriteLine($"'{url}' adresinden veri çekme tamamlandı.");
            return responseBody;
        }
        catch (HttpRequestException e)
        {
            Console.WriteLine($"\nİstek Hatası: {e.Message}");
            return null;
        }
    }

    // Task döndüren (sonuçsuz) asenkron metot
    public async Task IslemleriBaslatAsync()
    {
        Console.WriteLine("Asenkron işlemler başlıyor...");

        // await ile ilk işlemin tamamlanmasını bekle
        string sonuc1 = await VeriCekAsync("https://jsonplaceholder.typicode.com/todos/1");
        if(sonuc1 != null)
            Console.WriteLine($"Sonuç 1 (ilk 50 karakter): {sonuc1.Substring(0, Math.Min(50, sonuc1.Length))}...");

        // await ile ikinci işlemin tamamlanmasını bekle
        string sonuc2 = await VeriCekAsync("https://jsonplaceholder.typicode.com/posts/1");
         if(sonuc2 != null)
            Console.WriteLine($"Sonuç 2 (ilk 50 karakter): {sonuc2.Substring(0, Math.Min(50, sonuc2.Length))}...");

        // Paralel çalıştırma örneği (Task.WhenAll ile)
        Console.WriteLine("\nİki işlemi paralel başlatma:");
        Task<string> task3 = VeriCekAsync("https://jsonplaceholder.typicode.com/todos/2");
        Task<string> task4 = VeriCekAsync("https://jsonplaceholder.typicode.com/posts/2");

        // İki task'in da tamamlanmasını bekle
        await Task.WhenAll(task3, task4);
        Console.WriteLine("Paralel işlemler tamamlandı.");
        Console.WriteLine($"Sonuç 3: {(task3.Result != null ? "Var" : "Yok")}, Sonuç 4: {(task4.Result != null ? "Var" : "Yok")}");

        Console.WriteLine("Tüm asenkron işlemler bitti.");
    }
}

// Kullanım:
// AsenkronOrnek ornek = new AsenkronOrnek();
// await ornek.IslemleriBaslatAsync(); // Eğer çağıran metot da async ise
// VEYA
// ornek.IslemleriBaslatAsync().Wait(); // Ana thread'i bloke eder (genellikle kaçınılır)
// VEYA
// Task t = ornek.IslemleriBaslatAsync();
// t.GetAwaiter().GetResult(); // Ana thread'i bloke eder
                    </code></pre>
                     <p><code>async/await</code> kullanmak, özellikle UI uygulamalarında arayüzün donmasını ve sunucu uygulamalarında thread kaynaklarının verimli kullanılmasını sağlar.</p>
                 </details>

                 <details class="question-block">
                     <summary><h3>Diğer İleri Konular (Kısa Bahis)</h3></summary>
                     <ul>
                         <li><strong>Threading ve Paralel Programlama:</strong> CPU'yu daha verimli kullanmak için işlemleri birden fazla iş parçacığında (thread) veya paralel olarak çalıştırma teknikleri (<code>System.Threading</code>, Task Parallel Library - TPL).</li>
                         <li><strong>Reflection:</strong> Çalışma zamanında (runtime) kodun yapısını (tipler, metotlar, özellikler vb.) inceleme ve dinamik olarak kod çağırma yeteneği.</li>
                         <li><strong>Attributes (Nitelikler):</strong> Koda meta veriler eklemek için kullanılan bildirimsel etiketler (<code>[Serializable]</code>, <code>[Obsolete]</code>, <code>[Required]</code> gibi). Reflection ile okunabilirler.</li>
                         <li><strong>NuGet Paket Yönetimi:</strong> .NET projelerine üçüncü parti kütüphaneleri (paketleri) kolayca eklemek, güncellemek ve yönetmek için kullanılan sistem.</li>
                         <li><strong>Generics (Genel Türler):</strong> Belirli bir tipe bağlı olmayan, tür güvenli ve yeniden kullanılabilir sınıflar, metotlar ve arayüzler oluşturmayı sağlar (örn: <code>List<T></code>, <code>Dictionary<TKey, TValue></code>).</li>
                         <li><strong>SOLID Prensipleri:</strong> Daha anlaşılır, esnek ve bakımı kolay nesne yönelimli tasarımlar oluşturmak için kullanılan beş temel prensip (Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion).</li>
                         <li><strong>Unit Testing / Integration Testing:</strong> Kodun doğruluğunu otomatik olarak kontrol etmek için testler yazma (xUnit, NUnit, MSTest gibi framework'ler ve Moq, NSubstitute gibi mocking kütüphaneleri ile).</li>
                     </ul>
                 </details>

                 <details class="question-block">
                    <summary><h3>Sonuç: C# ve .NET ile Geliştirme</h3></summary>
                    <p>
                        C# dili ve .NET platformu, modern yazılım geliştirmenin zorluklarına cevap veren güçlü, esnek ve sürekli gelişen bir ekosistem sunar. Tip güvenliği, nesne yönelimli yapısı, zengin kütüphaneleri, çapraz platform desteği ve performans odaklı mimarisi ile çok çeşitli uygulamalar geliştirmek için sağlam bir temel sağlar.
                    </p>
                    <p>
                        Bu rehber, C# ve .NET dünyasına bir giriş yaparak temel kavramları, önemli teknolojileri ve modern yaklaşımları ele almıştır. Ancak bu geniş ekosistemde öğrenilecek her zaman daha fazla şey vardır. ASP.NET Core ile web, .NET MAUI ile mobil, Entity Framework Core ile veri erişimi gibi alanlarda uzmanlaşmak veya LINQ, asenkron programlama gibi dil özelliklerini derinlemesine öğrenmek mümkündür.
                    </p>
                    <p>
                        Microsoft Learn, .NET belgeleri (docs.microsoft.com/dotnet), topluluk blogları ve açık kaynak projeler, öğrenme sürecinde değerli kaynaklardır. Sürekli pratik yapmak, projeler geliştirmek ve yeni özellikleri takip etmek, C# ve .NET geliştiricisi olarak yeteneklerinizi geliştirmenin anahtarıdır. Bu güçlü araçlarla, fikirlerinizi etkili ve ölçeklenebilir yazılım çözümlerine dönüştürebilirsiniz.
                    </p>
                 </details>
            </section>
        </div>
    </main>

    <div class="back-to-top-container">
        <a href="#pageTop" class="back-to-top" aria-label="Sayfanın başına dön">
            <i class="fas fa-chevron-up"></i>
        </a>
   </div>

    <footer id="mainFooter">
        <div class="container">
            <div class="footer-layout">
                <div class="footer-left-links">
                    <h4>Hızlı Bağlantılar</h4>
                    <ul class="footer-nav-links">
                        <li><a href="https://abdulkadirgungor.com/">Ana Sayfa</a></li>
                        <li><a href="https://abdulkadirgungor.com/cv" target="_blank" rel="noopener noreferrer">Özgeçmiş</a></li>
                        <li><a href="https://abdulkadirgungor.com/blog" target="_blank" rel="noopener noreferrer">Blog</a></li>
                    </ul>
                </div>
                <div class="footer-center-content">
                    <h4 class="sitemap-link-heading">
                        <a href="https://abdulkadirgungor.com/sitemap.xml" target="_blank" rel="noopener noreferrer">Sitemap</a>
                    </h4>
                    <p id="footerTextContent">
                        © {YEAR} Abdulkadir Güngör. Tüm Hakları Saklıdır.
                    </p>
                </div>
            </div>
        </div>
    </footer>
    
    <script src="../assets/js/script.js" defer></script>
</body>
</html>
