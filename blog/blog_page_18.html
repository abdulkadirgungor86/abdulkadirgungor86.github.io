<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modern Yazılım Geliştirme Araçları ve Teknolojileri Rehberi</title>
    <meta name="description" content="Modern yazılım geliştirme süreçlerinde kullanılan temel araçlar ve teknolojiler hakkında kapsamlı bir rehber. Git, Docker, Bulut Bilişim (AWS, Azure, GCP), Veritabanları (SQL/NoSQL), API'ler (REST, GraphQL), Test Otomasyonu ve CI/CD konuları detaylı örneklerle açıklanmaktadır. Abdulkadir Güngör tarafından hazırlanmıştır.">
    <meta name="keywords" content="Git, Versiyon Kontrolü, Docker, Konteynerleştirme, Bulut Bilişim, Cloud Computing, AWS, Azure, GCP, Veritabanı, SQL, NoSQL, API, REST, GraphQL, Test Otomasyonu, Unit Test, Integration Test, E2E Test, CI/CD, Sürekli Entegrasyon, Sürekli Dağıtım, Jenkins, GitLab CI, GitHub Actions, Yazılım Geliştirme Araçları, DevOps, Abdulkadir Güngör">
    <meta name="author" content="Abdulkadir Güngör">
    <link rel="canonical" href="https://abdulkadirgungor86.github.io/blog/blog_page_18.html" />
    <link rel="sitemap" type="application/xml" title="Sitemap" href="https://abdulkadirgungor86.github.io/sitemap.xml">
    <link rel="sitemap" type="text/html" title="HTML Sitemap" href="https://abdulkadirgungor86.github.io/sitemap.html">
    <link rel="stylesheet" href="../assets/css/blog_style.css">
</head>
<body>

    <header class="header">
        <nav class="nav-container">
            <div class="logo">Geliştirici Araçları</div>
            <button class="menu-toggle" aria-label="Menüyü Aç/Kapat">☰</button>
            <ul class="nav-menu">
                <li><a href="#giris">Giriş</a></li>
                <li><a href="#git">Git</a></li>
                <li><a href="#docker">Docker</a></li>
                <li><a href="#bulut">Bulut</a></li>
                <li><a href="#veritabani">Veritabanı</a></li>
                <li><a href="#api">API</a></li>
                <li><a href="#test">Test</a></li>
                <li><a href="#ci-cd">CI/CD</a></li>
                <li><a href="#sonuc">Sonuç</a></li>
            </ul>
        </nav>
    </header>

    <div class="container">
        <main>
            <article id="giris" class="content-section intro-section">
                <h1>Modern Yazılım Geliştirme Araçları ve Teknolojileri: Verimlilik ve Kalite</h1>
                <p>
                    Günümüzün hızlı tempolu yazılım geliştirme dünyasında, fikirleri hızla çalışan ürünlere dönüştürmek ve bu ürünleri güvenilir bir şekilde sunmak büyük önem taşımaktadır. Bu süreci başarıyla yönetmek, sadece iyi programlama bilgisine sahip olmayı değil, aynı zamanda modern geliştirme araçlarını ve teknolojilerini etkin bir şekilde kullanmayı da gerektirir. Versiyon kontrol sistemlerinden konteynerleştirmeye, bulut bilişim platformlarından otomatik test ve dağıtım süreçlerine kadar uzanan bu araçlar, geliştiricilerin daha verimli çalışmasını, hataları azaltmasını ve daha kaliteli yazılımlar üretmesini sağlar.
                </p>
                <p>
                    Kodun zaman içindeki değişimini yönetmek ve takım çalışmasını kolaylaştırmak için Git gibi versiyon kontrol sistemleri artık bir standart haline gelmiştir. Uygulamaların farklı ortamlarda tutarlı bir şekilde çalışmasını sağlamak ve dağıtımı basitleştirmek için Docker gibi konteynerleştirme teknolojileri vazgeçilmez olmuştur. Ölçeklenebilirlik, esneklik ve küresel erişim ihtiyaçları için AWS, Azure ve GCP gibi bulut bilişim platformları, altyapı yönetimini kökten değiştirmiştir. Verilerin etkin bir şekilde saklanması ve sorgulanması için doğru veritabanı teknolojisini (SQL veya NoSQL) seçmek kritik önem taşırken, farklı sistemlerin ve servislerin birbiriyle konuşabilmesi için API'ler (özellikle RESTful API'ler ve giderek artan popülaritesiyle GraphQL) temel iletişim kanalları haline gelmiştir.
                </p>
                 <p>
                    Yazılım kalitesini güvence altına almak ve regresyonları önlemek için test otomasyonu (birim, entegrasyon, uçtan uca testler) artık lüks değil, bir zorunluluktur. Tüm bu süreçleri birbirine bağlayan, kod değişikliklerinin otomatik olarak test edilip güvenilir bir şekilde üretim ortamına taşınmasını sağlayan CI/CD (Sürekli Entegrasyon / Sürekli Dağıtım) yaklaşımları ise modern DevOps kültürünün merkezindedir. Bu rehber, günümüz yazılım geliştiricisinin araç kutusunda bulunması gereken bu temel araçları ve teknolojileri (Git, Docker, Bulut, Veritabanları, API'ler, Test Otomasyonu, CI/CD) tanıtacak, ne olduklarını, neden önemli olduklarını ve temel kullanım prensiplerini açıklayarak modern yazılım geliştirme pratiklerine sağlam bir giriş yapmanızı sağlayacaktır.
                </p>
            </article>

            <section id="git" class="content-section">
                <h2>Git ve Versiyon Kontrolü: Kodun Zaman Makinesi</h2>
                <p>
                    Versiyon Kontrol Sistemleri (Version Control Systems - VCS), bir projenin dosyalarında zaman içinde yapılan değişiklikleri izleyen ve yöneten sistemlerdir. Bu, geliştiricilerin kodun farklı sürümlerine geri dönebilmesini, değişiklikleri karşılaştırabilmesini, hataları düzeltebilmesini ve özellikle birden fazla kişinin aynı proje üzerinde çalıştığı durumlarda işbirliğini kolaylaştırmasını sağlar. Günümüzde en yaygın kullanılan dağıtık versiyon kontrol sistemi Git'tir.
                </p>

                <details class="question-block">
                    <summary><h3>Git Nedir ve Neden Önemlidir?</h3></summary>
                    <p>Git, Linus Torvalds tarafından Linux çekirdeğinin geliştirilmesi sırasında ortaya çıkan ihtiyaçlar doğrultusunda yaratılmış, dağıtık yapıda çalışan bir versiyon kontrol sistemidir. "Dağıtık" olması, her geliştiricinin kendi bilgisayarında projenin tam bir kopyasını (repository/depo) ve tüm geçmişini barındırması anlamına gelir. Bu, merkezi sistemlere (örn: SVN) göre daha hızlı çalışma, çevrimdışı çalışma imkanı ve daha esnek iş akışları sağlar.</p>
                    <p><strong>Önemi:</strong></p>
                    <ul>
                        <li><strong>Değişiklik Takibi ve Geçmiş:</strong> Kimin, ne zaman, neyi değiştirdiğini görmeyi sağlar.</li>
                        <li><strong>Geri Alma:</strong> Hatalı değişiklikleri veya istenmeyen sürümleri kolayca geri almayı mümkün kılar.</li>
                        <li><strong>Dallanma (Branching) ve Birleştirme (Merging):</strong> Yeni özellikleri veya hata düzeltmelerini ana kod tabanını (genellikle <code>main</code> veya <code>master</code> dalı) etkilemeden ayrı dallarda geliştirmeyi ve iş bittiğinde bu değişiklikleri ana dala güvenli bir şekilde birleştirmeyi sağlar. Bu, paralel geliştirmeyi ve deneysel çalışmaları kolaylaştırır.</li>
                        <li><strong>İşbirliği:</strong> Birden fazla geliştiricinin aynı proje üzerinde eş zamanlı olarak çalışmasını, değişikliklerini paylaşmasını ve birleştirmesini organize eder. GitHub, GitLab, Bitbucket gibi platformlar Git depolarını barındırarak ve ek işbirliği araçları sunarak bu süreci daha da kolaylaştırır.</li>
                        <li><strong>Kod Güvenliği:</strong> Kodun merkezi olmayan kopyaları sayesinde veri kaybı riski azalır.</li>
                    </ul>
                </details>

                <details class="question-block">
                    <summary><h3>Temel Git Komutları</h3></summary>
                    <p>Git genellikle komut satırından kullanılır (ancak birçok grafiksel arayüz de mevcuttur):</p>
                    <ul>
                        <li><strong><code>git init</code>:</strong> Boş bir Git deposu oluşturur veya mevcut bir projeyi Git deposuna dönüştürür (proje kök dizininde çalıştırılır).</li>
                        <li><strong><code>git clone [url]</code>:</strong> Uzak bir depoyu (örn: GitHub'daki bir proje) yerel bilgisayara kopyalar.</li>
                        <li><strong><code>git status</code>:</strong> Çalışma dizinindeki ve hazırlık alanındaki (staging area) değişikliklerin durumunu gösterir (değiştirilen, eklenen, silinen dosyalar).</li>
                        <li><strong><code>git add [dosya_adı]</code> veya <code>git add .</code>:</strong> Değiştirilen dosyaları bir sonraki commit için hazırlık alanına (staging area) ekler. <code>.</code> ile tüm değişiklikler eklenir.</li>
                        <li><strong><code>git commit -m "Açıklayıcı Mesaj"</code>:</strong> Hazırlık alanındaki değişiklikleri kalıcı olarak yerel depoya kaydeder. Her commit'in anlamlı bir mesajı olmalıdır.</li>
                        <li><strong><code>git log</code>:</strong> Projenin commit geçmişini gösterir (commit ID'leri, yazarlar, tarihler, mesajlar).</li>
                        <li><strong><code>git branch</code>:</strong> Mevcut dalları listeler. <code>git branch [dal_adi]</code> ile yeni bir dal oluşturur.</li>
                        <li><strong><code>git checkout [dal_adi]</code> veya <code>git switch [dal_adi]</code> (yeni):</strong> Belirtilen dala geçiş yapar (çalışma dizinini o dalın durumuyla günceller). <code>-b</code> parametresi ile dalı oluşturup doğrudan geçiş yapabilir: <code>git checkout -b yeni_ozellik</code>.</li>
                        <li><strong><code>git merge [dal_adi]</code>:</strong> Belirtilen daldaki değişiklikleri mevcut (aktif) dala birleştirir. Çakışmalar (conflict) olursa manuel olarak çözülmesi gerekir.</li>
                        <li><strong><code>git pull [uzak_depo] [dal_adi]</code>:</strong> Uzak depodaki (örn: <code>origin</code>) belirtilen daldaki (örn: <code>main</code>) en son değişiklikleri çeker ve mevcut yerel dalla birleştirir (<code>fetch</code> + <code>merge</code> işlemini yapar).</li>
                        <li><strong><code>git push [uzak_depo] [dal_adi]</code>:</strong> Yerel depodaki commit'leri uzak depoya gönderir.</li>
                    </ul>
                     <pre><code class="language-bash">
# Yeni bir proje başlatma
mkdir benim_projem
cd benim_projem
git init
echo "# Benim Projem" &gt; README.md
git add README.md
git commit -m "Initial commit: Proje ve README oluşturuldu"

# Değişiklik yapma
echo "print('Merhaba')" &gt; app.py
git status # app.py untracked olarak görünür
git add app.py
git commit -m "Feat: Merhaba dünya scripti eklendi"

# Yeni özellik dalı oluşturma ve geçme
git checkout -b yeni-ozellik

# Yeni özellikte değişiklik yapma
echo "print('Gelişmiş Merhaba')" &gt; app.py
git add app.py
git commit -m "Feat: Merhaba mesajı geliştirildi"

# Ana dala geri dönme
git checkout main # veya master

# Yeni özelliği ana dala birleştirme
git merge yeni-ozellik

# (Eğer uzak depo varsa) Değişiklikleri gönderme
# git remote add origin &lt;uzak_depo_url&gt; # İlk seferde uzak depo eklenir
# git push -u origin main # İlk push'ta -u kullanılır
git push
                     </code></pre>
                </details>

                 <details class="question-block">
                     <summary><h3>Branch Stratejileri (Gitflow vb.)</h3></summary>
                     <p>Projelerde dallanmayı (branching) organize etmek için farklı stratejiler kullanılır. Bu stratejiler, kodun kararlılığını korumaya, özellikleri izole etmeye ve yayın süreçlerini yönetmeye yardımcı olur.</p>
                     <ul>
                         <li><strong>Gitflow:</strong> Popüler ve kapsamlı bir modeldir. Genellikle şu dalları kullanır:
                            <ul>
                                <li><code>master</code> (veya <code>main</code>): Her zaman üretim ortamını yansıtan kararlı kod. Sadece yayınlardan (release) veya acil düzeltmelerden (hotfix) birleştirilir.</li>
                                <li><code>develop</code>: En son geliştirilen özellikleri içeren entegrasyon dalı. Yeni özellikler tamamlandıkça buraya birleştirilir. Bir sonraki yayının temelini oluşturur.</li>
                                <li><code>feature/*</code>: Yeni özellikler geliştirmek için <code>develop</code> dalından oluşturulan dallar. Tamamlandığında tekrar <code>develop</code>'a birleştirilir.</li>
                                <li><code>release/*</code>: Yeni bir sürümü yayınlamaya hazırlamak için <code>develop</code> dalından oluşturulur. Burada sadece hata düzeltmeleri ve dokümantasyon güncellemeleri yapılır. Yayın hazır olduğunda hem <code>master</code>/<code>main</code> hem de <code>develop</code> ile birleştirilir.</li>
                                <li><code>hotfix/*</code>: Üretimdeki (<code>master</code>/<code>main</code>) acil bir hatayı düzeltmek için doğrudan <code>master</code>/<code>main</code> dalından oluşturulur. Düzeltme yapıldıktan sonra hem <code>master</code>/<code>main</code> hem de <code>develop</code> ile birleştirilir.</li>
                            </ul>
                            Gitflow, yapılandırılmış ve planlı yayın döngüleri olan projeler için uygundur, ancak bazen karmaşık olabilir.
                         </li>
                         <li><strong>GitHub Flow / GitLab Flow:</strong> Daha basit modellerdir. Genellikle tek bir ana dal (<code>main</code>/<code>master</code>) bulunur. Yeni özellikler veya düzeltmeler bu ana daldan oluşturulan kısa ömürlü dallarda geliştirilir. Tamamlandığında, kod incelemesi (code review) ve testlerden sonra Pull Request (veya Merge Request) ile ana dala birleştirilir. CI/CD süreçleriyle iyi entegre olurlar.</li>
                         <li><strong>Trunk-Based Development:</strong> Geliştiricilerin doğrudan veya çok kısa ömürlü dallar üzerinden ana dala (trunk - genellikle <code>main</code>) sık sık küçük değişiklikler yaptığı bir modeldir. Genellikle güçlü CI/CD ve test otomasyonu gerektirir.</li>
                     </ul>
                     <p>Seçilecek strateji, projenin büyüklüğüne, takım yapısına, yayın sıklığına ve CI/CD süreçlerine bağlıdır.</p>
                 </details>

                 <details class="question-block">
                    <summary><h3>Merge vs Rebase</h3></summary>
                    <p>Farklı dallardaki değişiklikleri birleştirmek için iki temel Git komutu vardır:</p>
                    <ul>
                        <li><strong><code>git merge [dal_adi]</code>:</strong> Belirtilen daldaki (örn: <code>feature</code>) tüm commit'leri alır ve mevcut dala (örn: <code>main</code>) uygulayan yeni bir "birleştirme commit'i" (merge commit) oluşturur. Dallanma geçmişini korur, yani hangi commit'in hangi daldan geldiği bellidir. Geçmiş daha karmaşık görünebilir.</li>
                        <li><strong><code>git rebase [dal_adi]</code>:</strong> Mevcut daldaki (örn: <code>feature</code>) commit'leri geçici olarak kenara alır, belirtilen daldaki (örn: <code>main</code>) en son commit'in üzerine geçer, sonra kenara aldığı commit'leri sırayla bu yeni temel üzerine yeniden uygular. Geçmişi daha temiz ve doğrusal hale getirir (sanki tüm işler tek bir dalda yapılmış gibi). Ancak, commit'lerin ID'leri değiştiği için, **uzak depoya push edilmiş (paylaşılmış) dallarda rebase yapmak genellikle önerilmez**, çünkü diğer geliştiricilerin geçmişiyle çakışmalara neden olabilir.</li>
                    </ul>
                    <p>Genel olarak:</p>
                    <ul>
                        <li>Paylaşılmış dalları (<code>main</code>, <code>develop</code>) güncellemek için <code>merge</code> kullanmak daha güvenlidir.</li>
                        <li>Kendi yerel özellik dallarınızı ana dalla senkronize etmek ve temiz bir geçmişle birleştirmeye hazırlamak için <code>rebase</code> kullanılabilir (ana dala birleştirmeden önce).</li>
                    </ul>
                    <p>Hangi yöntemin kullanılacağı takımın tercihine ve iş akışına bağlıdır.</p>
                 </details>
            </section>

            <section id="docker" class="content-section">
                <h2>Docker ve Konteynerleştirme: Uygulamaları Paketlemek ve Dağıtmak</h2>
                <p>
                    Konteynerleştirme, bir uygulamayı ve onun tüm bağımlılıklarını (kütüphaneler, ayarlar, sistem araçları) işletim sistemi seviyesinde sanallaştırarak "konteyner" adı verilen izole birimler içinde paketleme teknolojisidir. Docker, bu teknolojiyi popülerleştiren ve standartlaştıran açık kaynaklı bir platformdur.
                </p>

                 <details class="question-block">
                    <summary><h3>Konteyner Nedir? Sanal Makineden Farkı Nedir?</h3></summary>
                    <ul>
                        <li><strong>Konteyner:</strong> Bir uygulamanın çalışması için gereken her şeyi (kod, runtime, sistem araçları, kütüphaneler, ayarlar) içeren hafif, taşınabilir bir pakettir. Konteynerler, üzerinde çalıştıkları ana makinenin (host) işletim sistemi çekirdeğini paylaşırlar, ancak kendi izole dosya sistemlerine, ağ arayüzlerine ve işlem alanlarına sahiptirler.</li>
                        <li><strong>Sanal Makine (Virtual Machine - VM):</strong> Tam bir işletim sistemini (kendi çekirdeği dahil) donanım üzerinde sanallaştırır. Her VM kendi işletim sistemini çalıştırdığı için konteynerlere göre daha fazla kaynak (disk alanı, bellek, CPU) tüketir ve başlatılması daha uzun sürer. Ancak daha güçlü bir izolasyon sağlarlar.</li>
                    </ul>
                    <p>Konteynerler, VM'lere göre daha hafif, daha hızlı ve daha verimlidir. Aynı donanım üzerinde çok daha fazla sayıda konteyner çalıştırılabilir.</p>
                 </details>

                <details class="question-block">
                    <summary><h3>Neden Docker Kullanılır? Avantajları</h3></summary>
                    <ul>
                        <li><strong>Tutarlılık:</strong> "Benim makinemde çalışıyordu" sorununu çözer. Konteynerler, geliştirme, test ve üretim ortamlarında aynı şekilde çalışır.</li>
                        <li><strong>Taşınabilirlik:</strong> Docker konteynerleri Docker kurulu olan her yerde (Windows, macOS, Linux, bulut) çalıştırılabilir.</li>
                        <li><strong>Hızlı Dağıtım ve Ölçekleme:</strong> Konteynerler saniyeler içinde başlatılabilir, bu da uygulamaları hızla dağıtmayı ve trafik arttığında kolayca ölçeklemeyi sağlar.</li>
                        <li><strong>İzolasyon:</strong> Konteynerler birbirlerinden ve ana makineden izole çalışır. Bir konteynerdeki sorun diğerlerini etkilemez.</li>
                        <li><strong>Kaynak Verimliliği:</strong> VM'lere göre çok daha az kaynak tüketirler.</li>
                        <li><strong>Mikroservis Mimarisi Desteği:</strong> Mikroservisleri ayrı konteynerlerde paketlemek ve yönetmek için idealdir.</li>
                        <li><strong>Geliştirici Verimliliği:</strong> Geliştirme ortamlarını hızla kurmayı ve paylaşmayı kolaylaştırır.</li>
                    </ul>
                </details>

                 <details class="question-block">
                    <summary><h3>Temel Docker Kavramları ve Komutları</h3></summary>
                    <ul>
                        <li><strong>Image (İmaj):</strong> Bir konteyner oluşturmak için kullanılan salt okunur bir şablondur. İşletim sistemi, kütüphaneler, uygulama kodu gibi katmanlardan oluşur. Docker Hub gibi kayıt defterlerinden (registry) indirilebilir veya Dockerfile ile oluşturulabilir.</li>
                        <li><strong>Container (Konteyner):</strong> Bir imajın çalıştırılabilir bir örneğidir (instance).</li>
                        <li><strong>Dockerfile:</strong> Bir Docker imajının nasıl oluşturulacağını adım adım tanımlayan metin tabanlı bir betiktir.</li>
                        <li><strong>Docker Hub / Registry:</strong> Docker imajlarının saklandığı ve paylaşıldığı merkezi veya özel depolardır.</li>
                        <li><strong>Volume (Birim):</strong> Konteyner verilerini kalıcı olarak saklamak veya konteyner ile ana makine arasında dosya paylaşmak için kullanılır. Konteyner silinse bile volume'daki veriler kaybolmaz.</li>
                        <li><strong>Network:</strong> Konteynerlerin birbirleriyle ve dış dünya ile nasıl iletişim kuracağını tanımlar.</li>
                    </ul>
                    <p><strong>Temel Komutlar:</strong></p>
                    <ul>
                        <li><code>docker pull [imaj_adi]:[etiket]</code>: Kayıt defterinden bir imaj indirir (örn: <code>docker pull ubuntu:latest</code>).</li>
                        <li><code>docker images</code>: Yereldeki imajları listeler.</li>
                        <li><code>docker build -t [imaj_adi]:[etiket] .</code>: Mevcut dizindeki Dockerfile'ı kullanarak bir imaj oluşturur (<code>-t</code> ile etiketler).</li>
                        <li><code>docker run [seçenekler] [imaj_adi] [komut]</code>: Bir imajdan yeni bir konteyner başlatır. Yaygın seçenekler:
                            <ul>
                                <li><code>-d</code>: Arka planda (detached mode) çalıştırır.</li>
                                <li><code>-p [host_port]:[konteyner_port]</code>: Port yönlendirme yapar.</li>
                                <li><code>--name [konteyner_adi]</code>: Konteynere isim verir.</li>
                                <li><code>-v [host_yolu]:[konteyner_yolu]</code> veya <code>[volume_adi]:[konteyner_yolu]</code>: Volume bağlar.</li>
                                <li><code>-it</code>: İnteraktif bir terminal oturumu başlatır (<code>docker run -it ubuntu bash</code> gibi).</li>
                            </ul>
                        </li>
                        <li><code>docker ps</code>: Çalışan konteynerleri listeler (<code>-a</code> ile durmuş olanları da gösterir).</li>
                        <li><code>docker stop [konteyner_id_veya_adi]</code>: Çalışan bir konteyneri durdurur.</li>
                        <li><code>docker start [konteyner_id_veya_adi]</code>: Durmuş bir konteyneri başlatır.</li>
                        <li><code>docker rm [konteyner_id_veya_adi]</code>: Durmuş bir konteyneri siler (<code>-f</code> ile çalışan konteyneri zorla siler).</li>
                        <li><code>docker rmi [imaj_id_veya_adi]</code>: Bir imajı siler (bu imajı kullanan konteyner olmamalı).</li>
                        <li><code>docker logs [konteyner_id_veya_adi]</code>: Bir konteynerin loglarını gösterir (<code>-f</code> ile takip eder).</li>
                        <li><code>docker exec -it [konteyner_id_veya_adi] [komut]</code>: Çalışan bir konteyner içinde komut çalıştırır (örn: <code>docker exec -it my_container bash</code>).</li>
                    </ul>
                 </details>

                 <details class="question-block">
                     <summary><h3>Dockerfile Yazımı (Basit Örnek)</h3></summary>
                     <p>Bir Node.js uygulamasını konteynerleştiren basit bir Dockerfile:</p>
                      <pre><code class="language-dockerfile">
# Temel imajı belirt (Node.js'in belirli bir sürümü)
FROM node:18-alpine

# Uygulama kodları için konteyner içinde bir çalışma dizini oluştur
WORKDIR /usr/src/app

# Bağımlılıkları yüklemek için package.json ve package-lock.json dosyalarını kopyala
# (Bu katmanı ayrı tutmak, kod değişmediği sürece bağımlılıkların tekrar yüklenmesini önler)
COPY package*.json ./
RUN npm install
# Eğer üretim ortamıysa sadece üretim bağımlılıklarını yükle:
# RUN npm ci --only=production

# Uygulama kodunu çalışma dizinine kopyala
COPY . .

# Uygulamanın hangi port üzerinden çalışacağını belirt (bilgilendirme amaçlı)
EXPOSE 3000

# Konteyner başlatıldığında çalıştırılacak komut
CMD [ "node", "server.js" ]
                      </code></pre>
                     <p>Bu Dockerfile kullanılarak <code>docker build -t benim-node-appim .</code> komutuyla imaj oluşturulabilir.</p>
                 </details>

                 <details class="question-block">
                    <summary><h3>Docker Compose ile Çoklu Konteyner Yönetimi</h3></summary>
                    <p>Uygulamalar genellikle birden fazla servisten (web sunucusu, veritabanı, önbellek vb.) oluşur ve bu servisler farklı konteynerlerde çalışır. Docker Compose, bu tür çoklu konteyner uygulamalarını tek bir YAML dosyası (<code>docker-compose.yml</code>) ile tanımlamayı, yapılandırmayı ve yönetmeyi sağlayan bir araçtır.</p>
                     <p>Basit bir <code>docker-compose.yml</code> örneği (web uygulaması ve veritabanı):</p>
                     <pre><code class="language-yaml">
version: '3.8' # Compose dosya formatı sürümü

services:
  webapp: # Servis adı (konteyner adı gibi)
    build: . # Mevcut dizindeki Dockerfile'ı kullanarak build et
    ports:
      - "8080:3000" # Host'un 8080 portunu konteynerin 3000 portuna yönlendir
    volumes:
      - .:/usr/src/app # Kod değişikliklerini anında yansıtmak için (geliştirme)
      - /usr/src/app/node_modules # node_modules'ı volume'da tutma (performans)
    environment: # Ortam değişkenleri
      - DATABASE_URL=postgres://user:password@db:5432/mydb
    depends_on: # Başlamadan önce db servisinin hazır olmasını bekle (tam hazır olmayabilir)
      - db

  db: # Veritabanı servisi
    image: postgres:14-alpine # Hazır PostgreSQL imajını kullan
    restart: always # Konteyner durursa otomatik yeniden başlat
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: mydb
    volumes:
      - postgres_data:/var/lib/postgresql/data # Veritabanı verilerini kalıcı tutmak için named volume

volumes: # Named volume tanımı
  postgres_data:

                    </code></pre>
                    <p>Bu dosya ile uygulamayı başlatmak için <code>docker-compose up -d</code>, durdurmak için <code>docker-compose down</code> komutları kullanılır. Docker Compose, geliştirme ve test ortamlarını kurmayı ve yönetmeyi çok kolaylaştırır.</p>
                 </details>
            </section>

             <section id="bulut" class="content-section">
                <h2>Bulut Bilişim (Cloud Computing): İhtiyaç Anında Kaynak</h2>
                <p>
                   Bulut bilişim, bilgi işlem kaynaklarının (sunucular, depolama, veritabanları, ağ, yazılım vb.) internet üzerinden, genellikle kullandıkça öde (pay-as-you-go) modeliyle hizmet olarak sunulmasıdır. Fiziksel sunucular satın almak, kurmak ve yönetmek yerine, ihtiyaç duyulan kaynaklara anında erişim sağlar.
                </p>

                <details class="question-block">
                    <summary><h3>Avantajları</h3></summary>
                    <ul>
                        <li><strong>Ölçeklenebilirlik (Scalability):</strong> İhtiyaç arttığında kaynakları (CPU, RAM, depolama) kolayca artırma (scale up/out) veya azaldığında düşürme (scale down/in) imkanı.</li>
                        <li><strong>Esneklik (Elasticity):</strong> Kaynakları talebe göre otomatik olarak ayarlayabilme.</li>
                        <li><strong>Maliyet Verimliliği:</strong> Başlangıç yatırım maliyeti (CapEx) yerine operasyonel maliyet (OpEx) modeli. Sadece kullanılan kaynaklar için ödeme yapılır.</li>
                        <li><strong>Hız ve Çeviklik:</strong> Yeni sunucuları veya servisleri dakikalar içinde devreye alma imkanı.</li>
                        <li><strong>Küresel Erişim:</strong> Uygulamaları dünyanın farklı coğrafi bölgelerindeki veri merkezlerinde barındırarak kullanıcılara daha yakın ve daha hızlı hizmet sunma.</li>
                        <li><strong>Güvenilirlik ve Dayanıklılık:</strong> Bulut sağlayıcıları genellikle yüksek erişilebilirlik (high availability) ve felaket kurtarma (disaster recovery) çözümleri sunar.</li>
                        <li><strong>Yönetilen Servisler:</strong> Veritabanı yönetimi, yedekleme, güvenlik gibi karmaşık görevleri bulut sağlayıcısına devretme imkanı.</li>
                    </ul>
                </details>

                <details class="question-block">
                    <summary><h3>Ana Bulut Sağlayıcıları (AWS, Azure, GCP)</h3></summary>
                    <p>Pazarın liderleri genellikle "Büyük Üçlü" olarak anılır:</p>
                    <ul>
                        <li><strong>Amazon Web Services (AWS):</strong> En eski ve pazar payı en yüksek olan sağlayıcıdır. Çok geniş bir hizmet yelpazesi sunar.</li>
                        <li><strong>Microsoft Azure:</strong> Microsoft'un bulut platformudur. Özellikle Windows ekosistemi ve kurumsal çözümlerle güçlü entegrasyon sunar, ancak platform bağımsızdır.</li>
                        <li><strong>Google Cloud Platform (GCP):</strong> Google'ın bulut platformudur. Özellikle veri analizi, makine öğrenmesi ve konteyner (Kubernetes) teknolojilerinde güçlüdür.</li>
                    </ul>
                    <p>Bunların dışında IBM Cloud, Oracle Cloud, Alibaba Cloud gibi başka büyük oyuncular da bulunmaktadır.</p>
                </details>

                 <details class="question-block">
                    <summary><h3>Temel Servis Kategorileri</h3></summary>
                    <p>Bulut platformları yüzlerce farklı servis sunsa da, temel kategoriler şunlardır:</p>
                    <ul>
                        <li><strong>Compute (İşlem Gücü):</strong> Sanal makineler (VMs - AWS EC2, Azure VMs, GCP Compute Engine), konteyner orkestrasyonu (Kubernetes - AWS EKS, Azure AKS, GCP GKE), sunucusuz (serverless) işlem (AWS Lambda, Azure Functions, GCP Cloud Functions) gibi işlem gücü sağlayan servisler.</li>
                        <li><strong>Storage (Depolama):</strong>
                            <ul>
                                <li>Nesne Depolama (Object Storage): Ölçeklenebilir, dayanıklı, genellikle statik dosyalar (resim, video, yedekler) için (AWS S3, Azure Blob Storage, GCP Cloud Storage).</li>
                                <li>Blok Depolama (Block Storage): Sanal makinelere takılan diskler (AWS EBS, Azure Managed Disks, GCP Persistent Disks).</li>
                                <li>Dosya Depolama (File Storage): Ağ üzerinden erişilebilen paylaşımlı dosya sistemleri (AWS EFS, Azure Files, GCP Filestore).</li>
                            </ul>
                        </li>
                        <li><strong>Database (Veritabanı):</strong>
                            <ul>
                                <li>İlişkisel Veritabanı Servisleri (Relational - Managed): PostgreSQL, MySQL, SQL Server gibi veritabanlarını yönetilen şekilde sunar (AWS RDS, Azure SQL Database, GCP Cloud SQL).</li>
                                <li>NoSQL Veritabanı Servisleri: Anahtar-değer, belge, sütun ailesi, graf gibi farklı NoSQL modellerini yönetilen şekilde sunar (AWS DynamoDB, Azure Cosmos DB, GCP Firestore/Bigtable).</li>
                                <li>Bellek İçi Önbellek (In-Memory Cache): Redis, Memcached gibi servisler (AWS ElastiCache, Azure Cache for Redis, GCP Memorystore).</li>
                            </ul>
                        </li>
                        <li><strong>Networking (Ağ):</strong> Sanal özel ağlar (VPC/VNet), yük dengeleyiciler (Load Balancers), DNS yönetimi (Route 53, Azure DNS, Cloud DNS), içerik dağıtım ağları (CDN - CloudFront, Azure CDN, Cloud CDN) gibi ağ altyapısı servisleri.</li>
                        <li><strong>Diğerleri:</strong> Güvenlik, kimlik yönetimi, makine öğrenmesi, yapay zeka, IoT, geliştirici araçları, izleme ve loglama gibi birçok farklı alanda servisler bulunur.</li>
                    </ul>
                    <p>Bulut bilişim, modern uygulamaların geliştirilmesi, dağıtılması ve yönetilmesi için temel bir altyapı haline gelmiştir.</p>
                 </details>
            </section>

            <section id="veritabani" class="content-section">
                <h2>Veritabanları: Verinin Kalbi</h2>
                <p>Veritabanları, uygulamaların verilerini yapılandırılmış bir şekilde saklamak, yönetmek ve sorgulamak için kullanılan sistemlerdir. Temel olarak iki ana kategoriye ayrılırlar: SQL (İlişkisel) ve NoSQL (İlişkisel Olmayan).</p>

                <details class="question-block">
                    <summary><h3>SQL vs NoSQL Karşılaştırması</h3></summary>
                     <div class="comparison-table">
                        <table>
                             <thead>
                                <tr>
                                    <th>Özellik</th>
                                    <th>SQL (İlişkisel Veritabanları)</th>
                                    <th>NoSQL (İlişkisel Olmayan Veritabanları)</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Veri Modeli</strong></td>
                                    <td>Tablolar (Satırlar ve Sütunlar), Önceden tanımlanmış şema (Schema)</td>
                                    <td>Çeşitli modeller: Belge (Document - JSON/BSON), Anahtar-Değer (Key-Value), Sütun Ailesi (Column-Family), Graf (Graph). Genellikle şemasız (schemaless) veya dinamik şemalı.</td>
                                </tr>
                                <tr>
                                    <td><strong>Şema</strong></td>
                                    <td>Katı, önceden tanımlı</td>
                                    <td>Esnek, dinamik veya şemasız</td>
                                </tr>
                                <tr>
                                    <td><strong>Sorgulama Dili</strong></td>
                                    <td>SQL (Structured Query Language) - Standartlaşmış</td>
                                    <td>Modele özgü API'ler veya sorgulama dilleri (SQL benzeri diller de olabilir - örn. N1QL, CQL)</td>
                                </tr>
                                 <tr>
                                    <td><strong>Ölçeklenebilirlik</strong></td>
                                    <td>Genellikle Dikey Ölçekleme (Vertical Scaling - daha güçlü sunucu) daha kolaydır. Yatay Ölçekleme (Horizontal Scaling - daha fazla sunucu) daha karmaşıktır (sharding vb.).</td>
                                    <td>Genellikle Yatay Ölçekleme için tasarlanmıştır, büyük veri ve yüksek trafik için daha uygundur.</td>
                                 </tr>
                                 <tr>
                                    <td><strong>Tutarlılık (Consistency)</strong></td>
                                    <td>Genellikle Güçlü Tutarlılık (Strong Consistency - ACID özellikleri vurgulanır: Atomicity, Consistency, Isolation, Durability).</td>
                                    <td>Genellikle Nihai Tutarlılık (Eventual Consistency - BASE özellikleri vurgulanabilir: Basically Available, Soft state, Eventually consistent). Tutarlılık seviyesi ayarlanabilir olabilir.</td>
                                 </tr>
                                 <tr>
                                     <td><strong>İlişkiler</strong></td>
                                     <td>Tablolar arası ilişkiler (foreign keys) güçlü bir şekilde tanımlanır ve yönetilir. JOIN işlemleri yaygındır.</td>
                                     <td>İlişkiler daha az vurgulanır veya farklı şekillerde (gömme - embedding, referanslama) modellenir. Karmaşık JOIN'ler genellikle zordur veya desteklenmez.</td>
                                 </tr>
                                 <tr>
                                     <td><strong>Kullanım Alanları</strong></td>
                                     <td>Yapılandırılmış veriler, ilişkisel bütünlüğün önemli olduğu sistemler (Finans, ERP, CRM), karmaşık sorgular ve raporlama.</td>
                                     <td>Büyük veri (Big Data), gerçek zamanlı uygulamalar, esnek şema gerektiren durumlar, yüksek yazma/okuma trafiği, içerik yönetimi, sosyal medya, IoT.</td>
                                 </tr>
                                 <tr>
                                     <td><strong>Örnekler</strong></td>
                                     <td>PostgreSQL, MySQL, SQL Server, Oracle, SQLite</td>
                                     <td>MongoDB (Belge), Redis (Anahtar-Değer/Cache), Cassandra (Sütun Ailesi), Neo4j (Graf), Couchbase (Belge/Anahtar-Değer)</td>
                                 </tr>
                            </tbody>
                        </table>
                    </div>
                    <p>Seçim, uygulamanın veri yapısına, sorgu ihtiyaçlarına, ölçeklenebilirlik gereksinimlerine ve tutarlılık beklentilerine bağlıdır. Bazen hibrit yaklaşımlar (Polyglot Persistence) da kullanılır.</p>
                </details>

                <details class="question-block">
                    <summary><h3>Örnek Veritabanı: PostgreSQL</h3></summary>
                    <p>PostgreSQL (genellikle "Postgres" olarak kısaltılır), güçlü, açık kaynaklı, nesne-ilişkisel bir veritabanı yönetim sistemidir (ORDBMS). Uzun yıllara dayanan geliştirme geçmişi, standartlara uyumu, geniş özellik seti ve güvenilirliği ile bilinir.</p>
                    <p><strong>Neden PostgreSQL?</strong></p>
                    <ul>
                        <li><strong>Açık Kaynak ve Ücretsiz:</strong> Lisans maliyeti yoktur.</li>
                        <li><strong>Genişletilebilirlik:</strong> Özel veri tipleri, fonksiyonlar, operatörler tanımlamaya izin verir. PostGIS gibi eklentilerle coğrafi veri desteği gibi yetenekler kazanır.</li>
                        <li><strong>Standartlara Uyum:</strong> SQL standartlarına yüksek düzeyde uyumludur.</li>
                        <li><strong>ACID Uyumluluğu:</strong> Güçlü veri bütünlüğü ve işlem (transaction) yönetimi sağlar.</li>
                        <li><strong>Gelişmiş Özellikler:</strong> JSON/JSONB desteği, tam metin arama, pencere fonksiyonları (window functions), CTE (Common Table Expressions), materyalize görünümler (materialized views) gibi birçok gelişmiş özellik sunar.</li>
                        <li><strong>Ölçeklenebilirlik ve Performans:</strong> Yüksek trafikli uygulamalar için replikasyon, bağlantı havuzlama (connection pooling) gibi özelliklerle iyi performans ve ölçeklenebilirlik sunar.</li>
                        <li><strong>Aktif Topluluk:</strong> Geniş ve aktif bir topluluğu vardır.</li>
                    </ul>
                    <p>Web uygulamaları, veri ambarları, coğrafi bilgi sistemleri (GIS) ve genel amaçlı birçok uygulama için popüler ve güçlü bir seçenektir.</p>
                </details>

                 <details class="question-block">
                     <summary><h3>İndeksleme ve Sorgu Optimizasyonu</h3></summary>
                     <ul>
                         <li><strong>İndeksleme (Indexing):</strong> Veritabanı tablolarındaki verilere erişimi hızlandırmak için kullanılan özel veri yapılarıdır. Bir kitaptaki dizin gibi çalışır. Belirli sütunlar (genellikle <code>WHERE</code>, <code>JOIN</code>, <code>ORDER BY</code> koşullarında sıkça kullanılanlar) üzerine indeks oluşturmak, tam tablo taraması (full table scan) yerine indeks üzerinden ilgili satırlara daha hızlı ulaşmayı sağlar.
                            <ul>
                                <li>Yaygın indeks türleri: B-Tree (varsayılan, çoğu sorgu için iyi), Hash, GiST, GIN (PostgreSQL'de özel tipler için).</li>
                                <li>İndeksler sorguları hızlandırırken, yazma (INSERT, UPDATE, DELETE) işlemlerini yavaşlatabilir (çünkü indeksin de güncellenmesi gerekir) ve diskte ek yer kaplarlar. Doğru sütunlara doğru tipte indeks oluşturmak önemlidir.</li>
                            </ul>
                         </li>
                          <li><strong>Sorgu Optimizasyonu:</strong> Veritabanından veri çekmek için yazılan sorguların (SQL) en verimli şekilde çalışmasını sağlama sürecidir.
                            <ul>
                                <li>Veritabanı motoru, bir sorguyu çalıştırmadan önce onu analiz eder ve en iyi yürütme planını (query execution plan) oluşturmaya çalışır.</li>
                                <li><code>EXPLAIN</code> (veya <code>EXPLAIN ANALYZE</code> - PostgreSQL) komutu, veritabanının bir sorguyu nasıl çalıştıracağını veya çalıştırdığını gösterir. Bu planı inceleyerek yavaş çalışan adımlar (örn: full table scan, yavaş join'ler) tespit edilebilir.</li>
                                <li>Optimizasyon teknikleri: Gerekli indeksleri oluşturmak, sorguları yeniden yazmak (daha basit hale getirmek, gereksiz JOIN'lerden kaçınmak), sadece ihtiyaç duyulan sütunları seçmek (<code>SELECT *</code> yerine), veritabanı istatistiklerini güncellemek gibi adımları içerebilir.</li>
                            </ul>
                         </li>
                     </ul>
                     <p>Veritabanı performansı, uygulamanın genel performansı için kritik olduğundan indeksleme ve sorgu optimizasyonu önemli konulardır.</p>
                 </details>
            </section>

             <section id="api" class="content-section">
                <h2>API'ler: Uygulamaların Konuşma Dili</h2>
                <p>API (Application Programming Interface - Uygulama Programlama Arayüzü), farklı yazılım bileşenlerinin veya uygulamaların birbirleriyle nasıl iletişim kuracağını ve etkileşimde bulunacağını tanımlayan bir dizi kural, protokol ve araçtır. Özellikle web tabanlı servisler arasında veri alışverişi için yaygın olarak kullanılırlar.</p>

                <details class="question-block">
                    <summary><h3>RESTful API Nedir? Prensipleri</h3></summary>
                    <p>REST (Representational State Transfer), web servisleri oluşturmak için kullanılan bir mimari stildir. REST prensiplerine uygun olarak tasarlanmış API'lere RESTful API denir. Temel amacı, istemci ve sunucu arasındaki etkileşimi basit, standartlaşmış ve ölçeklenebilir hale getirmektir.</p>
                    <p><strong>Temel Prensipleri (Kısıtlamaları):</strong></p>
                    <ul>
                        <li><strong>İstemci-Sunucu Mimarisi (Client-Server):</strong> İstemci (arayüzden sorumlu) ve sunucu (veri ve mantıktan sorumlu) birbirinden ayrıdır. Bu ayrım, her ikisinin de bağımsız olarak geliştirilmesini sağlar.</li>
                        <li><strong>Durumsuzluk (Statelessness):</strong> Sunucu, istemciden gelen her isteği önceki isteklerden bağımsız olarak anlar ve işler. İstekler arasında istemci durumu (session) sunucuda saklanmaz. Gerekli tüm bilgiler isteğin kendisinde bulunur. Bu, ölçeklenebilirliği ve güvenilirliği artırır.</li>
                        <li><strong>Önbelleklenebilirlik (Cacheability):</strong> Yanıtlar, istemci veya aradaki vekil sunucular tarafından önbelleğe alınabilir olarak işaretlenmelidir. Bu, performansı artırır ve sunucu yükünü azaltır.</li>
                        <li><strong>Katmanlı Sistem (Layered System):</strong> İstemci, doğrudan bağlandığı sunucunun ötesindeki katmanları (yük dengeleyici, proxy, gateway vb.) bilmek zorunda değildir. Mimari katmanlar halinde geliştirilebilir.</li>
                        <li><strong>Tek Tip Arayüz (Uniform Interface):</strong> İstemci ve sunucu arasındaki etkileşimi basitleştiren ve standartlaştıran kısıtlamalar kümesidir:
                            <ul>
                                <li><strong>Kaynakların Tanımlanması (Identification of resources):</strong> Sistemdeki her kaynak (örn: kullanıcı, ürün, sipariş) benzersiz bir URI (Uniform Resource Identifier - genellikle URL) ile tanımlanır (örn: <code>/kullanicilar/123</code>).</li>
                                <li><strong>Temsiller Aracılığıyla Kaynakların Manipülasyonu (Manipulation of resources through representations):</strong> İstemci, bir kaynağın durumunu değiştirmek istediğinde, kaynağın bir temsilini (genellikle JSON veya XML formatında) sunucuya gönderir. Sunucu da yanıt olarak kaynağın güncel temsilini dönebilir.</li>
                                <li><strong>Kendini Tanımlayan Mesajlar (Self-descriptive messages):</strong> Her istek ve yanıt, nasıl işleneceğini anlamak için yeterli bilgiyi içermelidir (örn: HTTP metodu, başlıklar - <code>Content-Type</code>, <code>Accept</code>, yanıt durum kodları).</li>
                                <li><strong>HATEOAS (Hypermedia as the Engine of Application State):</strong> Yanıtlar, istemcinin bir sonraki olası adımları keşfetmesi için ilgili kaynaklara bağlantılar (linkler) içermelidir. Bu, API'nin kendini keşfedilebilir olmasını sağlar (genellikle en az uygulanan kısıtlamadır).</li>
                            </ul>
                        </li>
                        <li><strong>İsteğe Bağlı Kod (Code on Demand - İsteğe Bağlı):</strong> Sunucu, istemcinin işlevselliğini geçici olarak genişletmek için çalıştırılabilir kod (örn: JavaScript) gönderebilir. Bu kısıtlama isteğe bağlıdır.</li>
                    </ul>
                    <p>RESTful API'ler genellikle HTTP protokolü üzerinde çalışır ve standart HTTP metotlarını (GET, POST, PUT, PATCH, DELETE) kaynaklar üzerinde işlem yapmak için kullanır.</p>
                </details>

                <details class="question-block">
                    <summary><h3>RESTful API Tasarımı En İyi Pratikler</h3></summary>
                    <ul>
                        <li><strong>Kaynak Odaklı URI'lar Kullanın:</strong> URI'lar fiiller yerine isimleri (genellikle çoğul) temsil etmelidir (örn: <code>/urunler</code>, <code>/siparisler/5</code> yerine <code>/getUrunler</code>, <code>/deleteSiparis?id=5</code> değil).</li>
                        <li><strong>Doğru HTTP Metotlarını Kullanın:</strong>
                            <ul>
                                <li><code>GET</code>: Kaynakları okumak için (güvenli ve idempotent).</li>
                                <li><code>POST</code>: Yeni bir kaynak oluşturmak için (idempotent değil).</li>
                                <li><code>PUT</code>: Mevcut bir kaynağı tamamen güncellemek veya belirtilen URI'da oluşturmak için (idempotent).</li>
                                <li><code>PATCH</code>: Mevcut bir kaynağı kısmen güncellemek için (idempotent olmayabilir).</li>
                                <li><code>DELETE</code>: Bir kaynağı silmek için (idempotent).</li>
                            </ul>
                        </li>
                        <li><strong>JSON Kullanın:</strong> Veri alışverişi için genellikle JSON formatı tercih edilir (<code>Content-Type: application/json</code>, <code>Accept: application/json</code> başlıkları önemlidir).</li>
                        <li><strong>Uygun HTTP Durum Kodlarını Kullanın:</strong> İsteğin sonucunu belirtmek için standart HTTP durum kodlarını (200 OK, 201 Created, 204 No Content, 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 500 Internal Server Error vb.) doğru şekilde kullanın.</li>
                        <li><strong>Hata Yönetimi:</strong> Hata durumlarında anlaşılır ve tutarlı hata mesajları içeren yanıtlar (genellikle JSON formatında) döndürün.</li>
                        <li><strong>Versiyonlama:</strong> API'de kırıcı değişiklikler (breaking changes) yapıldığında, eski istemcilerin çalışmaya devam edebilmesi için versiyonlama stratejisi kullanın (örn: URL'de <code>/v1/urunler</code>, HTTP başlığında <code>Accept: application/vnd.myapi.v1+json</code>).</li>
                        <li><strong>Filtreleme, Sıralama, Sayfalama:</strong> Büyük veri setlerini yönetmek için istemcilerin sonuçları filtrelemesine (<code>?status=aktif</code>), sıralamasına (<code>?sort=-tarih</code>) ve sayfalamasına (<code>?page=2&amp;limit=20</code>) olanak tanıyan parametreler sunun.</li>
                        <li><strong>Güvenlik:</strong> Kimlik doğrulama (Authentication - örn: API Key, OAuth 2.0, JWT) ve yetkilendirme (Authorization) mekanizmalarını uygulayın. HTTPS kullanın.</li>
                        <li><strong>Dokümantasyon:</strong> API'nin nasıl kullanılacağını açıklayan açık ve güncel bir dokümantasyon sağlayın. Swagger/OpenAPI standartları bunun için yaygın olarak kullanılır ve otomatik olarak interaktif dokümantasyon ve istemci kodu oluşturmayı sağlar.</li>
                    </ul>
                </details>

                <details class="question-block">
                    <summary><h3>GraphQL'e Giriş</h3></summary>
                    <p>GraphQL, Facebook tarafından geliştirilen ve API'ler için bir sorgulama dili ve çalışma zamanıdır. REST'e bir alternatif olarak ortaya çıkmıştır ve istemcilerin ihtiyaç duydukları veriyi tam olarak, tek bir istekte almalarını sağlamayı hedefler.</p>
                    <p><strong>Temel Farklar ve Avantajları:</strong></p>
                    <ul>
                        <li><strong>İstemci Odaklı Veri Talep Etme:</strong> REST'te genellikle birden fazla endpoint'e istek yapmak veya sunucunun tanımladığı sabit veri yapılarını almak gerekirken, GraphQL'de istemci tek bir endpoint'e bağlanır ve ihtiyaç duyduğu alanları (nested yapılar dahil) bir sorgu ile tam olarak belirtir.</li>
                        <li><strong>Over-fetching ve Under-fetching Sorunlarını Çözme:</strong> REST'te bazen ihtiyaç duyulandan fazla veri (over-fetching) veya eksik veri (under-fetching - ek istekler gerekir) alınabilir. GraphQL, istemcinin sadece istediği veriyi almasını sağlayarak bu sorunları çözer.</li>
                        <li><strong>Tek Endpoint:</strong> Genellikle tüm veri işlemleri (okuma - query, yazma/güncelleme - mutation, gerçek zamanlı - subscription) tek bir URL endpoint'i üzerinden yapılır.</li>
                        <li><strong>Güçlü Tip Sistemi:</strong> GraphQL şeması, API'nin veri yapısını ve yeteneklerini güçlü bir tip sistemiyle tanımlar. Bu, API'nin kendini belgelemesini sağlar ve istemci/sunucu tarafında doğrulamayı kolaylaştırır.</li>
                    </ul>
                     <pre><code class="language-graphql">
# Örnek GraphQL Sorgusu (İstemci Tarafı)
query KullaniciVeGonderileriGetir($userId: ID!) {
  kullanici(id: $userId) { # Kullanıcı nesnesini al
    id
    ad
    email
    gonderiler(limit: 5) { # Kullanıcının gönderilerini al (ilişkili veri)
      baslik
      icerik
      yorumlar { # Gönderinin yorumlarını al (iç içe)
        yazan
        metin
      }
    }
  }
}

# Örnek Değişkenler (İstemci Tarafı)
# { "userId": "123" }
                    </code></pre>
                    <p>GraphQL, özellikle karmaşık veri ilişkilerine sahip uygulamalar, mobil istemciler (ağ kullanımını optimize etmek için) ve farklı istemcilerin farklı veri ihtiyaçları olduğu durumlar için güçlü bir alternatiftir. Ancak REST'e göre sunucu tarafında implementasyonu daha karmaşık olabilir ve önbellekleme gibi konularda farklı yaklaşımlar gerektirir.</p>
                </details>
            </section>

             <section id="test" class="content-section">
                <h2>Test Otomasyonu: Kaliteyi Güvence Altına Almak</h2>
                <p>Yazılım test otomasyonu, yazılımın kalitesini doğrulamak, hataları erken tespit etmek ve manuel test yükünü azaltmak için otomatikleştirilmiş testler kullanma sürecidir. Modern yazılım geliştirme yaşam döngüsünün (SDLC) vazgeçilmez bir parçasıdır.</p>

                <details class="question-block">
                    <summary><h3>Test Türleri: Birim, Entegrasyon, Uçtan Uca</h3></summary>
                    <p>Otomatik testler genellikle farklı seviyelerde uygulanır (Test Piramidi konsepti):</p>
                    <ol>
                        <li><strong>Birim Testleri (Unit Tests):</strong> Piramidin en altındadır ve en fazla sayıda olmalıdır. Yazılımın en küçük izole edilebilir birimlerini (genellikle tek bir fonksiyon, metot veya sınıf) test eder. Harici bağımlılıklar (veritabanı, ağ, dosya sistemi) sahte (mock/stub) nesnelerle değiştirilir. Çok hızlı çalışırlar ve geliştiricilere anında geri bildirim sağlarlar. Kodun mantıksal doğruluğunu kontrol ederler.</li>
                        <li><strong>Entegrasyon Testleri (Integration Tests):</strong> Piramidin ortasındadır. Farklı birimlerin veya modüllerin birlikte nasıl çalıştığını test eder. Örneğin, bir servisin veritabanıyla doğru şekilde etkileşim kurup kurmadığını veya farklı API endpoint'lerinin birlikte çalışıp çalışmadığını kontrol edebilir. Genellikle birim testlerinden daha yavaş çalışırlar ve daha karmaşık kurulum gerektirebilirler (örn: test veritabanı).</li>
                        <li><strong>Uçtan Uca Testler (End-to-End / E2E Tests):</strong> Piramidin en üstündedir ve en az sayıda olmalıdır. Tüm uygulamanın baştan sona, gerçek kullanıcı senaryolarını taklit ederek çalışıp çalışmadığını test eder. Kullanıcı arayüzü (UI) etkileşimlerini (tıklama, form doldurma vb.), API çağrılarını ve veritabanı etkileşimlerini içerebilir. En yavaş çalışan ve en kırılgan (flaky) test türüdür, ancak sistemin bir bütün olarak beklendiği gibi çalıştığına dair en yüksek güvenceyi verir.</li>
                    </ol>
                    <p>Bunların dışında API testleri, performans testleri, güvenlik testleri, kullanılabilirlik testleri gibi başka test türleri de bulunur.</p>
                </details>

                <details class="question-block">
                    <summary><h3>Popüler Test Framework'leri ve Araçları</h3></summary>
                    <p>Her programlama dili ve platformu için çeşitli test framework'leri ve araçları mevcuttur:</p>
                    <ul>
                        <li><strong>JavaScript:</strong>
                            <ul>
                                <li>Unit/Integration: Jest, Mocha, Jasmine, Vitest</li>
                                <li>E2E: Cypress, Playwright, Selenium WebDriver</li>
                                <li>Mocking: Jest Mocks, Sinon.JS</li>
                            </ul>
                        </li>
                        <li><strong>Python:</strong>
                             <ul>
                                <li>Unit/Integration: unittest (standart kütüphane), pytest (çok popüler), nose2</li>
                                <li>E2E: Selenium WebDriver, Playwright, Robot Framework</li>
                                <li>Mocking: unittest.mock (standart kütüphane)</li>
                            </ul>
                        </li>
                        <li><strong>C#:</strong>
                             <ul>
                                <li>Unit/Integration: xUnit.net, NUnit, MSTest</li>
                                <li>E2E: Selenium WebDriver, Playwright</li>
                                <li>Mocking: Moq, NSubstitute</li>
                             </ul>
                        </li>
                        <li><strong>Java:</strong>
                             <ul>
                                <li>Unit/Integration: JUnit, TestNG</li>
                                <li>E2E: Selenium WebDriver, Playwright</li>
                                <li>Mocking: Mockito, EasyMock</li>
                             </ul>
                        </li>
                    </ul>
                    <p>Doğru framework seçimi, dil, proje türü ve takımın tercihlerine bağlıdır. Test otomasyonu, yazılım kalitesini sürekli olarak sağlamak ve geliştirme hızını artırmak için kritik bir yatırımdır.</p>
                </details>
            </section>

            <section id="ci-cd" class="content-section">
                 <h2>CI/CD: Otomatikleştirilmiş ve Güvenilir Dağıtım</h2>
                 <p>CI/CD (Continuous Integration / Continuous Delivery or Continuous Deployment - Sürekli Entegrasyon / Sürekli Teslimat veya Sürekli Dağıtım), yazılım geliştirme süreçlerini otomatikleştiren ve hızlandıran modern bir DevOps pratiğidir.</p>

                 <details class="question-block">
                     <summary><h3>Nedir ve Neden Önemlidir?</h3></summary>
                     <ul>
                         <li><strong>Sürekli Entegrasyon (Continuous Integration - CI):</strong> Geliştiricilerin kod değişikliklerini sık sık (genellikle günde birden çok kez) merkezi bir depoya (örn: Git) birleştirmesi pratiğidir. Her birleştirmeden sonra otomatik olarak derleme (build) ve test (unit, integration) süreçleri tetiklenir.
                            <ul>
                                <li><strong>Amacı:</strong> Entegrasyon sorunlarını erken tespit etmek, hataları hızlıca bulmak ve düzeltmek, kod kalitesini sürekli kontrol altında tutmak.</li>
                            </ul>
                         </li>
                         <li><strong>Sürekli Teslimat (Continuous Delivery - CD):</strong> CI'ın bir uzantısıdır. Otomatik derleme ve test süreçlerinden başarıyla geçen kod değişikliklerinin, **manuel bir onay** ile üretim ortamına benzer bir test (staging) veya doğrudan üretim ortamına dağıtıma hazır hale getirilmesi pratiğidir.</li>
                         <li><strong>Sürekli Dağıtım (Continuous Deployment - CD):</strong> Sürekli Teslimat'ın bir sonraki adımıdır. Otomatik derleme ve test süreçlerinden başarıyla geçen her kod değişikliğinin, **herhangi bir manuel müdahale olmadan otomatik olarak** doğrudan üretim ortamına dağıtılmasıdır.</li>
                     </ul>
                     <p><strong>Neden Önemlidir?</strong></p>
                     <ul>
                         <li><strong>Daha Hızlı Geri Bildirim:</strong> Hatalar geliştirme döngüsünün erken aşamalarında tespit edilir.</li>
                         <li><strong>Risk Azaltma:</strong> Küçük değişikliklerin sık sık entegre edilmesi ve test edilmesi, büyük ve riskli dağıtımların önüne geçer.</li>
                         <li><strong>Artan Verimlilik:</strong> Manuel derleme, test ve dağıtım süreçlerini otomatikleştirerek geliştiricilerin kod yazmaya odaklanmasını sağlar.</li>
                         <li><strong>Daha Hızlı Yayın Döngüleri:</strong> Yeni özellikler ve düzeltmeler kullanıcılara daha hızlı ulaştırılır.</li>
                         <li><strong>Daha Güvenilir Dağıtımlar:</strong> Otomatikleştirilmiş ve tekrarlanabilir süreçler manuel hataları azaltır.</li>
                     </ul>
                 </details>

                 <details class="question-block">
                    <summary><h3>Basit Bir CI/CD Pipeline Adımları ve Araçları</h3></summary>
                    <p>Bir CI/CD pipeline (iş akışı), kod değişikliğinin depoya gönderilmesinden dağıtıma kadar olan adımları otomatikleştiren bir süreçtir. Temel adımlar genellikle şunlardır:</p>
                    <ol>
                        <li><strong>Kaynak Kodu Alma (Checkout/Clone):</strong> Kod değişikliği Git deposuna push edildiğinde pipeline tetiklenir ve en son kod CI/CD sunucusuna çekilir.</li>
                        <li><strong>Derleme (Build):</strong> Kaynak kod derlenir, bağımlılıklar yüklenir ve çalıştırılabilir bir uygulama paketi (örn: JAR, DLL, Docker imajı) oluşturulur.</li>
                        <li><strong>Test Etme (Test):</strong> Otomatik testler (önce unit, sonra integration testleri) çalıştırılır. Herhangi bir test başarısız olursa pipeline durdurulur ve geliştiriciye bildirim gönderilir.</li>
                        <li><strong>Dağıtıma Hazırlama (Package/Release - CDelivery için):</strong> Testlerden geçen uygulama paketi, dağıtıma hazır bir "artifact" (ürün) olarak saklanır.</li>
                        <li><strong>Dağıtım (Deploy - CDelivery/CDeployment için):</strong> Onaylanan (CDelivery) veya otomatik olarak (CDeployment) artifact, hedef ortama (test, staging, üretim) dağıtılır.</li>
                        <li><strong>(İsteğe Bağlı) Dağıtım Sonrası Testler:</strong> Uygulamanın hedef ortamda doğru çalıştığını doğrulamak için ek testler (smoke tests, E2E tests) çalıştırılabilir.</li>
                    </ol>
                    <p><strong>Popüler CI/CD Araçları:</strong></p>
                    <ul>
                        <li><strong>Jenkins:</strong> Açık kaynaklı, çok popüler ve esnek, eklentilerle genişletilebilen bir otomasyon sunucusu.</li>
                        <li><strong>GitLab CI/CD:</strong> GitLab platformu ile entegre, YAML tabanlı yapılandırma sunan güçlü bir CI/CD çözümü.</li>
                        <li><strong>GitHub Actions:</strong> GitHub platformu ile entegre, olay tabanlı iş akışları oluşturmayı sağlayan popüler bir CI/CD hizmeti.</li>
                        <li><strong>Azure DevOps Pipelines:</strong> Microsoft Azure platformu ile entegre kapsamlı CI/CD hizmeti.</li>
                        <li><strong>CircleCI, Travis CI, Bamboo:</strong> Diğer popüler bulut tabanlı veya kendi kendine barındırılan CI/CD araçları.</li>
                    </ul>
                    <p>CI/CD, modern yazılım geliştirme ekiplerinin daha hızlı, daha güvenilir ve daha verimli çalışmasını sağlayan temel bir DevOps pratiğidir.</p>
                 </details>
            </section>

            <section id="sonuc" class="content-section">
                 <h2>Sonuç: Modern Geliştiricinin Araç Kutusu</h2>
                 <p>
                    Modern yazılım geliştirme, kod yazmanın ötesinde, süreci verimli bir şekilde yönetmek, kaliteyi güvence altına almak ve değişime hızla adapte olmak için doğru araçları ve teknolojileri kullanmayı gerektirir. Git ile kod geçmişini yönetmek ve işbirliği yapmak, Docker ile uygulamaları tutarlı bir şekilde paketlemek ve dağıtmak, Bulut Bilişim ile ölçeklenebilir ve esnek altyapılar kurmak, doğru Veritabanı teknolojisini seçmek ve optimize etmek, API'ler aracılığıyla sistemler arası iletişimi sağlamak, Test Otomasyonu ile kaliteyi sürekli kılmak ve CI/CD ile tüm bu süreçleri otomatikleştirmek, günümüz geliştiricisinin temel yetkinlikleri arasında yer almaktadır.
                 </p>
                 <p>
                    Bu araçlar ve teknolojiler, tek başlarına güçlü olsalar da, asıl değerleri birbirleriyle entegre bir şekilde kullanıldıklarında ortaya çıkar. Örneğin, Git'e pushlanan bir kod değişikliği otomatik olarak bir CI/CD pipeline'ını tetikleyebilir, bu pipeline kodu test edip bir Docker imajı oluşturabilir ve ardından bu imajı bir Bulut platformundaki Kubernetes kümesine dağıtabilir. Bu tür otomatize edilmiş iş akışları, geliştirme hızını artırırken hata riskini önemli ölçüde azaltır.
                 </p>
                 <p>
                    Bu rehberde ele alınan teknolojiler, modern yazılım geliştirme ekosisteminin sadece bir kısmını temsil etmektedir. Teknoloji sürekli geliştiği için, bu araçları öğrenmek ve güncel kalmak devam eden bir süreçtir. Ancak burada bahsedilen temel kavramları anlamak, hangi aracın hangi probleme çözüm sunduğunu bilmek ve temel kullanım prensiplerine hakim olmak, daha etkili, verimli ve başarılı bir yazılım geliştiricisi olma yolunda size sağlam bir temel sağlayacaktır.
                 </p>
            </section>
        </main>
    </div>

    <footer class="footer">
        <a href="https://abdulkadirgungor86.github.io/cv/" target="_blank" rel="noopener noreferrer">© 2025 Abdulkadir Güngör</a><br/>
        <a href="https://abdulkadirgungor86.github.io/sitemap.xml" target="_blank" rel="noopener noreferrer">Sitemap (XML)</a>
    </footer>
    <script src="../assets/js/blog_script.js"></script>
</body>
</html>