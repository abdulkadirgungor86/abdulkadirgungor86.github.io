<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="siteTitle">.NET Geliştirici Mülakat Soruları ve Yanıtları | Kapsamlı Rehber</title>

    <meta name="description" content="Yazılım Geliştirici, Siber Güvenlik Uzmanı, İnşaat Yüksek Mühendisi ve İSG Uzmanı Abdulkadir Güngör'ün profesyonel portföyü. C#, .NET, mühendislik ve proje yönetimi alanlarındaki yetkinliklerini, bloğunu, yazılarını ve gçrüşlerini keşfedin.">

    <meta name="keywords" content="Abdulkadir, Güngör, Abdulkadir Güngör, Özgeçmiş, CV, Portföy, BilgeAdam Mezunu, Yazılım Geliştirici, Software Developer, İnşaat Yüksek Mühendisi, Civil Engineer M.Sc., İş Sağlığı ve Güvenliği Uzmanı, OHS Specialist, C#, .NET Framework, .NET Core, ASP.NET MVC, ASP.NET Core, JavaScript, TypeScript, HTML5, CSS3, SQL Server, T-SQL, Entity Framework, Entity Framework Core, LINQ, SOLID Prensipleri">

    <meta name="author" content="Abdulkadir Güngör">
    <link rel="canonical" href="https://abdulkadirgungor.com/blog/blog_page_1.html" />

    <link rel="icon" type="image/png" href="../assets/images/icons/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="../assets/images/icons/favicon.svg" />
    <link rel="shortcut icon" href="../assets/images/icons/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="../assets/images/icons/apple-touch-icon.png" />
    <link rel="manifest" href="../assets/images/icons/site.webmanifest" />

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="../assets/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <link rel="sitemap" type="application/xml" title="Sitemap" href="https://abdulkadirgungor.com/sitemap.xml">
    <link rel="sitemap" type="text/html" title="HTML Sitemap" href="https://abdulkadirgungor.com/sitemap.html">
    
    <script type="application/ld+json" id="siteData">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://abdulkadirgungor.com/blog/blog_page_1.html"
  },
  "headline": ".NET Geliştirici Mülakat Soruları ve Yanıtları",
  "description": ".NET ekosistemindeki iş görüşmeleri için kritik öneme sahip teknik bilgi ve becerileri kapsayan bu rehber, C#, ASP.NET, veritabanı ve yazılım prensipleri gibi alanlarda sıkça sorulan sorulara odaklanmaktadır.",
  "author": {
    "@type": "Person",
    "name": "Abdulkadir Güngör",
    "url": "https://abdulkadirgungor.com/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Abdulkadir Güngör",
    "logo": {
      "@type": "ImageObject",
      "url": "https://abdulkadirgungor.com/assets/images/icons/favicon-96x96.png",
      "width": 96,
      "height": 96
    }
  },
  "datePublished": "2025-05-13",
  "dateModified": "2025-05-13",
  "image": "https://abdulkadirgungor.com/assets/images/cv-profile.jpg"
}
    </script>

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-5GFQC3DYZF"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-5GFQC3DYZF');
    </script>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-5L6M34JW');</script>
    
</head>
<body id="pageTop"> 
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5L6M34JW"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    
    <main class="section-padding">
        <div class="container">
            <article class="content-section intro-section">
                <h1>.NET Geliştirici İş Görüşmesi Soruları ve Cevapları</h1>
                <p>
                    .NET ekosisteminde kariyer hedefleyen geliştiriciler için hazırlanan bu kaynak, mülakat süreçlerinde karşılaşabileceğiniz teknik sorulara ve güncel metodolojilere odaklanmaktadır. Amacımız, en son teknolojiler, kütüphaneler ve sıkça sorulan mülakat konuları hakkında sizi bilgilendirerek başarı şansınızı artırmaktır.
                </p>
                <p>
                    Bu rehber, C#, ASP.NET, veritabanı yönetimi, yazılım prensipleri ve front-end teknolojileri gibi temel alanlardaki bilgilerinizi tazelemek ve derinleştirmek için tasarlanmıştır.
                </p>
            </article>

            <section id="csharp" class="content-section">
                <h2>C# Temelleri ve İleri Konular</h2>

                <details class="question-block">
                    <summary><h3>Null Birleştirme Operatörü (<code>??</code>) Nedir?</h3></summary>
                    <p>
                        Null birleştirme operatörü (<code>??</code>), bir değişkenin <code>null</code> olup olmadığını kontrol etmek ve <code>null</code> ise varsayılan bir değer atamak için kısa ve okunaklı bir yol sunar. Geleneksel <code>if</code> kontrolü yerine tek satırda bu işlemi gerçekleştirmemizi sağlar.
                    </p>
                    <pre><code class="language-csharp">
var kullaniciAdi = mevcutKullaniciAdi ?? "Misafir";
// Eğer mevcutKullaniciAdi null ise, kullaniciAdi "Misafir" olarak atanır.
// Değilse, mevcutKullaniciAdi değeri atanır.
                    </code></pre>
                </details>

                <details class="question-block">
                    <summary><h3>C# Dilinde <code>struct</code> ve <code>class</code> Arasındaki Ayırt Edici Özellikler Nelerdir?</h3></summary>
                    <p>
                        En temel fark, <code>class</code>'ların referans türü (reference type), <code>struct</code>'ların ise değer türü (value type) olmasıdır. Bu, bellek yönetimi ve kullanım şekillerini etkiler. <code>class</code>'lar kalıtımı desteklerken, <code>struct</code>'lar desteklemez (ancak interface implemente edebilirler). <code>struct</code>'lar genellikle daha küçük veri yapıları için ve performansın kritik olduğu durumlarda tercih edilirken, <code>class</code>'lar daha karmaşık nesneler ve OOP prensiplerinin tam olarak uygulandığı senaryolar için kullanılır.
                    </p>
                </details>

                <details class="question-block">
                    <summary><h3><code>abstract class</code> ile <code>interface</code> Farklılıkları Nelerdir?</h3></summary>
                    <ul>
                        <li><strong>Kalıtım:</strong> Bir sınıf sadece bir <code>abstract class</code>'tan kalıtım alabilirken, birden fazla <code>interface</code> implemente edebilir.</li>
                        <li><strong>Üye Tanımları:</strong> <code>interface</code>'ler sadece metot imzaları, property'ler, event'ler ve indexer'lar içerirken, <code>abstract class</code>'lar bunlara ek olarak somut (gövdeli) metotlar ve alanlar (fields) içerebilir.</li>
                        <li><strong>Erişim Belirleyiciler:</strong> <code>interface</code> üyeleri varsayılan olarak public'tir ve erişim belirleyici almazlar. <code>abstract class</code> üyeleri farklı erişim belirleyicilere (public, protected, private vb.) sahip olabilir.</li>
                        <li><strong>Amaç:</strong> <code>interface</code>'ler bir "sözleşme" tanımlarken (<code>ne</code> yapılacağını), <code>abstract class</code>'lar genellikle bir temel sınıf ("is-a" ilişkisi) oluşturmak ve ortak davranışları kısmen implemente etmek için kullanılır (<code>nasıl</code> yapılacağının bir kısmı).</li>
                    </ul>
                </details>

                <details class="question-block">
                    <summary><h3><code>virtual</code>, <code>abstract</code>, <code>sealed</code> ve <code>static</code> Anahtar Kelimelerini Açıklayınız.</h3></summary>
                    <ul>
                        <li><strong>virtual:</strong> Türetilmiş sınıfların override edebileceği (ezebileceği) metot veya property'leri işaretler.</li>
                        <li><strong>abstract:</strong> Sadece abstract sınıflar içinde kullanılabilir. İmplemente edilmemiş (gövdesiz) metot veya property'leri tanımlar. Türetilmiş sınıf bu üyeleri implemente etmek zorundadır. Abstract sınıflardan nesne türetilemez.</li>
                        <li><strong>sealed:</strong> Bir sınıfın başka sınıflar tarafından kalıtım alınmasını veya bir metot/property'nin override edilmesini engeller.</li>
                        <li><strong>static:</strong> Bir sınıfın örneğini (instance) oluşturmadan doğrudan sınıf üzerinden erişilebilen üyeleri (metot, property, field) tanımlar. Static sınıflardan nesne türetilemez ve sadece static üyeler içerebilir.</li>
                    </ul>
                </details>

            </section>

            <section id="aspnet" class="content-section">
                <h2>ASP.NET ve Web Teknolojileri</h2>

                <details class="question-block">
                    <summary><h3>ASP.NET Web Forms ve ASP.NET MVC Arasındaki Temel Farklar Nelerdir?</h3></summary>
                    <p>
                        Web Forms, olay güdümlü (event-driven) bir model sunar ve masaüstü uygulama geliştirmeye benzer bir deneyim sağlar (ViewState, Server Controls). MVC (Model-View-Controller) ise sorumlulukların ayrılması (Separation of Concerns) ilkesine dayalı bir mimari desendir. MVC, HTML üzerinde daha fazla kontrol, daha iyi test edilebilirlik ve modern web standartlarına (REST, URL Routing) daha yakın bir yapı sunar. Web Forms daha hızlı başlangıç sağlayabilirken, MVC genellikle daha büyük, sürdürülebilir ve test edilebilir uygulamalar için tercih edilir.
                    </p>
                </details>

                <details class="question-block">
                    <summary><h3>.NET Core Bağımlılık Enjeksiyonunda (DI) Nesne Yaşam Süreleri (Scoped, Transient, Singleton) Nelerdir?</h3></summary>
                    <ul>
                        <li><strong>Transient:</strong> Servis her talep edildiğinde yeni bir örnek (instance) oluşturulur. Hafif, durumsuz (stateless) servisler için uygundur.</li>
                        <li><strong>Scoped:</strong> Her bir web isteği (request) başına tek bir örnek oluşturulur. İstek süresince aynı örnek kullanılır, farklı isteklerde yeni örnekler oluşturulur. Veritabanı context'leri gibi istek bazında durum tutması gereken servisler için idealdir.</li>
                        <li><strong>Singleton:</strong> Uygulama ömrü boyunca sadece tek bir örnek oluşturulur ve her talepte aynı örnek kullanılır. Ayar (configuration) nesneleri, loglama servisleri gibi uygulama genelinde paylaşılması gereken durumlar için kullanılır. Dikkatli kullanılmalıdır, özellikle stateful (durum tutan) ise thread-safety sorunlarına yol açabilir.</li>
                    </ul>
                </details>

                <details class="question-block">
                    <summary><h3>.NET Core'da Tag Helper Kavramı Nedir?</h3></summary>
                    <p>
                        Tag Helper'lar, Razor view'ları içerisinde sunucu taraflı kodları HTML benzeri bir sözdizimi ile yazmayı sağlayan bileşenlerdir. HTML elemanlarına özel attribute'lar ekleyerek veya tamamen yeni özel elemanlar oluşturarak çalışırlar. Geleneksel HTML Helper'lara göre daha doğal ve okunabilir bir HTML çıktısı üretmeyi hedeflerler. Örneğin, <code><a></code> etiketi için <code>asp-controller</code> ve <code>asp-action</code> gibi attribute'lar kullanarak URL oluşturmayı kolaylaştırırlar.
                    </p>
                </details>

            </section>

            <section id="yazilim-genel" class="content-section">
                <h2>Yazılım Geliştirme Genel Prensipleri</h2>

                 <details class="question-block">
                    <summary><h3>SOLID Prensipleri Nelerdir ve Kısaca Açıklayınız.</h3></summary>
                     <ul>
                        <li><strong>S (Single Responsibility Principle - Tek Sorumluluk Prensibi):</strong> Her sınıfın veya modülün sadece tek bir sorumluluğu olmalı, yani değişmek için tek bir nedeni olmalıdır.</li>
                        <li><strong>O (Open/Closed Principle - Açık/Kapalı Prensibi):</strong> Yazılım bileşenleri (sınıflar, modüller) genişletilmeye açık, ancak değiştirilmeye kapalı olmalıdır. Yeni özellikler eklenirken mevcut kodun değiştirilmesi gerekmemelidir.</li>
                        <li><strong>L (Liskov Substitution Principle - Liskov'un Yerine Geçme Prensibi):</strong> Alt sınıflar (türetilmiş sınıflar), üst sınıflarının (temel sınıfların) yerine geçebilmeli ve programın doğruluğunu bozmamalıdır.</li>
                        <li><strong>I (Interface Segregation Principle - Arayüz Ayırma Prensibi):</strong> Sınıflar, kullanmadıkları metotları içeren "şişkin" arayüzleri implemente etmeye zorlanmamalıdır. Bunun yerine daha küçük, amaca özel arayüzler tanımlanmalıdır.</li>
                        <li><strong>D (Dependency Inversion Principle - Bağımlılıkların Tersine Çevrilmesi Prensibi):</strong> Üst seviye modüller, alt seviye modüllere doğrudan bağımlı olmamalıdır. Her ikisi de soyutlamalara (arayüzler veya abstract sınıflar) bağımlı olmalıdır. Detaylar, soyutlamalara bağlı olmalıdır.</li>
                    </ul>
                </details>

                <details class="question-block">
                    <summary><h3>Kütüphane (Library) ve Çatı (Framework) Arasındaki Fark Nedir?</h3></summary>
                    <p>
                        Temel fark kontrolün kimde olduğudur (Inversion of Control - IoC). Bir <strong>kütüphane</strong> kullandığınızda, kodunuz kütüphanenin fonksiyonlarını çağırır; yani kontrol sizdedir. Bir <strong>çatı</strong> kullandığınızda ise, çatı sizin kodunuzu çağırır; yani kontrol çatıdadır. Çatı, uygulamanın genel akışını ve yapısını belirlerken, kütüphane belirli işlevleri yerine getiren yardımcı araçlar sunar. Örneğin, jQuery bir kütüphanedir, ASP.NET Core ise bir çatıdır.
                    </p>
                </details>

                 <details class="question-block">
                    <summary><h3>Deep Copy ve Shallow Copy Arasındaki Fark Nedir?</h3></summary>
                    <p>
                        Bir nesneyi kopyalarken ortaya çıkan iki yöntemdir:
                        <ul>
                            <li><strong>Shallow Copy (Sığ Kopyalama):</strong> Nesnenin sadece en üst seviyedeki alanlarını kopyalar. Eğer alanlar değer türüyse (int, bool vb.), değerleri kopyalanır. Eğer alanlar referans türüyse (başka nesneler, diziler), sadece referanslar (adresler) kopyalanır. Yani, orijinal ve kopya nesne, aynı iç nesnelere işaret eder. Birinde yapılan değişiklik diğerini etkileyebilir.</li>
                            <li><strong>Deep Copy (Derin Kopyalama):</strong> Nesnenin tüm alanlarını ve bu alanların işaret ettiği nesneleri de (ve onların içindekileri de) özyinelemeli (recursive) olarak kopyalar. Orijinal ve kopya tamamen bağımsız hale gelir. Birinde yapılan değişiklik diğerini etkilemez.</li>
                        </ul>
                    </p>
                </details>

            </section>

            <section id="veritabani" class="content-section">
                <h2>Veritabanı Konuları (SQL ve Kavramlar)</h2>

                <details class="question-block">
                    <summary><h3>SQL JOIN Türleri (INNER, LEFT, RIGHT, FULL OUTER) Arasındaki Farklar Nelerdir?</h3></summary>
                    <ul>
                        <li><strong>INNER JOIN:</strong> Her iki tabloda da eşleşen kayıtları getirir. Eşleşme olmayan kayıtlar sonuç kümesine dahil edilmez.</li>
                        <li><strong>LEFT JOIN (veya LEFT OUTER JOIN):</strong> Sol tablodaki tüm kayıtları ve sağ tablodaki eşleşen kayıtları getirir. Sağ tabloda eşleşme yoksa, sağ tabloya ait sütunlar için NULL değerini getirir.</li>
                        <li><strong>RIGHT JOIN (veya RIGHT OUTER JOIN):</strong> Sağ tablodaki tüm kayıtları ve sol tablodaki eşleşen kayıtları getirir. Sol tabloda eşleşme yoksa, sol tabloya ait sütunlar için NULL değerini getirir.</li>
                        <li><strong>FULL OUTER JOIN:</strong> Her iki tablodaki tüm kayıtları getirir. Eşleşme olmayan kayıtlar için ilgili tablonun sütunlarına NULL değeri atanır.</li>
                    </ul>
                </details>

                <details class="question-block">
                    <summary><h3>SQL'de Index Nedir ve Neden Kullanılır?</h3></summary>
                    <p>
                        Index (Dizin), veritabanı tablolarındaki verilere erişimi hızlandırmak için kullanılan özel bir veri yapısıdır. Bir kitaptaki dizin gibi çalışır; belirli bir veriyi bulmak için tüm tabloyu taramak yerine, index üzerinden daha hızlı bir şekilde ilgili satırın konumuna ulaşmayı sağlar. Özellikle <code>WHERE</code> ve <code>JOIN</code> koşullarında kullanılan sütunlara index eklemek, sorgu performansını önemli ölçüde artırabilir. Ancak, index'ler diskte ek yer kaplar ve <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code> işlemlerini yavaşlatabilirler çünkü her veri değişikliğinde index'in de güncellenmesi gerekir.
                    </p>
                </details>

                <details class="question-block">
                    <summary><h3>Clustered Index ve Non-Clustered Index Farkları Nelerdir?</h3></summary>
                     <ul>
                        <li><strong>Clustered Index (Kümelenmiş Dizin):</strong> Tablodaki verilerin fiziksel olarak diskte nasıl sıralanacağını belirler. Bir tabloda sadece bir tane clustered index olabilir (genellikle Primary Key üzerinde otomatik oluşur). Veriler, index'in anahtarına göre sıralı tutulduğu için aralık sorgularında (range queries) çok etkilidir.</li>
                        <li><strong>Non-Clustered Index (Kümelenmemiş Dizin):</strong> Verilerin fiziksel sırasını değiştirmez. Index, anahtar değerlerini ve bu değerlere karşılık gelen satırların konumlarını (row locator) içeren ayrı bir yapıdır. Bir tabloda birden fazla non-clustered index olabilir. Belirli bir kaydı bulmak için etkilidir, ancak verilerin kendisi index'te olmadığı için ek bir okuma adımı (lookup) gerektirebilir.</li>
                    </ul>
                </details>

            </section>

            <section id="frontend" class="content-section">
                <h2>Front End Teknolojileri ve Kavramlar</h2>

                 <details class="question-block">
                    <summary><h3>Single-Page Application (SPA) Nedir?</h3></summary>
                    <p>
                       SPA, kullanıcının etkileşimiyle tüm sayfanın yeniden yüklenmesi yerine, sadece değişen içerik bölümlerinin dinamik olarak güncellendiği modern bir web uygulaması mimarisidir. İlk yüklemede gerekli HTML, CSS ve JavaScript kodları tarayıcıya indirilir. Sonraki gezinmelerde genellikle sadece veriler (JSON formatında) sunucudan alınır ve sayfa yapısı JavaScript ile istemci tarafında (client-side) oluşturulur. Bu, daha akıcı ve masaüstü uygulamasına benzer bir kullanıcı deneyimi sağlar. Angular, React, Vue.js popüler SPA çatılarındandır.
                    </p>
                </details>

                 <details class="question-block">
                    <summary><h3>Authentication ve Authorization Arasındaki Fark Nedir?</h3></summary>
                    <ul>
                        <li><strong>Authentication (Kimlik Doğrulama):</strong> Bir kullanıcının kim olduğunu doğrulama işlemidir. Genellikle kullanıcı adı/şifre, token, biyometrik veri gibi yöntemlerle yapılır. Sisteme "kimsin?" sorusunun cevabıdır.</li>
                        <li><strong>Authorization (Yetkilendirme):</strong> Kimliği doğrulanmış bir kullanıcının hangi kaynaklara erişebileceğini veya hangi işlemleri yapabileceğini belirleme işlemidir. Sisteme "ne yapabilirsin?" sorusunun cevabıdır. Roller (admin, user) veya izinler (okuma, yazma) üzerinden yönetilir.</li>
                    </ul>
                     <p>Önce Authentication yapılır, sonra Authorization kontrol edilir.</p>
                </details>

                 <details class="question-block">
                    <summary><h3>REST ve SOAP Servisleri Arasındaki Temel Farklılıklar Nelerdir?</h3></summary>
                    <ul>
                        <li><strong>Protokol:</strong> SOAP genellikle sadece HTTP/HTTPS üzerinden çalışır (ancak diğer protokolleri de destekleyebilir), REST ise çoğunlukla HTTP/HTTPS kullanır ancak protokolden bağımsız bir mimari stildir.</li>
                        <li><strong>Veri Formatı:</strong> SOAP genellikle sadece XML formatını kullanır ve katı bir mesajlaşma yapısına (Envelope, Header, Body) sahiptir. REST ise daha esnektir; JSON, XML, YAML, hatta düz metin gibi farklı formatları destekleyebilir. JSON en yaygın kullanılanıdır.</li>
                        <li><strong>Mimari Yaklaşım:</strong> SOAP bir protokoldür, REST ise bir mimari stildir. REST, HTTP metotlarını (GET, POST, PUT, DELETE vb.) kaynaklar üzerinde işlem yapmak için kullanır ve durumsuz (stateless) olmayı hedefler.</li>
                        <li><strong>Performans ve Esneklik:</strong> REST genellikle daha hafif, daha hızlı ve daha esnek kabul edilir. SOAP ise daha standartlaşmış, güvenlik (WS-Security) ve işlem (transaction) yönetimi gibi konularda daha yerleşik özellikler sunabilir.</li>
                    </ul>
                </details>
            </section>
        </div>
    </main>

    <div class="back-to-top-container">
        <a href="#pageTop" class="back-to-top" aria-label="Sayfanın başına dön">
            <i class="fas fa-chevron-up"></i>
        </a>
   </div>

    <footer id="mainFooter">
        <div class="container">
            <div class="footer-layout">
                <div class="footer-left-links">
                    <h4>Hızlı Bağlantılar</h4>
                    <ul class="footer-nav-links">
                        <li><a href="https://abdulkadirgungor.com/">Ana Sayfa</a></li>
                        <li><a href="https://abdulkadirgungor.com/cv" target="_blank" rel="noopener noreferrer">Özgeçmiş</a></li>
                        <li><a href="https://abdulkadirgungor.com/blog" target="_blank" rel="noopener noreferrer">Blog</a></li>
                    </ul>
                </div>
                <div class="footer-center-content">
                    <h4 class="sitemap-link-heading">
                        <a href="https://abdulkadirgungor.com/sitemap.xml" target="_blank" rel="noopener noreferrer">Sitemap</a>
                    </h4>
                    <p id="footerTextContent">
                        © {YEAR} Abdulkadir Güngör. Tüm Hakları Saklıdır.
                    </p>
                </div>
            </div>
        </div>
    </footer>
    
    <script src="../assets/js/script.js" defer></script>
</body>
</html>
