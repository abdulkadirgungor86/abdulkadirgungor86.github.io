<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="siteTitle">Yazılım Geliştirmenin Temel Taşları: Prensipler, Desenler ve Kavramlar</title>
    <meta name="description" content="Yazılım geliştirmenin temel prensiplerini (SOLID, Temiz Kod, DRY, KISS, YAGNI), tasarım desenlerini, veri yapıları/algoritmaları, OOP vs FP farklarını ve asenkron programlamayı öğrenmek için kapsamlı bir rehber. C#, Python, Java ve JavaScript örnekleriyle daha kaliteli yazılımlar geliştirin. Abdulkadir Güngör tarafından hazırlanmıştır.">
    <meta name="keywords" content="Yazılım Geliştirme, Programlama, SOLID, Temiz Kod, Clean Code, Tasarım Desenleri, Design Patterns, Veri Yapıları, Algoritmalar, OOP, FP, Fonksiyonel Programlama, Nesne Yönelimli Programlama, Asenkron Programlama, async, await, Yazılım Prensipleri, Yazılım Mimarisi, C#, Python, Java, JavaScript, Abdulkadir Güngör">
    <meta name="author" content="Abdulkadir Güngör">
    <link rel="canonical" href="https://abdulkadirgungor86.github.io/blog/blog_page_16.html" />

    <link rel="icon" type="image/png" href="../assets/images/icons/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="../assets/images/icons/favicon.svg" />
    <link rel="shortcut icon" href="../assets/images/icons/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="../assets/images/icons/apple-touch-icon.png" />
    <link rel="manifest" href="../assets/images/icons/site.webmanifest" />

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="../assets/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <link rel="sitemap" type="application/xml" title="Sitemap" href="https://abdulkadirgungor86.github.io/sitemap.xml">
    <link rel="sitemap" type="text/html" title="HTML Sitemap" href="https://abdulkadirgungor86.github.io/sitemap.html">
    
    <script type="application/ld+json" id="siteData">
    {
      "@context": "https://schema.org",
      "@type": "Article", 
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://abdulkadirgungor86.github.io/blog/blog_page_16.html"
      },
      "headline": "Yazılım Geliştirmenin Temel Taşları: Prensipler, Desenler ve Kavramlar",
      "name": "Yazılım Geliştirmenin Temel Taşları | Abdulkadir Güngör", 
      "author": {
        "@type": "Person",
        "name": "Abdulkadir Güngör"
      },
      "publisher": {
        "@type": "Organization",
        "name": "Abdulkadir Güngör",
        "logo": {
          "@type": "ImageObject",
          "url": "https://abdulkadirgungor86.github.io/assets/images/icons/favicon-96x96.png" 
        }
      },
      "datePublished": "2025-05-13", 
      "dateModified": "2025-05-13", 
      "description": "Yazılım geliştirmenin temel prensiplerini (SOLID, Temiz Kod), tasarım desenlerini, veri yapıları/algoritmaları, OOP vs FP ve asenkron programlamayı öğrenin.",
      "isPartOf": {
        "@type": "WebSite",
        "@id": "https://abdulkadirgungor86.github.io/"
      },
      "footerText": "© {YEAR} Abdulkadir Güngör. Tüm Hakları Saklıdır." 
    }
    </script>

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-5GFQC3DYZF"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-5GFQC3DYZF');
    </script>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-5L6M34JW');</script>
    
</head>
<body id="pageTop"> 
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5L6M34JW"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    
    <main class="section-padding">
        <div class="container">
            <article id="giris" class="content-section intro-section">
                <h1>Yazılım Geliştirmenin Temel Taşları: Prensipler, Desenler ve Paradigmalar</h1>
                <p>
                    Başarılı bir yazılım ürünü ortaya koymak, sadece kodun çalışmasını sağlamaktan çok daha fazlasıdır. Yazılımın zaman içinde sürdürülebilir olması, değişen gereksinimlere kolayca adapte olabilmesi, yeni özelliklerin rahatça eklenebilmesi ve birden fazla geliştirici tarafından anlaşılıp yönetilebilmesi gerekir. İşte bu noktada, yazılım geliştirmenin temelini oluşturan prensipler, tasarım desenleri ve farklı programlama paradigmaları devreye girer. Bu kavramlar, geliştiricilere daha kaliteli, esnek ve dayanıklı kodlar yazmaları için yol gösterir.
                </p>
                <p>
                    SOLID prensipleri gibi köklü tasarım ilkeleri, nesne yönelimli programlamanın gücünü doğru kullanmak için bir çerçeve sunarken, "Temiz Kod" felsefesi yazdığımız kodun sadece makineler tarafından değil, insanlar (başta gelecekteki kendimiz ve takım arkadaşlarımız) tarafından da kolayca okunabilir ve anlaşılabilir olmasını vurgular. Tasarım Desenleri (Design Patterns), sıkça karşılaşılan problemlere kanıtlanmış, yeniden kullanılabilir çözümler sunarak tekerleği yeniden icat etmemizi önler. Veri yapıları ve algoritmalar hakkındaki temel bilgi ise yazdığımız kodun verimliliğini ve performansını doğrudan etkiler.
                </p>
                 <p>
                    Ayrıca, farklı programlama paradigmalarını (örneğin Nesne Yönelimli Programlama ve Fonksiyonel Programlama) anlamak, probleme en uygun yaklaşımı seçmemize olanak tanır. Modern uygulamaların kaçınılmaz bir gerekliliği olan asenkron programlama yeteneği ise, kullanıcı deneyimini iyileştirmek ve kaynakları verimli kullanmak için kritik öneme sahiptir. Bu rehber, yazılım geliştirmenin bu temel taşlarını - SOLID prensipleri, temiz kod anlayışı, temel tasarım desenleri, veri yapıları/algoritmalar, OOP/FP karşılaştırması ve asenkron programlama - ele alarak, daha bilinçli ve etkili bir yazılım geliştiricisi olma yolculuğunuzda size kapsamlı bir bakış açısı sunmayı hedeflemektedir.
                </p>
            </article>

            <section id="solid" class="content-section">
                <h2>SOLID Prensipleri: Sağlam Temeller Üzerine İnşa Etmek</h2>
                <p>
                    Robert C. Martin tarafından popülerleştirilen SOLID, daha anlaşılır, esnek ve bakımı kolay nesne yönelimli tasarımlar oluşturmak için beş temel prensibin baş harflerinden oluşan bir akronimdir.
                </p>

                <details class="question-block">
                    <summary><h3>S: Single Responsibility Principle (Tek Sorumluluk Prensibi)</h3></summary>
                    <p><strong>Bir sınıfın değişmek için sadece tek bir nedeni olmalıdır.</strong> Yani, bir sınıf yalnızca tek bir sorumluluğa odaklanmalıdır.</p>
                    <p><strong>Neden Önemli?</strong> Yüksek uyum (cohesion), düşük bağlılık (coupling), anlaşılabilirlik, test edilebilirlik ve bakım kolaylığı sağlar. Değişikliklerin etkisini sınırlar.</p>
                    <p><strong>Örnek İhlal:</strong> Hem kullanıcı veritabanı işlemlerini hem de kullanıcı arayüzü güncellemelerini yapan bir sınıf.</p>
                    <p><strong>Çözüm:</strong> Veritabanı işlemlerini ayrı bir <code>KullaniciRepository</code> sınıfına, arayüz güncellemelerini ayrı bir <code>KullaniciViewModel</code> veya UI sınıfına taşımak.</p>
                    <pre><code class="language-csharp">
// SRP Uygulanmış (Konsept)
public class KullaniciRepository { /* Veritabanı işlemleri */ }
public class KullaniciArayuz { /* Arayüz güncelleme */ }
public class KullaniciYonetici
{
    private KullaniciRepository _repo = new KullaniciRepository();
    private KullaniciArayuz _ui = new KullaniciArayuz();
    // Kullanıcı yönetimi mantığı burada, diğer sorumlulukları delege eder
}
                    </code></pre>
                </details>

                <details class="question-block">
                    <summary><h3>O: Open/Closed Principle (Açık/Kapalı Prensibi)</h3></summary>
                    <p><strong>Yazılım varlıkları genişletilmeye açık, ancak değiştirilmeye kapalı olmalıdır.</strong> Yeni özellikler eklemek için mevcut kodu değiştirmek yerine, yeni kod ekleyerek sistemi genişletebilmeliyiz.</p>
                    <p><strong>Neden Önemli?</strong> Değişiklik riskini azaltır, esneklik ve genişletilebilirlik sağlar, sistemin kararlılığını artırır.</p>
                    <p><strong>Nasıl Uygulanır?</strong> Soyutlama (arayüzler, soyut sınıflar) ve polimorfizm ile. Strateji, Şablon Metot gibi tasarım desenleri yardımcı olur.</p>
                    <p><strong>Örnek:</strong> Farklı rapor türleri (PDF, Excel, CSV) oluşturma. Yeni bir rapor türü (örn. XML) eklenmesi gerektiğinde mevcut raporlama sınıfını değiştirmek yerine, yeni bir <code>XmlRaporOlusturucu</code> sınıfı ekleyip ortak bir <code>IRaporOlusturucu</code> arayüzünü implemente etmek.</p>
                     <pre><code class="language-csharp">
public interface IRaporOlusturucu { void Olustur(object veri); }
public class PdfRaporOlusturucu : IRaporOlusturucu { /*...*/ }
public class ExcelRaporOlusturucu : IRaporOlusturucu { /*...*/ }
// Yeni XML raporu için:
public class XmlRaporOlusturucu : IRaporOlusturucu { /*...*/ }

public class RaporlamaServisi
{
    public void RaporYarat(IRaporOlusturucu olusturucu, object data)
    {
        olusturucu.Olustur(data); // Mevcut kod değişmez
    }
}
                    </code></pre>
                </details>

                <details class="question-block">
                    <summary><h3>L: Liskov Substitution Principle (Liskov Yerine Geçme Prensibi)</h3></summary>
                    <p><strong>Alt tipler (subtypes), üst tiplerinin (base types) yerine, programın doğruluğunu bozmadan geçebilmelidir.</strong> Alt sınıflar, üst sınıfın beklenen davranışını ve sözleşmesini korumalıdır.</p>
                    <p><strong>Neden Önemli?</strong> Kalıtımın doğru kullanılmasını sağlar, polimorfizmin güvenilirliğini artırır, sistem tutarlılığını korur.</p>
                    <p><strong>İhlal Örneği:</strong> Klasik Kare/Dikdörtgen problemi. Kare, dikdörtgenin yerine geçtiğinde genişlik/yükseklik ayarlama beklentisini bozar.</p>
                    <p><strong>Çözüm:</strong> Kalıtım hiyerarşisini gözden geçirmek, alt sınıfların üst sınıf sözleşmesine uymasını sağlamak.</p>
                </details>

                <details class="question-block">
                    <summary><h3>I: Interface Segregation Principle (Arayüz Ayırma Prensibi)</h3></summary>
                    <p><strong>İstemciler, kullanmadıkları metotları içeren arayüzleri uygulamaya zorlanmamalıdır.</strong> Büyük, "şişman" arayüzler yerine küçük, role özgü arayüzler tercih edilmelidir.</p>
                    <p><strong>Neden Önemli?</strong> Gereksiz bağımlılıkları azaltır, uyumu (cohesion) artırır, gereksiz implementasyonları önler, esnekliği artırır.</p>
                    <p><strong>Örnek:</strong> Tek bir <code>IMakine</code> arayüzü yerine <code>IYazdirici</code>, <code>ITarayici</code>, <code>IFaksGonderici</code> gibi ayrı arayüzler tanımlamak. Bir sınıf sadece ihtiyaç duyduğu arayüzleri uygular.</p>
                     <pre><code class="language-csharp">
// ISP Uygulanmış (Konsept)
public interface IYazdirici { void Yazdir(string s); }
public interface ITarayici { void Tara(string s); }

public class BasitYazici : IYazdirici { /* ... */ }
public class GelismisMakine : IYazdirici, ITarayici { /* ... */ }
// BasitYazici, kullanmadığı Tara metodunu implemente etmek zorunda kalmaz.
                    </code></pre>
                </details>

                <details class="question-block">
                    <summary><h3>D: Dependency Inversion Principle (Bağımlılıkların Tersine Çevrilmesi Prensibi)</h3></summary>
                    <p><strong>1. Üst seviye modüller, alt seviye modüllere doğrudan bağımlı olmamalıdır. Her ikisi de soyutlamalara bağımlı olmalıdır. 2. Soyutlamalar detaylara bağımlı olmamalıdır. Detaylar soyutlamalara bağımlı olmalıdır.</strong> Kısaca, somut implementasyonlara değil, soyut arayüzlere bağımlı olunmalıdır.</p>
                    <p><strong>Neden Önemli?</strong> Gevşek bağlılık (loose coupling) sağlar, esneklik ve değiştirilebilirlik kazandırır, test edilebilirliği artırır.</p>
                    <p><strong>Nasıl Uygulanır?</strong> Arayüzler/Soyut Sınıflar ve Bağımlılık Enjeksiyonu (Dependency Injection - DI) ile.</p>
                     <pre><code class="language-csharp">
// DIP Uygulanmış (Konsept)
public interface IVeritabani { void Kaydet(object data); } // Soyutlama
public class SqlVeritabani : IVeritabani { /* ... */ } // Detay
public class OracleVeritabani : IVeritabani { /* ... */ } // Başka bir detay

public class IsMantigi // Üst Seviye Modül
{
    private readonly IVeritabani _db; // Soyutlamaya bağımlı
    public IsMantigi(IVeritabani db) { _db = db; } // DI ile bağımlılık alınır

    public void Calistir(object veri) { _db.Kaydet(veri); }
}

// Kullanım (Composition Root):
// IVeritabani sql = new SqlVeritabani();
// IsMantigi mantik = new IsMantigi(sql); // Bağımlılık dışarıdan verilir
// mantik.Calistir("...");
                    </code></pre>
                </details>
            </section>

            <section id="temiz-kod" class="content-section">
                <h2>Temiz Kod (Clean Code): Okunabilir ve Anlaşılır Yazmak</h2>
                <p>
                    Robert C. Martin'in "Clean Code" kitabıyla popülerleşen bu felsefe, kodun sadece çalışmasını değil, aynı zamanda insanlar tarafından kolayca okunabilir, anlaşılabilir ve değiştirilebilir olmasını hedefler. Temiz kod, uzun vadede bakım maliyetlerini düşürür, hataları azaltır ve takım çalışmasını kolaylaştırır.
                </p>
                 <details class="question-block">
                     <summary><h3>Anlamlı İsimlendirme</h3></summary>
                     <p>Değişkenler, fonksiyonlar, sınıflar ve diğer öğeler için <strong>açıklayıcı ve niyetini belli eden</strong> isimler kullanılmalıdır.</p>
                     <ul>
                         <li>Kısaltmalardan veya belirsiz isimlerden (<code>a</code>, <code>b</code>, <code>x</code>, <code>data</code>, <code>temp</code> gibi) kaçının.</li>
                         <li>İsim, değişkenin/fonksiyonun neyi temsil ettiğini veya ne iş yaptığını anlatmalıdır (örn: <code>gecenSure</code> yerine <code>gecenSureMilisaniye</code>, <code>listeyiAl</code> yerine <code>aktifKullanicilariGetir</code>).</li>
                         <li>Tutarlı bir isimlendirme standardı kullanın (örn: Python için snake_case, C# için PascalCase/camelCase).</li>
                         <li>Boolean değişkenler için <code>isAktif</code>, <code>hasError</code> gibi isimler tercih edilebilir.</li>
                     </ul>
                 </details>
                 <details class="question-block">
                    <summary><h3>Kısa Fonksiyonlar/Metotlar</h3></summary>
                    <p>Fonksiyonlar ve metotlar mümkün olduğunca <strong>kısa olmalı ve tek bir iş yapmalıdır</strong> (SRP'nin fonksiyon seviyesindeki yansıması). </p>
                    <ul>
                        <li>Bir fonksiyon çok uzuyorsa veya birden fazla iş yapıyorsa, onu daha küçük, odaklı fonksiyonlara ayırmayı düşünün.</li>
                        <li>İdeal olarak bir fonksiyon bir ekrana sığmalıdır.</li>
                        <li>İç içe geçmiş kontrol yapılarının (if, for, while) derinliğini azaltmaya çalışın.</li>
                    </ul>
                 </details>
                  <details class="question-block">
                    <summary><h3>Yorum Satırları</h3></summary>
                    <p>Yorumlar kodu açıklamak için değil, kodun <strong>neden</strong> o şekilde yazıldığını veya karmaşık bir iş mantığını açıklamak için kullanılmalıdır. Kodun kendisi <strong>ne</strong> yaptığını anlatmalıdır.</p>
                    <ul>
                        <li>Açıklayıcı olmayan veya güncelliğini yitirmiş yorumlardan kaçının.</li>
                        <li>Kodu açıklamak yerine, kodu daha okunabilir hale getirmeye çalışın (iyi isimlendirme, kısa fonksiyonlar).</li>
                        <li>Yasal uyarılar, TODO notları veya karmaşık algoritmaların özeti gibi durumlar için yorumlar faydalı olabilir.</li>
                        <li>Fonksiyon/sınıf/modül belgeleri için docstring (Python) veya XML yorumları (C#) kullanın.</li>
                    </ul>
                     <pre><code class="language-python">
# Kötü Yorum
# i'yi 1 artır
i = i + 1

# İyi Yorum (Nedenini Açıklıyor)
# Veritabanı bağlantı havuzundaki zaman aşımını önlemek için
# periyodik olarak dummy bir sorgu gönderiyoruz.
check_db_connection()
                     </code></pre>
                  </details>
                  <details class="question-block">
                    <summary><h3>Kod Formatlama ve Tutarlılık</h3></summary>
                    <p>Tutarlı bir kod formatı (girintileme, boşluk kullanımı, satır uzunluğu vb.) kodun okunabilirliğini önemli ölçüde artırır.</p>
                    <ul>
                        <li>Proje genelinde veya takım içinde ortak bir stil rehberi (PEP 8 gibi) belirleyin ve buna uyun.</li>
                        <li>Otomatik kod formatlayıcıları (Prettier, Black, Yapf) kullanarak tutarlılığı sağlayın.</li>
                    </ul>
                  </details>
                  <details class="question-block">
                    <summary><h3>Hata Yönetimi</h3></summary>
                    <p>Hataları görmezden gelmeyin. Olası hataları öngörün ve <code>try...except</code> (Python) veya <code>try...catch</code> (C#) blokları ile uygun şekilde yönetin. Hata mesajlarının bilgilendirici olmasına özen gösterin.</p>
                  </details>
            </section>

            <section id="desenler" class="content-section">
                <h2>Tasarım Desenleri (Design Patterns): Kanıtlanmış Çözümler</h2>
                <p>Tasarım desenleri, yazılım tasarımında sıkça karşılaşılan belirli problemlere yönelik genel, yeniden kullanılabilir çözümlerdir. Tekerleği yeniden icat etmek yerine, daha önce denenmiş ve etkinliği kanıtlanmış çözümlerden yararlanmayı sağlarlar. Gang of Four (GoF) tarafından tanımlanan 23 desen en bilinenleridir ve genellikle üç kategoride incelenir: Yaratımsal, Yapısal ve Davranışsal.</p>

                <details class="question-block">
                    <summary><h3>Yaratımsal Desenler (Creational Patterns)</h3></summary>
                    <p>Nesne oluşturma mekanizmalarını soyutlayarak, sistemin hangi nesnelerin nasıl oluşturulduğundan bağımsız hale gelmesini sağlarlar.</p>
                    <ul>
                        <li><strong>Singleton (Tek Nesne):</strong> Bir sınıftan sadece tek bir nesne (instance) oluşturulmasını garanti eder ve bu nesneye global bir erişim noktası sağlar. Örnekler: Loglama servisi, konfigürasyon yöneticisi, veritabanı bağlantı havuzu. Dikkatli kullanılmalıdır, global durum ve test zorluğu yaratabilir.
                            <pre><code class="language-python">
# Singleton Örneği (Basit - Thread safe değil)
class SingletonLogger:
    _instance = None
    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super(SingletonLogger, cls).__new__(cls, *args, **kwargs)
            print("Logger instance oluşturuldu.")
        return cls._instance
    def log(self, message): print(f"LOG: {message}")

# logger1 = SingletonLogger() # Logger instance oluşturuldu.
# logger2 = SingletonLogger() # Tekrar oluşturulmaz
# logger1.log("Mesaj 1")
# print(logger1 is logger2) # True
                            </code></pre>
                        </li>
                        <li><strong>Factory Method (Fabrika Metodu):</strong> Nesne oluşturma işini alt sınıflara delege eden bir metot tanımlar. Hangi sınıfın nesnesinin oluşturulacağına alt sınıflar karar verir. Üst sınıf sadece nesne oluşturma arayüzünü bilir.</li>
                        <li><strong>Abstract Factory (Soyut Fabrika):</strong> Birbiriyle ilişkili veya bağımlı nesne ailelerini, somut sınıflarını belirtmeden oluşturmak için bir arayüz sağlar.</li>
                    </ul>
                </details>

                <details class="question-block">
                    <summary><h3>Yapısal Desenler (Structural Patterns)</h3></summary>
                    <p>Sınıfların ve nesnelerin daha büyük yapılar oluşturmak üzere nasıl birleştirileceğiyle ilgilenirler. Kalıtım ve kompozisyon kullanarak esnek ve verimli yapılar kurmaya odaklanırlar.</p>
                     <ul>
                        <li><strong>Adapter (Adaptör):</strong> Uyumsuz arayüzlere sahip sınıfların birlikte çalışmasını sağlar. Bir sınıfın arayüzünü, istemcinin beklediği başka bir arayüze dönüştürür.</li>
                        <li><strong>Decorator (Dekoratör):</strong> Bir nesneye, alt sınıflama yapmadan dinamik olarak yeni sorumluluklar (davranışlar) eklemeyi sağlar. Nesneyi bir veya daha fazla sarmalayıcı (decorator) nesne ile sarmalar. Örnek: Stream sınıfları (FileInputStream'i BufferedInputStream ile sarmalamak).
                            <pre><code class="language-python">
# Decorator Konsepti (Python Decorator'ları ile değil, OOP Decorator deseni)
class Kahve:
    def maliyet(self): return 5
    def aciklama(self): return "Sade Kahve"

class SutDekorator:
    def __init__(self, kahve_bileseni): self._kahve = kahve_bileseni
    def maliyet(self): return self._kahve.maliyet() + 2
    def aciklama(self): return self._kahve.aciklama() + ", Sütlü"

class SekerDekorator:
    def __init__(self, kahve_bileseni): self._kahve = kahve_bileseni
    def maliyet(self): return self._kahve.maliyet() + 1
    def aciklama(self): return self._kahve.aciklama() + ", Şekerli"

# kahvem = Kahve()
# print(f"{kahvem.aciklama()} - {kahvem.maliyet()} TL") # Sade Kahve - 5 TL
# sutlu_kahvem = SutDekorator(kahvem)
# print(f"{sutlu_kahvem.aciklama()} - {sutlu_kahvem.maliyet()} TL") # Sade Kahve, Sütlü - 7 TL
# sutlu_sekerli = SekerDekorator(sutlu_kahvem)
# print(f"{sutlu_sekerli.aciklama()} - {sutlu_sekerli.maliyet()} TL") # Sade Kahve, Sütlü, Şekerli - 8 TL
                            </code></pre>
                        </li>
                         <li><strong>Facade (Cephe):</strong> Karmaşık bir alt sistem için basitleştirilmiş tek bir arayüz sağlar. İstemcinin alt sistemin karmaşıklığıyla uğraşmasını engeller.</li>
                         <li><strong>Proxy (Vekil):</strong> Başka bir nesneye erişimi kontrol etmek için bir vekil veya yer tutucu nesne sağlar. Erişim kontrolü, tembel başlatma (lazy initialization), loglama gibi amaçlarla kullanılabilir.</li>
                     </ul>
                </details>

                <details class="question-block">
                     <summary><h3>Davranışsal Desenler (Behavioral Patterns)</h3></summary>
                     <p>Nesneler arasındaki etkileşim algoritmaları ve sorumluluk dağılımı ile ilgilenirler. Nesnelerin nasıl işbirliği yapacağını ve iletişim kuracağını tanımlarlar.</p>
                     <ul>
                        <li><strong>Observer (Gözlemci):</strong> Bir nesnede (Subject/Publisher) bir değişiklik olduğunda, ona bağımlı olan diğer nesnelerin (Observers/Subscribers) otomatik olarak bilgilendirilmesini ve güncellenmesini sağlayan bir mekanizma tanımlar. Olay tabanlı sistemlerde sıkça kullanılır.</li>
                        <li><strong>Strategy (Strateji):</strong> Bir algoritma ailesi tanımlar, her birini ayrı bir sınıfta kapsüller ve onları birbirinin yerine kullanılabilir hale getirir. Algoritmanın istemciden bağımsız olarak değiştirilmesini sağlar. OCP'yi uygulamak için iyi bir yoldur.
                             <pre><code class="language-python">
# Strategy Deseni Konsepti
from abc import ABC, abstractmethod

# Strategy Arayüzü
class ISiralamaStratejisi(ABC):
    @abstractmethod
    def sirala(self, veri): pass

# Somut Stratejiler
class HizliSiralama(ISiralamaStratejisi):
    def sirala(self, veri): print("Hızlı sıralama kullanılıyor..."); return sorted(veri)
class BaloncukSiralama(ISiralamaStratejisi):
    def sirala(self, veri): print("Baloncuk sıralama kullanılıyor..."); return sorted(veri, reverse=True) # Basit örnek

# Context Sınıfı
class VeriSiralayici:
    def __init__(self, strateji: ISiralamaStratejisi):
        self._strateji = strateji
    def set_strateji(self, strateji: ISiralamaStratejisi):
        self._strateji = strateji
    def sirala_ve_goster(self, veri):
        sirali_veri = self._strateji.sirala(veri)
        print(f"Sıralı Veri: {sirali_veri}")

# Kullanım
# data = [5, 1, 8, 3]
# hizli = HizliSiralama()
# baloncuk = BaloncukSiralama()
# siralayici = VeriSiralayici(hizli) # Başlangıç stratejisi
# siralayici.sirala_ve_goster(data)
# siralayici.set_strateji(baloncuk) # Çalışma zamanında strateji değiştirme
# siralayici.sirala_ve_goster(data)
                             </code></pre>
                        </li>
                        <li><strong>Command (Komut):</strong> Bir isteği, isteğin tüm bilgilerini içeren bağımsız bir nesne olarak kapsüller. Bu sayede istekleri parametrelendirebilir, kuyruğa alabilir, loglayabilir ve geri alma (undo) işlemleri uygulayabilirsiniz.</li>
                        <li><strong>Template Method (Şablon Metot):</strong> Bir algoritmanın iskeletini bir üst sınıfta tanımlar, ancak bazı adımların implementasyonunu alt sınıflara bırakır. Algoritmanın genel yapısını değiştirmeden belirli adımların yeniden tanımlanmasını sağlar.</li>
                     </ul>
                     <p>Tasarım desenleri, tecrübeli geliştiricilerin ortak bir dil konuşmasını sağlar ve karmaşık sorunlara zarif çözümler sunar.</p>
                </details>
            </section>

             <section id="veri-algo" class="content-section">
                <h2>Veri Yapıları ve Algoritmalar: Verimli Kodun Temeli</h2>
                <p>Veri yapıları, verileri bellekte verimli bir şekilde organize etme ve saklama yöntemleridir. Algoritmalar ise belirli bir problemi çözmek için adım adım izlenen prosedürlerdir. Doğru veri yapısını ve algoritmayı seçmek, yazılımın performansı (hız ve bellek kullanımı) üzerinde büyük etki yaratır.</p>

                <details class="question-block">
                    <summary><h3>Temel Veri Yapıları</h3></summary>
                    <ul>
                        <li><strong>Diziler (Arrays):</strong> Sabit boyutlu, aynı türden elemanları ardışıl bellek bölgelerinde tutar. Index ile hızlı erişim (O(1)) sağlar, ancak ekleme/silme (özellikle ortadan) yavaş olabilir (O(n)).</li>
                        <li><strong>Listeler (Lists - Python Lists, C# List<T>, Java ArrayList):</strong> Dinamik boyutlu dizilerdir. Eleman ekleme/silme dizilere göre daha esnektir, ancak bazen arka planda yeniden boyutlandırma maliyeti olabilir. Erişimi genellikle hızlıdır (ortalama O(1)).</li>
                        <li><strong>Bağlı Listeler (Linked Lists):</strong> Elemanların (düğümlerin) birbirine referanslarla bağlandığı yapılardır. Ekleme/silme (özellikle başa/sona veya belirli bir düğümden sonra) hızlıdır (O(1)), ancak belirli bir elemana erişim yavaştır (O(n)).</li>
                        <li><strong>Yığınlar (Stacks):</strong> LIFO (Last-In, First-Out) prensibiyle çalışır (<code>push</code> ile eklenir, <code>pop</code> ile çıkarılır). Fonksiyon çağrıları, geri alma işlemleri gibi senaryolarda kullanılır.</li>
                        <li><strong>Kuyruklar (Queues):</strong> FIFO (First-In, First-Out) prensibiyle çalışır (<code>enqueue</code> ile eklenir, <code>dequeue</code> ile çıkarılır). Görev sıralama, BFS algoritması gibi yerlerde kullanılır.</li>
                        <li><strong>Sözlükler / Hash Map'ler / Hash Tabloları (Dictionaries - Python dict, C# Dictionary<K,V>, Java HashMap):</strong> Anahtar-değer çiftlerini saklar. Anahtarlar kullanılarak değerlere çok hızlı erişim (ortalama O(1)) sağlar. Veri arama, önbelleğe alma için idealdir.</li>
                        <li><strong>Kümeler (Sets - Python set, C# HashSet<T>, Java HashSet):</strong> Benzersiz elemanları sırasız olarak tutar. Eleman varlığını kontrol etme (<code>in</code> / <code>Contains</code>) çok hızlıdır (ortalama O(1)).</li>
                        <li><strong>Ağaçlar (Trees):</strong> Hiyerarşik veri yapılarıdır (örn: İkili Arama Ağaçları - Binary Search Trees, AVL Ağaçları). Verimli arama, ekleme, silme (genellikle O(log n)) ve sıralı veri tutma için kullanılır. Dosya sistemleri, veritabanı indeksleri gibi yerlerde kullanılır.</li>
                        <li><strong>Graflar (Graphs):</strong> Düğümler (vertices) ve aralarındaki bağlantılardan (edges) oluşan yapılardır. Sosyal ağlar, harita uygulamaları, ağ topolojileri gibi ilişkisel verileri modellemek için kullanılır.</li>
                    </ul>
                </details>

                 <details class="question-block">
                     <summary><h3>Temel Algoritmalar ve Big O Notasyonu</h3></summary>
                     <ul>
                         <li><strong>Algoritma:</strong> Belirli bir problemi çözmek için tanımlanmış, sıralı adımlar kümesidir.</li>
                         <li><strong>Arama Algoritmaları:</strong>
                            <ul>
                                <li>Doğrusal Arama (Linear Search): Sırasız bir listede elemanı baştan sona arar (O(n)).</li>
                                <li>İkili Arama (Binary Search): Sıralı bir listede ortadaki elemana bakarak arama uzayını sürekli yarıya indirir (O(log n)). Çok daha verimlidir.</li>
                            </ul>
                         </li>
                         <li><strong>Sıralama Algoritmaları:</strong>
                            <ul>
                                <li>Baloncuk Sıralama (Bubble Sort), Seçmeli Sıralama (Selection Sort), Eklemeli Sıralama (Insertion Sort): Basit ama genellikle yavaştır (O(n²)). Küçük veri setleri için kullanılabilir.</li>
                                <li>Birleştirmeli Sıralama (Merge Sort), Hızlı Sıralama (Quick Sort): Daha karmaşık ama çok daha verimlidir (ortalama O(n log n)).</li>
                            </ul>
                         </li>
                         <li><strong>Big O Notasyonu:</strong> Bir algoritmanın girdi boyutu (n) büyüdükçe çalışma süresinin veya bellek kullanımının nasıl arttığını (büyüme oranını) ifade eden matematiksel bir gösterimdir. Algoritmaların verimliliğini karşılaştırmak için kullanılır.
                            <ul>
                                <li>O(1): Sabit zaman (girdi boyutundan bağımsız).</li>
                                <li>O(log n): Logaritmik zaman (çok verimli, girdi boyutu arttıkça süre çok az artar - örn. Binary Search).</li>
                                <li>O(n): Doğrusal zaman (girdi boyutuyla orantılı artar - örn. Linear Search).</li>
                                <li>O(n log n): Log-doğrusal zaman (verimli sıralama algoritmaları).</li>
                                <li>O(n²): Karesel zaman (iç içe döngülerde sık görülür, büyük n için yavaşlar).</li>
                                <li>O(2ⁿ): Üstel zaman (çok verimsiz, genellikle kaçınılması gerekir).</li>
                            </ul>
                         </li>
                     </ul>
                     <p>Doğru veri yapısını ve algoritmayı seçmek, özellikle büyük veri setleriyle çalışırken uygulamanın performansını önemli ölçüde etkiler.</p>
                 </details>
            </section>

             <section id="oop-fp" class="content-section">
                <h2>OOP vs Fonksiyonel Programlama (FP): Farklı Bakış Açıları</h2>
                <p>Nesne Yönelimli Programlama (OOP) ve Fonksiyonel Programlama (FP), problemleri çözmek için farklı yaklaşımlar sunan iki temel programlama paradigmasıdır.</p>

                <details class="question-block">
                    <summary><h3>Temel Farklılıklar</h3></summary>
                    <div class="comparison-table">
                        <table>
                            <thead>
                                <tr>
                                    <th>Özellik</th>
                                    <th>Nesne Yönelimli Programlama (OOP)</th>
                                    <th>Fonksiyonel Programlama (FP)</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Odak Noktası</strong></td>
                                    <td>Nesneler (veri ve davranışı bir arada tutan)</td>
                                    <td>Fonksiyonlar (saf, birinci sınıf, yüksek mertebeden)</td>
                                </tr>
                                <tr>
                                    <td><strong>Durum Yönetimi (State)</strong></td>
                                    <td>Nesnelerin içinde değiştirilebilir durum (mutable state) tutulur.</td>
                                    <td>Değiştirilemezlik (immutability) ve durumsuz (stateless) fonksiyonlar vurgulanır. Yan etkilerden (side effects) kaçınılır.</td>
                                </tr>
                                <tr>
                                    <td><strong>Ana Kavramlar</strong></td>
                                    <td>Sınıf, Nesne, Kalıtım, Kapsülleme, Polimorfizm</td>
                                    <td>Saf Fonksiyonlar (Pure Functions), Değişmezlik (Immutability), Birinci Sınıf Fonksiyonlar (First-class Functions), Yüksek Mertebeden Fonksiyonlar (Higher-order Functions), Rekürsiyon (Recursion)</td>
                                </tr>
                                 <tr>
                                    <td><strong>Veri Akışı</strong></td>
                                    <td>Nesneler birbirine mesaj gönderir, metotlar çağrılır, nesnelerin durumu değişir.</td>
                                    <td>Veri genellikle fonksiyonlardan fonksiyonlara akar, dönüşüm (transformation) vurgulanır.</td>
                                 </tr>
                                 <tr>
                                     <td><strong>Paralellik</strong></td>
                                     <td>Paylaşılan değiştirilebilir durum nedeniyle thread güvenliği zor olabilir, senkronizasyon mekanizmaları gerektirir.</td>
                                     <td>Saf fonksiyonlar ve değişmezlik sayesinde paralellik ve eşzamanlılık yönetimi genellikle daha kolaydır.</td>
                                 </tr>
                                 <tr>
                                     <td><strong>Yaygın Diller</strong></td>
                                     <td>Java, C#, C++, Python, Ruby (OOP destekli)</td>
                                     <td>Haskell, Clojure, F#, Scala, Lisp (FP odaklı), JavaScript, Python, C# (FP özellikleri destekli)</td>
                                 </tr>
                            </tbody>
                        </table>
                    </div>
                </details>

                 <details class="question-block">
                    <summary><h3>Avantajlar ve Dezavantajlar</h3></summary>
                    <p><strong>OOP Avantajları:</strong></p>
                    <ul>
                        <li>Gerçek dünya problemlerini modellemek için sezgisel olabilir.</li>
                        <li>Kapsülleme ile veri gizliliği ve modülerlik sağlar.</li>
                        <li>Kalıtım ile kod yeniden kullanımı sağlar (dikkatli kullanılmalı).</li>
                        <li>Büyük, karmaşık sistemleri organize etmek için iyi yapılar sunar.</li>
                    </ul>
                    <p><strong>OOP Dezavantajları:</strong></p>
                    <ul>
                        <li>Değiştirilebilir durum yönetimi karmaşıklaşabilir ve hatalara yol açabilir.</li>
                        <li>Kalıtım hiyerarşileri sıkı bağlılık yaratabilir.</li>
                        <li>Paralel programlama zor olabilir.</li>
                        <li>Çok fazla "boilerplate" kod gerektirebilir.</li>
                    </ul>
                     <p><strong>FP Avantajları:</strong></p>
                     <ul>
                         <li>Kod daha öngörülebilir ve test edilebilirdir (saf fonksiyonlar sayesinde).</li>
                         <li>Paralellik ve eşzamanlılık yönetimi daha kolaydır.</li>
                         <li>Daha az yan etki (side effect) olduğu için hata ayıklama kolaylaşabilir.</li>
                         <li>Kod genellikle daha kısa ve öz olabilir (yüksek mertebeden fonksiyonlar sayesinde).</li>
                     </ul>
                     <p><strong>FP Dezavantajları:</strong></p>
                     <ul>
                         <li>Bazı geliştiriciler için başlangıçta öğrenme eğrisi daha dik olabilir (rekürsiyon, monad gibi kavramlar).</li>
                         <li>Durumun yoğun olarak değiştiği bazı problemler (örn. UI durumu) için modelleme daha az sezgisel olabilir.</li>
                         <li>Performans (sürekli yeni veri yapıları oluşturma nedeniyle) bazı durumlarda optimize edilmelidir.</li>
                     </ul>
                 </details>

                 <details class="question-block">
                    <summary><h3>Ne Zaman Hangisi? Hibrit Yaklaşımlar</h3></summary>
                    <p>Günümüzde birçok modern dil (Python, C#, JavaScript, Scala vb.) hem OOP hem de FP özelliklerini destekler. Geliştiriciler genellikle her iki paradigmanın güçlü yanlarını birleştiren <strong>hibrit yaklaşımları</strong> benimserler.</p>
                    <ul>
                        <li>Karmaşık durumları ve varlıkları modellemek için OOP yapıları (sınıflar) kullanılabilir.</li>
                        <li>Veri dönüşümleri, işlemler ve yan etkisiz hesaplamalar için FP teknikleri (saf fonksiyonlar, map/filter/reduce) tercih edilebilir.</li>
                        <li>Değişmez veri yapıları (immutability) kullanmak, hem OOP hem de FP tarzı kodlarda hataları azaltabilir.</li>
                    </ul>
                    <p>Problemin doğasına, takımın tecrübesine ve kullanılan dilin/ekosistemin yeteneklerine göre en uygun yaklaşım veya yaklaşım kombinasyonu seçilmelidir. Kesin sınırlar çizmek yerine, her iki paradigmanın sunduğu araçları bilmek ve duruma göre en uygun olanı kullanmak önemlidir.</p>
                 </details>
            </section>

            <section id="asenkron" class="content-section">
                <h2>Asenkron Programlama: Beklemeye Son!</h2>
                <p>Modern uygulamalar sıklıkla zaman alan işlemlerle uğraşır: ağ üzerinden veri istemek, veritabanına yazmak, dosyaları okumak vb. Eğer bu işlemler eş zamanlı (senkron) yapılırsa, işlemin bitmesini beklerken uygulamanın geri kalanı donar ve yanıt veremez hale gelir. Asenkron programlama, bu tür "bekleten" işlemlerin arka planda yürütülmesine izin verirken, uygulamanın diğer görevlere devam etmesini sağlayarak performansı ve kullanıcı deneyimini iyileştirir.</p>

                 <details class="question-block">
                    <summary><h3>Neden Asenkron Programlama?</h3></summary>
                    <ul>
                        <li><strong>Yanıt Verebilirlik (Responsiveness):</strong> Özellikle kullanıcı arayüzü (UI) olan uygulamalarda (web, masaüstü, mobil), uzun süren bir işlem UI iş parçacığını bloke ederse arayüz donar. Asenkron işlemler UI'ın akıcı kalmasını sağlar.</li>
                        <li><strong>Verimlilik (Efficiency):</strong> Sunucu tarafı uygulamalarda, bir istek bir I/O işlemini beklerken, o iş parçacığı (thread) başka bir isteği işlemek için serbest bırakılabilir. Bu, daha az thread ile daha fazla isteği karşılamayı sağlar ve kaynak kullanımını optimize eder.</li>
                        <li><strong>Ölçeklenebilirlik (Scalability):</strong> Kaynakları daha verimli kullanan uygulamalar daha kolay ölçeklenebilir.</li>
                    </ul>
                 </details>

                 <details class="question-block">
                    <summary><h3>Temel Mekanizmalar: Callback, Promise, Async/Await</h3></summary>
                    <p>Asenkron işlemleri yönetmek için farklı dillerde benzer mekanizmalar kullanılır:</p>
                    <ul>
                        <li><strong>Callback Fonksiyonları:</strong> Asenkron işlem bittiğinde çağrılacak bir fonksiyonu işlem başlatan fonksiyona parametre olarak geçme yöntemidir. Basit durumlar için işe yarar ancak iç içe geçmiş işlemler "Callback Hell" sorununa yol açabilir. (JavaScript'te yaygındı).</li>
                        <li><strong>Promise'ler / Future'lar / Task'lar:</strong> Asenkron bir işlemin gelecekteki sonucunu temsil eden nesnelerdir. İşlemin başarı (resolve) veya başarısızlık (reject) durumunu ve sonucunu taşırlar. <code>.then()</code>, <code>.catch()</code> gibi metotlarla zincirleme işlem yapmayı kolaylaştırırlar. (JavaScript Promise, C# Task/Task<TResult>, Python asyncio Future/Task).</li>
                        <li><strong><code>async</code> / <code>await</code> Anahtar Kelimeleri:</strong> Promise/Task tabanlı asenkron kodu, senkron koda benzer bir şekilde yazmayı sağlayan sözdizimsel kolaylıktır. Kodun okunabilirliğini ve yazımını büyük ölçüde iyileştirir. <code>await</code>, asenkron işlemin sonucunu beklemeden programın akışını bloke etmez, işlemin tamamlanmasını beklerken kontrolü çağırana geri verir. (JavaScript, C#, Python 3.5+).</li>
                    </ul>
                     <p>Örnek (JavaScript - Fetch API ile):</p>
                     <pre><code class="language-javascript">
// Promise tabanlı fetch kullanımı
function veriCekPromise() {
    fetch('https://jsonplaceholder.typicode.com/todos/1')
        .then(response => {
            if (!response.ok) { throw new Error('Ağ yanıtı sorunlu'); }
            return response.json(); // Bu da bir Promise döndürür
        })
        .then(data => {
            console.log("Veri (Promise):", data);
        })
        .catch(error => {
            console.error('Hata (Promise):', error);
        });
}

// async/await ile fetch kullanımı (daha okunabilir)
async function veriCekAsyncAwait() {
    try {
        console.log("İstek gönderiliyor...");
        const response = await fetch('https://jsonplaceholder.typicode.com/todos/1');
        console.log("Yanıt alındı, kontrol ediliyor...");
        if (!response.ok) {
            throw new Error(`HTTP Hatası: ${response.status}`);
        }
        console.log("JSON verisi ayrıştırılıyor...");
        const data = await response.json(); // JSON ayrıştırmasını bekle
        console.log("Veri (async/await):", data);
    } catch (error) {
        console.error('Hata (async/await):', error);
    } finally {
        console.log("İşlem tamamlandı (hata olsa da olmasa da).");
    }
}

// veriCekPromise();
// veriCekAsyncAwait();
// console.log("Asenkron işlemler başlatıldı..."); // Bu satır genellikle fetch'lerden önce çalışır
                     </code></pre>
                      <p>Örnek (C# - HttpClient ile):</p>
                     <pre><code class="language-csharp">
using System;
using System.Net.Http;
using System.Threading.Tasks;

public class ApiIstemci
{
    private static readonly HttpClient client = new HttpClient();

    public async Task<string> VeriAlAsync(string url)
    {
        try
        {
            Console.WriteLine($"'{url}' adresinden veri alınıyor...");
            // await ile asenkron ağ isteğinin tamamlanmasını bekle
            HttpResponseMessage response = await client.GetAsync(url);
            response.EnsureSuccessStatusCode(); // Başarısızsa exception fırlatır

            Console.WriteLine("İçerik okunuyor...");
            // await ile içeriğin string olarak okunmasını bekle
            string responseBody = await response.Content.ReadAsStringAsync();
            Console.WriteLine("Veri başarıyla alındı.");
            return responseBody;
        }
        catch (HttpRequestException e)
        {
            Console.WriteLine($"\nİstek Hatası: {e.Message}");
            return null;
        }
    }
}

// Kullanım (Başka bir async metot içinde):
// async Task Kullan() {
//     ApiIstemci istemci = new ApiIstemci();
//     string veri = await istemci.VeriAlAsync("https://jsonplaceholder.typicode.com/posts/1");
//     if (veri != null) {
//         Console.WriteLine("\nAlınan Veri (ilk 100 karakter):");
//         Console.WriteLine(veri.Substring(0, Math.Min(veri.Length, 100)) + "...");
//     }
// }
                     </code></pre>
                     <p>Asenkron programlama, modern, performanslı ve duyarlı uygulamalar geliştirmek için vazgeçilmez bir tekniktir.</p>
                 </details>
            </section>

             <section id="sonuc" class="content-section">
                 <h2>Sonuç: Kaliteli Yazılım İçin Bütünsel Yaklaşım</h2>
                 <p>
                     Bu rehberde ele alınan SOLID prensipleri, Temiz Kod felsefesi, temel Tasarım Desenleri, Veri Yapıları ve Algoritmalar, OOP ile FP arasındaki denge ve Asenkron Programlama gibi konular, yazılım geliştirmenin sadece teknik bir süreç olmadığını, aynı zamanda bir zanaat ve mühendislik disiplini olduğunu göstermektedir. Bu kavramlar, sadece çalışan değil, aynı zamanda anlaşılır, sürdürülebilir, esnek, verimli ve test edilebilir yazılımlar oluşturmak için bir araya gelir.
                 </p>
                 <p>
                    SOLID, nesne yönelimli tasarımın temel direklerini oluştururken, Temiz Kod ilkeleri bu tasarımları okunabilir ve yönetilebilir kılar. Tasarım Desenleri, yaygın sorunlara zarif çözümler sunarken, Veri Yapıları ve Algoritmalar kodumuzun performans temelini oluşturur. Farklı programlama paradigmalarını (OOP, FP) anlamak, probleme en uygun aracı seçmemizi sağlarken, Asenkron Programlama modern uygulamaların yanıt verebilirliğini ve verimliliğini garanti eder.
                 </p>
                 <p>
                    Bu prensip ve kavramları öğrenmek ve ustalaşmak zaman ve pratik gerektirir. Ancak bu yatırım, uzun vadede daha kaliteli yazılımlar üretmenize, daha verimli çalışmanıza ve bir geliştirici olarak değerinizi artırmanıza yardımcı olacaktır. En önemlisi, bu ilkeler sadece belirli bir dil veya teknolojiye özgü değildir; çoğu, farklı platformlarda ve dillerde uygulanabilen evrensel yazılım mühendisliği prensipleridir. Bu bütünsel yaklaşımla, sadece kod yazmakla kalmaz, aynı zamanda kalıcı ve değerli yazılım çözümleri inşa edebilirsiniz.
                 </p>
            </section>
        </div>
    </main>

    <div class="back-to-top-container">
        <a href="#pageTop" class="back-to-top" aria-label="Sayfanın başına dön">
            <i class="fas fa-chevron-up"></i>
        </a>
   </div>

    <footer id="mainFooter">
        <div class="container">
            <div class="footer-layout">
                <div class="footer-left-links">
                    <h4>Hızlı Bağlantılar</h4>
                    <ul class="footer-nav-links">
                        <li><a href="https://abdulkadirgungor86.github.io/">Ana Sayfa</a></li>
                        <li><a href="https://abdulkadirgungor86.github.io/cv" target="_blank" rel="noopener noreferrer">Özgeçmiş</a></li>
                        <li><a href="https://abdulkadirgungor86.github.io/blog" target="_blank" rel="noopener noreferrer">Blog</a></li>
                    </ul>
                </div>
                <div class="footer-center-content">
                    <h4 class="sitemap-link-heading">
                        <a href="https://abdulkadirgungor86.github.io/sitemap.xml" target="_blank" rel="noopener noreferrer">Sitemap</a>
                    </h4>
                    <p id="footerTextContent">
                        <!-- Content will be loaded by script.js -->
                    </p>
                </div>
            </div>
        </div>
    </footer>
    
    <script src="../assets/js/script.js" defer></script>
</body>
</html>