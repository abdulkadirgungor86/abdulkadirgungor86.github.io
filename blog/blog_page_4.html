<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>.NET Lazy<T> Sınıfı: Tembel Yüklemenin Derinlikleri ve Performans Optimizasyonu</title>
    <meta name="description" content=".NET Framework ve .NET Core'un güçlü ama sıklıkla göz ardı edilen Lazy<T> sınıfı üzerine ultra detaylı bir inceleme. Bu kapsamlı rehber, tembel yükleme (lazy initialization) kavramının temellerinden başlayarak, Lazy<T>'nin neden gerekli olduğunu, tüm yapıcı metotlarını (constructor overloads), kritik LazyThreadSafetyMode seçeneklerini (None, PublicationOnly, ExecutionAndPublication), Value ve IsValueCreated özelliklerinin inceliklerini, iç çalışma mekanizmalarını, Singleton deseni gibi pratik kullanım senaryolarını, performans üzerindeki etkilerini, istisna yönetimini, AsyncLazy<T> gibi alternatifleri ve en iyi uygulama pratiklerini 5000 kelimeyi aşan bir derinlikle ele almaktadır. Performans optimizasyonu, kaynak yönetimi ve temiz kod yazımı için vazgeçilmez bir kaynak.">
    <meta name="keywords" content="Lazy<T>, Lazy Initialization, Tembel Yükleme, .NET, C#, .NET Core, .NET Framework, Performans Optimizasyonu, Performance Optimization, Kaynak Yönetimi, Resource Management, Gecikmeli Başlatma, Deferred Initialization, LazyThreadSafetyMode, None, PublicationOnly, ExecutionAndPublication, Thread Safety, İş Parçacığı Güvenliği, IsValueCreated, Value, Func<T>, valueFactory, Singleton Pattern, Singleton Deseni, Expensive Object Creation, Maliyetli Nesne Oluşturma, Veritabanı Bağlantısı, Database Connection, Yapılandırma Yönetimi, Configuration Management, Caching, Önbellekleme, Dependency Injection, Bağımlılık Enjeksiyonu, DI, IoC, Inversion of Control, AsyncLazy<T>, Asenkron Tembel Yükleme, LazyInitializer, LINQ, Deferred Execution, Yazılım Tasarımı, Software Design, Temiz Kod, Clean Code, Yazılım Mühendisliği, Software Engineering, .NET Mülakat Soruları, Debugging, Hata Ayıklama, İstisna Yönetimi, Exception Handling, Race Condition, Yarış Durumu, Locking, Kilitleme, Double-Checked Locking, Performans Analizi, Profiling, Yazılım Mimarisi">
    <meta name="author" content="Abdulkadir Güngör">
    <link rel="canonical" href="https://abdulkadirgungor86.github.io/blog/blog_page_4.html" />
    <link rel="icon" type="image/png" href="/icons/favicon-96x96.png" sizes="96x96" />
<link rel="icon" type="image/svg+xml" href="/icons/favicon.svg" />
<link rel="shortcut icon" href="/icons/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png" />
<link rel="manifest" href="/icons/site.webmanifest" />
    <link rel="sitemap" type="application/xml" title="Sitemap" href="https://abdulkadirgungor86.github.io/sitemap.xml">
    <link rel="sitemap" type="text/html" title="HTML Sitemap" href="https://abdulkadirgungor86.github.io/sitemap.html">
    <link rel="stylesheet" href="../assets/css/blog_style.css">
</head>
<body>

    <header class="header">
        <nav class="nav-container">
            <div class="logo">Lazy<T> Derinlemesine</div>
            <button class="menu-toggle" aria-label="Menüyü Aç/Kapat">☰</button>
            <ul class="nav-menu">
                 <li><a href="index.html">Ana Sayfa</a></li>
                <li><a href="#giris">Giriş: Tembelliğin Erdemi</a></li>
                <li><a href="#neden-lazy">Neden Lazy<T>?</a></li>
                <li><a href="#yapici-metotlar">Yapıcı Metotlar</a></li>
                <li><a href="#thread-safety">Thread Güvenliği</a></li>
                <li><a href="#temel-ozellikler">Temel Özellikler</a></li>
                <li><a href="#kullanim-senaryolari">Kullanım Senaryoları</a></li>
                <li><a href="#alternatifler-karsilastirma">Alternatifler</a></li>
                <li><a href="#dikkat-edilmesi-gerekenler">Önemli Notlar</a></li>
                <li><a href="#sonuc">Sonuç</a></li>
            </ul>
        </nav>
    </header>

    <div class="container">
        <main>
            <article id="giris" class="content-section intro-section">
                <h1>.NET Lazy&lt;T&gt;: Tembel Yüklemenin Sanatı ve Bilimi</h1>
                <p>
                    Yazılım geliştirme dünyasında "tembellik" genellikle olumsuz bir çağrışım yapsa da, doğru bağlamda kullanıldığında aslında büyük bir erdeme dönüşebilir. Özellikle performans optimizasyonu ve kaynak yönetimi söz konusu olduğunda, "tembel yükleme" (lazy initialization veya lazy loading) olarak bilinen yaklaşım, uygulamalarımızın daha hızlı başlamasını, gereksiz kaynak tüketimini önlemesini ve genel verimliliğini artırmasını sağlayan güçlü bir tekniktir. .NET ekosistemi, bu güçlü tekniği zarif ve kullanımı kolay bir şekilde hayata geçirmemiz için bize `System.Lazy<T>` adında, küçük ama son derece etkili bir sınıf sunar.
                </p>
                <p>
                    İlk bakışta `Lazy<T>`, sadece birkaç yapıcı metot ve iki temel özellik (`Value` ve `IsValueCreated`) içeren basit bir generic sınıf gibi görünebilir. Ancak bu basitliğin ardında, özellikle çoklu iş parçacıklı (multi-threaded) ortamlarda nesne başlatma işlemini güvenli ve verimli bir şekilde ertelemeyi sağlayan sofistike bir mekanizma yatar. `Lazy<T>`'nin temel vaadi şudur: Bir nesnenin veya bir değerin oluşturulması maliyetliyse (zaman, CPU veya bellek açısından) ve bu nesneye veya değere her zaman ihtiyaç duyulmuyorsa, onun oluşturulma işlemini gerçekten ihtiyaç duyulduğu ilk ana kadar ertelemek. Bu "ihtiyaç anında oluşturma" felsefesi, özellikle uygulama başlangıç sürelerini kısaltmak, bellek ayak izini azaltmak ve pahalı kaynakların (veritabanı bağlantıları, ağ servisleri, büyük veri yapıları vb.) yalnızca gerektiğinde tüketilmesini sağlamak için paha biçilmezdir.
                </p>
                <p>
                    Bu ultra detaylı makalede, `Lazy<T>` sınıfının sadece yüzeyini kazımakla kalmayacak, derinliklerine ineceğiz. Tembel yükleme kavramının neden önemli olduğunu anlamaktan başlayarak, `Lazy<T>`'nin tüm yapıcı metotlarını ve özellikle kritik öneme sahip `LazyThreadSafetyMode` seçeneklerini (None, PublicationOnly, ExecutionAndPublication) tüm ayrıntılarıyla inceleyeceğiz. `Value` ve `IsValueCreated` özelliklerinin nasıl çalıştığını, arka plandaki potansiyel mekanizmaları, istisna yönetiminin nasıl ele alındığını ve olası tuzakları tartışacağız. Singleton deseni gibi klasik tasarım problemlerinin `Lazy<T>` ile nasıl zarifçe çözüldüğünü, çeşitli pratik kullanım senaryolarını, performans üzerindeki gerçek etkilerini, `AsyncLazy<T>` gibi asenkron alternatifleri ve en iyi uygulama pratiklerini 5000 kelimeyi aşan bir kapsamda ele alacağız. Amacımız, `Lazy<T>`'yi sadece nasıl kullanacağınızı değil, aynı zamanda neden, ne zaman ve hangi modda kullanmanız gerektiğini tam olarak anlamanızı sağlamak ve bu güçlü aracı .NET araç kutunuzun vazgeçilmez bir parçası haline getirmenize yardımcı olmaktır.
                </p>
                 <p>
                    Yazılım geliştirmede optimizasyon, sadece mikro saniyeleri tıraşlamak anlamına gelmez; aynı zamanda kaynakları akıllıca kullanmak, kullanıcıya daha hızlı yanıt veren uygulamalar sunmak ve kodun bakımını kolaylaştırmak anlamına da gelir. `Lazy<T>`, bu hedeflere ulaşmada bize yardımcı olan, zarif bir şekilde tasarlanmış bir araçtır. Gelin, bu "erdemli tembelliğin" .NET'teki somutlaşmış hali olan `Lazy<T>`'nin tüm yönlerini birlikte keşfedelim.
                 </p>
            </article>

            <section id="neden-lazy" class="content-section">
                <h2>Neden Tembel Yükleme ve `Lazy&lt;T&gt;` Kullanmalıyız? Erken Yüklemenin Gölgeleri</h2>
                <p>Bir uygulamanın veya bileşenin yaşam döngüsünde, ihtiyaç duyduğu nesneleri ve verileri ne zaman oluşturacağı veya yükleyeceği önemli bir tasarım kararıdır. Varsayılan yaklaşım olan "erken yükleme" (eager loading), yani ihtiyaç anından önce her şeyi hazır etme stratejisi, basit görünse de beraberinde ciddi performans ve kaynak yönetimi sorunları getirebilir. İşte bu sorunlar, tembel yüklemenin ve dolayısıyla `Lazy<T>`'nin neden değerli olduğunu anlamamızı sağlar.</p>

                <details class="question-block">
                    <summary><h3>Erken Yüklemenin (Eager Loading) Somut Dezavantajları ve Senaryoları</h3></summary>
                    <p>
                        Bir sınıfın başlatılması sırasında veya uygulama ilk açıldığında tüm bağımlılıkların ve kaynakların yüklenmesi şu somut problemlere yol açabilir:
                    </p>
                    <ul>
                        <li>
                            <strong>Yavaş Başlangıç (Slow Startup):</strong>
                            <ul>
                                <li><strong>Kullanıcı Deneyimi Darbesi:</strong> Masaüstü veya mobil uygulamaların açılışının saniyelerce sürmesi, kullanıcı sabrını zorlar ve kötü bir ilk izlenim bırakır. Bu gecikmenin nedeni genellikle, henüz ekranda görünmeyen veya kullanıcı tarafından talep edilmeyen birçok bileşenin, verinin veya servisin arka planda başlatılmasıdır. Örneğin, bir e-posta istemcisinin tüm klasörleri, eklentileri ve ayarları açılışta senkronize etmeye çalışması.</li>
                                <li><strong>Servis Başlatma Gecikmeleri:</strong> Web servisleri veya arka plan görevleri için başlangıç süresi, sistemin genel yanıt verme kapasitesini etkiler. Bir mikroservisin başlaması uzun sürüyorsa, ona bağımlı diğer servisler de beklemek zorunda kalabilir veya zaman aşımları yaşanabilir. Özellikle otomatik ölçeklendirme (auto-scaling) senaryolarında, yeni örneklerin hızla devreye girmesi kritikken, yavaş başlangıç ciddi bir engel teşkil eder.</li>
                            </ul>
                        </li>
                        <li>
                            <strong>Kaynak İsrafı (Resource Waste):</strong>
                            <ul>
                                <li><strong>Bellek Tüketimi:</strong> Büyük veri yapıları (örneğin, uygulama genelinde kullanılan ama nadiren erişilen lookup tabloları, önbellekler) veya çok sayıda küçük nesne, başlangıçta belleğe yüklenirse, uygulamanın bellek ayak izini gereksiz yere artırır. Bu nesneler hiç kullanılmazsa, o bellek alanı boşa harcanmış olur. Özellikle bellek kısıtlı ortamlarda (mobil cihazlar, IoT cihazları, konteynerler) bu durum kritikleşir.</li>
                                <li><strong>CPU Döngüleri:</strong> Karmaşık hesaplamalar, şifreleme/çözme işlemleri veya veri dönüşümleri gerektiren nesnelerin oluşturulması, başlangıçta değerli CPU zamanını tüketir. Eğer bu sonuçlara daha sonra ihtiyaç duyulacaksa veya hiç duyulmayacaksa, bu CPU kullanımı israftır.</li>
                                <li><strong>Ağ ve G/Ç (I/O) İşlemleri:</strong> Veritabanı bağlantıları kurmak, uzak API'leri çağırmak veya diskten büyük dosyaları okumak gibi işlemler hem zaman alır hem de ağ bant genişliği, veritabanı bağlantı havuzu gibi sınırlı kaynakları tüketir. Başlangıçta gereksiz yere yapılan bu işlemler, hem uygulamanın yavaşlamasına hem de altyapı kaynaklarının verimsiz kullanılmasına neden olur. Örneğin, bir uygulamanın başlangıçta, kullanıcının henüz talep etmediği tüm rapor şablonlarını veritabanından çekmesi.</li>
                                <li><strong>Lisans Maliyetleri:</strong> Bazı kaynaklar (örneğin, belirli veritabanı sürücüleri, üçüncü parti servisler) bağlantı veya kullanım başına lisans maliyetine sahip olabilir. Gerekli olmayan bağlantıları veya servis çağrılarını başlangıçta yapmak, maliyeti artırabilir.</li>
                            </ul>
                        </li>
                        <li>
                            <strong>Kırılganlık ve Hata Yayılımı (Brittleness & Error Propagation):</strong>
                            <ul>
                                <li><strong>Tek Noktada Başarısızlık Riski:</strong> Eğer başlangıçta yüklenen kritik olmayan bir bileşen (örneğin, isteğe bağlı bir loglama servisi veya nadir kullanılan bir özellik modülü) başlatılamazsa (örneğin, konfigürasyon hatası, ağ sorunu), bu durum tüm uygulamanın veya ana bileşenin başlatılmasını engelleyebilir. Başarısızlık, ihtiyaç duyulmayan bir bileşenden kaynaklansa bile yayılabilir.</li>
                                <li><strong>Maskelenmiş Hatalar:</strong> Başlatma sırasında oluşan ancak hemen fark edilmeyen hatalar (örneğin, yanlış yüklenen konfigürasyon verisi), uygulamanın ilerleyen aşamalarında, hatanın kaynağını tespit etmenin zor olduğu anlarda beklenmedik davranışlara yol açabilir.</li>
                            </ul>
                        </li>
                        <li>
                            <strong>Artan Test Karmaşıklığı:</strong> Bir sınıfın yapıcısında çok fazla iş yapılması veya bağımlılığın yüklenmesi, o sınıfın birim testlerini (unit testing) yazmayı zorlaştırır. Tüm bu bağımlılıkların test ortamında sağlanması veya sahte (mock) nesnelerle değiştirilmesi gerekir, bu da testlerin karmaşıklığını ve kırılganlığını artırır.</li>
                    </ul>
                    <p>
                        Bu dezavantajlar, özellikle büyük ölçekli, modüler ve yüksek performans gerektiren uygulamalarda daha belirgin hale gelir. İşte bu noktada tembel yükleme ve `Lazy<T>` devreye girer.
                    </p>
                </details>

                 <details class="question-block">
                    <summary><h3>Tembel Yüklemenin Kurtarıcı Rolü ve `Lazy&lt;T&gt;`'nin Katkısı</h3></summary>
                    <p>
                        Tembel yükleme, "ihtiyaç anında başlatma" prensibiyle erken yüklemenin getirdiği sorunlara doğrudan çözümler sunar:
                    </p>
                    <ul>
                        <li><strong>Daha Hızlı Başlangıç:</strong> Sadece temel ve hemen gerekli olan bileşenler başlatılır. Maliyetli işlemler, ilgili nesneye veya değere ilk kez erişilene kadar ertelenir. Bu, uygulamanın veya servisin çok daha hızlı yanıt verir hale gelmesini sağlar.</li>
                        <li><strong>Optimize Edilmiş Kaynak Kullanımı:</strong> Bellek, CPU, ağ bağlantıları gibi kaynaklar sadece gerçekten ihtiyaç duyulduğunda tüketilir. Kullanılmayan nesneler için kaynak israfı ortadan kalkar. Bu, uygulamanın genel verimliliğini ve ölçeklenebilirliğini artırır.</li>
                        <li><strong>İzole Edilmiş Hatalar:</strong> Bir nesnenin başlatılması sırasındaki hata, sadece o nesneye ilk kez erişildiğinde ortaya çıkar. Bu, hatanın uygulamanın başlangıcını engellemesini önleyebilir ve hatanın etkisini, o nesneyi kullanmaya çalışan belirli bir iş akışıyla sınırlar. Hata yönetimi daha odaklı hale gelebilir.</li>
                        <li><strong>Basitleştirilmiş Bağımlılık Grafikleri (Başlangıçta):</strong> Başlangıç anında daha az nesne oluşturulduğu için, başlatma sırası karmaşıklığı azalabilir.</li>
                    </ul>
                    <p>
                        <strong>`Lazy<T>`'nin Katkısı Nedir?</strong> Tembel yükleme mantığını manuel olarak uygulamak mümkündür (örneğin, null kontrolü yapıp ilk erişimde nesneyi oluşturmak ve bir alanda saklamak), ancak bu yaklaşım özellikle çoklu iş parçacıklı ortamlarda karmaşık ve hataya açıktır. İş parçacığı güvenliğini (yarış durumlarını - race conditions - önlemek) sağlamak, başlatma işleminin yalnızca bir kez yapılmasını garanti etmek ve istisnaları doğru yönetmek ciddi bir mühendislik çabası gerektirir.
                    </p>
                    <p>
                        `Lazy<T>`, tüm bu karmaşıklığı bizim için yönetir:
                    </p>
                    <ul>
                        <li><strong>Standart ve Güvenilir Mekanizma:</strong> Tembel yüklemeyi uygulamak için kanıtlanmış, test edilmiş ve standart bir yol sunar.</li>
                        <li><strong>İş Parçacığı Güvenliği (Thread Safety):</strong> Farklı güvenlik seviyeleri (`LazyThreadSafetyMode`) sunarak, çoklu iş parçacıklı senaryolarda başlatma işleminin güvenli bir şekilde yapılmasını garanti eder (veya bilinçli olarak kapatılmasına izin verir). Elle yazılan çözümlerdeki potansiyel kilitlenme (deadlock) veya yarış durumu risklerini ortadan kaldırır.</li>
                        <li><strong>Yalnızca Bir Kez Başlatma Garantisi (Çoğu Modda):</strong> `ExecutionAndPublication` modunda, başlatma mantığının (fabrika metodu veya yapıcı) yalnızca bir kez çalıştırılacağını garanti eder. `PublicationOnly` modunda bile, yalnızca bir sonuç yayınlanır.</li>
                        <li><strong>Sonuç Önbellekleme:</strong> Başlatma işlemi bir kez yapıldıktan sonra sonuç önbelleğe alınır ve sonraki tüm `Value` erişimlerinde bu önbelleğe alınan değer döndürülür.</li>
                        <li><strong>Kolay Kullanım:</strong> Karmaşık kilitleme veya senkronizasyon kodları yazmak yerine, `Lazy<T>`'yi birkaç satır kodla kullanmak mümkündür. Bu, kodu daha okunabilir ve bakımı kolay hale getirir.</li>
                    </ul>
                     <p>
                        Kısacası, `Lazy<T>`, tembel yüklemenin faydalarını, manuel implementasyonun zorlukları ve riskleri olmadan elde etmemizi sağlayan, .NET geliştiricisinin araç çantasında mutlaka bulunması gereken temel bir sınıftır.
                    </p>
                </details>
                 <details class="question-block">
                    <summary><h3>LINQ Ertelenmiş Yürütme vs. `Lazy&lt;T&gt;`: Kavramsal Netleştirme</h3></summary>
                    <p>
                        Daha önce de belirtildiği gibi, LINQ'nun ertelenmiş yürütme (deferred execution) özelliği ile `Lazy<T>` arasında bir kavramsal benzerlik olsa da (her ikisi de bir işi hemen yapmaz), temel farkları ve kullanım amaçları farklıdır. Bu ayrımı netleştirmek önemlidir:
                    </p>
                    <table class="comparison-table" border="1" style="width:100%; border-collapse: collapse; margin-top: 1em;">
                        <thead>
                            <tr>
                                <th style="padding: 8px; text-align: left; background-color: var(--light-color);">Özellik</th>
                                <th style="padding: 8px; text-align: left; background-color: var(--light-color);">LINQ Deferred Execution</th>
                                <th style="padding: 8px; text-align: left; background-color: var(--light-color);">`Lazy&lt;T&gt;`</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td style="padding: 8px;"><strong>Temel Amaç</strong></td>
                                <td style="padding: 8px;">Veri kaynakları üzerinde sorguları tanımlamak ve yürütmeyi sonuçlar talep edilene kadar ertelemek. Sorgu zincirleme ve optimizasyon sağlar.</td>
                                <td style="padding: 8px;">Maliyetli bir nesnenin veya değerin oluşturulmasını, ilk kez ihtiyaç duyulana kadar ertelemek ve sonucu önbelleğe almak.</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px;"><strong>Yürütme Zamanı</strong></td>
                                <td style="padding: 8px;">Sorgu sonuçları üzerinde döngü başlatıldığında veya `ToList()`, `Count()` gibi sonuçlandırma metotları çağrıldığında.</td>
                                <td style="padding: 8px;">`Value` özelliğine ilk kez erişildiğinde.</td>
                            </tr>
                             <tr>
                                <td style="padding: 8px;"><strong>Tekrar Yürütme</strong></td>
                                <td style="padding: 8px;">Sorgu her sonuçlandırıldığında <strong>tekrar çalıştırılır</strong>.</td>
                                <td style="padding: 8px;">Başlatma mantığı (fabrika/yapıcı) <strong>yalnızca bir kez</strong> çalıştırılır (ExecutionAndPublication modunda) veya birden çok kez çalışsa bile sadece bir sonuç yayınlanır (PublicationOnly).</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px;"><strong>Sonuç Önbellekleme</strong></td>
                                <td style="padding: 8px;">Sorgunun kendisi önbellekleme yapmaz (sonuçları `ToList()` gibi bir metotla siz önbelleğe almadıkça).</td>
                                <td style="padding: 8px;">İlk çalıştırmanın sonucu <strong>otomatik olarak önbelleğe alınır</strong> ve sonraki erişimlerde kullanılır.</td>
                            </tr>
                            <tr>
                                <td style="padding: 8px;"><strong>Tipik Kullanım</strong></td>
                                <td style="padding: 8px;">Veritabanı sorguları, koleksiyon filtreleme/dönüştürme işlemleri.</td>
                                <td style="padding: 8px;">Pahalı nesne başlatma (Singleton, kaynaklar), maliyetli hesaplamalar, isteğe bağlı veri yükleme.</td>
                            </tr>
                             <tr>
                                <td style="padding: 8px;"><strong>İş Parçacığı Güvenliği</strong></td>
                                <td style="padding: 8px;">LINQ sorgularının kendisi genellikle thread-safe değildir (özellikle paylaşılan koleksiyonlar üzerinde çalışırken). Güvenlik, veri kaynağının ve sonuçlandırma işleminin nasıl yapıldığına bağlıdır.</td>
                                <td style="padding: 8px;">`LazyThreadSafetyMode` ile iş parçacığı güvenliği açıkça kontrol edilebilir ve garanti altına alınabilir (varsayılan modda).</td>
                            </tr>
                        </tbody>
                    </table>
                     <p style="margin-top: 1em;">
                        Bu tablo, iki mekanizmanın farklı problemlere çözüm sunduğunu göstermektedir. LINQ, sorgu ifadesini optimize ederken, `Lazy<T>`, bir nesnenin yaşam döngüsündeki başlatma anını optimize eder. Her ikisi de performansa katkıda bulunabilir ancak farklı yollarla ve farklı senaryolarda.
                    </p>
                </details>
            </section>

            <section id="yapici-metotlar" class="content-section">
                 <h2>`Lazy&lt;T&gt;` Yapıcı Metotları (Constructors): Tembelliği İnce Ayarlamak</h2>
                 <p>`Lazy<T>` sınıfının gücü ve esnekliği, farklı başlatma stratejileri ve iş parçacığı güvenliği ihtiyaçlarına cevap veren çeşitli yapıcı metot (constructor) aşırı yüklemelerinde (overloads) yatmaktadır. Bu yapıcıları doğru anlamak ve uygun olanı seçmek, `Lazy<T>`'yi etkin bir şekilde kullanmanın anahtarıdır. Gelin her birini detaylıca inceleyelim.</p>

                <details class="question-block">
                    <summary><h3>1. `public Lazy()` - En Basit Yol: Varsayılan Yapıcı</h3></summary>
                    <p>
                        Bu, `Lazy<T>`'nin en temel ve parametresiz yapıcı metodudur. Kullanımı son derece basittir ancak belirli varsayımlara dayanır.
                    </p>
                    <ul>
                        <li><strong>Çalışma Prensibi:</strong> Bu yapıcı ile oluşturulan bir `Lazy<T>` örneği, `T` tipinin <strong>public ve parametresiz varsayılan yapıcı metodunu</strong> (`new T()`) kullanarak hedef nesneyi oluşturmak üzere yapılandırılır. Başlatma işlemi, `Value` özelliğine ilk kez erişilene kadar ertelenir.</li>
                        <li><strong>Önemli Gereksinim:</strong> Bu yapıcıyı kullanabilmek için, generic tip parametresi olan `T`'nin mutlaka erişilebilir (genellikle `public`) ve parametre almayan bir yapıcı metoda sahip olması gerekir. Eğer `T` böyle bir yapıcıya sahip değilse, `Lazy<T>` örneği oluşturulur ancak `Value` özelliğine ilk erişimde `System.MissingMemberException` fırlatılır. Eğer yapıcı metot var ama erişim kısıtlamaları nedeniyle (örneğin `private` veya `internal` olması ve erişim hakkı olmaması) erişilemiyorsa, `System.MemberAccessException` fırlatılabilir.</li>
                        <li><strong>Varsayılan İş Parçacığı Güvenliği:</strong> Bu yapıcı metot, varsayılan olarak en güvenli mod olan `LazyThreadSafetyMode.ExecutionAndPublication` modunu kullanır. Bu, birden fazla iş parçacığı aynı anda `Value` özelliğine erişse bile, `new T()` işleminin yalnızca bir kez, güvenli bir şekilde çalıştırılacağını ve tüm iş parçacıklarının aynı nesne örneğini alacağını garanti eder.</li>
                        <li><strong>Kullanım Senaryoları:</strong>
                            <ul>
                                <li>Oluşturulacak nesnenin (`T`) basit bir varsayılan yapıcısı varsa ve ek başlatma mantığı gerekmiyorsa.</li>
                                <li>Nesne oluşturma maliyetli ise veya her zaman ihtiyaç duyulmuyorsa.</li>
                                <li>Çoklu iş parçacıklı bir ortamda çalışılıyorsa ve varsayılan güvenlik seviyesi yeterliyse.</li>
                            </ul>
                        </li>
                        <li><strong>Dezavantajları:</strong> Parametreli yapıcıları veya daha karmaşık başlatma mantığını desteklemez. İş parçacığı güvenliği modunu değiştirmek için kullanılamaz.</li>
                    </ul>
                    <pre><code class="language-csharp">
public class ExpensiveService
{
    public ExpensiveService() // Public, parametresiz yapıcı
    {
        Console.WriteLine("ExpensiveService başlatılıyor... (Maliyetli işlem)");
        // Örneğin, veritabanı bağlantısı kur, konfigürasyon oku vb.
        System.Threading.Thread.Sleep(2000); // Simüle edilen gecikme
    }

    public void DoWork() => Console.WriteLine("ExpensiveService iş yapıyor.");
}

// Kullanım:
Lazy&lt;ExpensiveService&gt; lazyService = new Lazy&lt;ExpensiveService&gt;(); // Varsayılan yapıcı ve ExecutionAndPublication modu

Console.WriteLine($"Servis oluşturuldu mu? {lazyService.IsValueCreated}"); // False

Console.WriteLine("Value'ya ilk erişim...");
ExpensiveService serviceInstance = lazyService.Value; // Bu satırda ExpensiveService() yapıcısı çalışır
Console.WriteLine($"Servis oluşturuldu mu? {lazyService.IsValueCreated}"); // True

serviceInstance.DoWork();

Console.WriteLine("Value'ya ikinci erişim...");
ExpensiveService sameInstance = lazyService.Value; // Yapıcı tekrar çalışmaz, önbellekteki örnek döndürülür
sameInstance.DoWork();

// lazyService == sameInstance -> true
                    </code></pre>
                </details>

                <details class="question-block">
                    <summary><h3>2. `public Lazy(Func&lt;T&gt; valueFactory)` - Özel Başlatma Mantığı</h3></summary>
                    <p>
                        Nesne oluşturma işlemi varsayılan yapıcıdan daha karmaşıksa veya belirli parametrelerle yapılması gerekiyorsa, bu yapıcı metot devreye girer.
                    </p>
                    <ul>
                        <li><strong>Çalışma Prensibi:</strong> Bu yapıcı, `valueFactory` adında bir `Func<T>` delegesi alır. Bu delege, parametre almayan ve `T` tipinde bir nesne döndüren bir metodu (veya lambda ifadesini) işaret eder. `Value` özelliğine ilk kez erişildiğinde, `Lazy<T>` bu `valueFactory`'yi çağırır, dönen değeri alır ve sonraki erişimler için önbelleğe alır.</li>
                        <li><strong>`Func<T> valueFactory` Detayları:</strong> `Func<T>`, `.NET`'in generic bir delegesidir. `()` -> `T` imzasına sahiptir. Yani, herhangi bir parametre almadan `T` türünde bir sonuç döndüren herhangi bir metodu temsil edebilir. Lambda ifadeleri (`() => { /* mantık */ return new T(...); }`) bu delegeye kolayca atanabilir.</li>
                        <li><strong>Önemli Gereksinim:</strong> Sağlanan `valueFactory` delegesi `null` olamaz. Eğer `null` ise, yapıcı metot hemen `System.ArgumentNullException` fırlatır. `T` tipinin varsayılan yapıcısı olması gerekmez, çünkü başlatma mantığı artık `valueFactory` tarafından sağlanmaktadır.</li>
                        <li><strong>Varsayılan İş Parçacığı Güvenliği:</strong> Bu yapıcı da varsayılan olarak `LazyThreadSafetyMode.ExecutionAndPublication` modunu kullanır. Yani, `valueFactory`'nin birden fazla iş parçacığı tarafından eş zamanlı erişim durumunda bile yalnızca bir kez çağrılacağı garanti edilir.</li>
                        <li><strong>Kullanım Senaryoları:</strong>
                            <ul>
                                <li>Parametre alan bir yapıcıyı çağırmak gerektiğinde.</li>
                                <li>Nesneyi oluşturmadan önce veya sonra ek yapılandırma veya başlatma adımları gerektiğinde.</li>
                                <li>Nesnenin bir fabrika metodundan (factory method) alınması gerektiğinde.</li>
                                <li>Oluşturma işleminin karmaşık bir hesaplama veya veri getirme işlemi içerdiği durumlarda.</li>
                                <li>Singleton deseni gibi özel başlatma senaryolarında.</li>
                            </ul>
                        </li>
                    </ul>
                    <pre><code class="language-csharp">
public class DatabaseSettings
{
    public string ConnectionString { get; private set; }
    public int Timeout { get; private set; }

    // Parametreli yapıcı
    public DatabaseSettings(string connectionString, int timeout = 30)
    {
        Console.WriteLine("DatabaseSettings başlatılıyor...");
        ConnectionString = connectionString;
        Timeout = timeout;
        // ... belki başka başlatma işlemleri ...
    }
}

// Kullanım:
Lazy&lt;DatabaseSettings&gt; lazySettings = new Lazy&lt;DatabaseSettings&gt;(() =>
{
    Console.WriteLine("ValueFactory çalışıyor...");
    // Konfigürasyon dosyasından veya başka bir yerden değerleri oku
    string connStr = "Server=myServer;Database=myDataBase;Trusted_Connection=True;";
    int timeout = 60;
    return new DatabaseSettings(connStr, timeout); // Parametreli yapıcıyı çağır
});

Console.WriteLine($"Ayarlar oluşturuldu mu? {lazySettings.IsValueCreated}"); // False

Console.WriteLine("Value'ya ilk erişim...");
DatabaseSettings settings = lazySettings.Value; // Lambda ifadesi çalışır, DatabaseSettings(connStr, timeout) çağrılır
Console.WriteLine($"Ayarlar oluşturuldu mu? {lazySettings.IsValueCreated}"); // True
Console.WriteLine($"Connection String: {settings.ConnectionString}");

Console.WriteLine("Value'ya ikinci erişim...");
DatabaseSettings sameSettings = lazySettings.Value; // Fabrika metodu tekrar çalışmaz
Console.WriteLine($"Timeout: {sameSettings.Timeout}");
                    </code></pre>
                </details>

                <details class="question-block">
                    <summary><h3>3. `public Lazy(bool isThreadSafe)` - Varsayılan Yapıcı ile Güvenlik Ayarı (Eski Yöntem)</h3></summary>
                    <p>
                        Bu yapıcı, `T`'nin varsayılan yapıcısını kullanır ancak iş parçacığı güvenliğini basit bir `bool` değeri ile kontrol etme imkanı sunar. Modern kodlarda genellikle `Lazy(LazyThreadSafetyMode mode)` tercih edilir.
                    </p>
                    <ul>
                        <li><strong>Çalışma Prensibi:</strong> `T`'nin varsayılan yapıcısını (`new T()`) kullanır. `isThreadSafe` parametresi `true` ise `LazyThreadSafetyMode.ExecutionAndPublication` modunda, `false` ise `LazyThreadSafetyMode.None` modunda çalışır.</li>
                        <li><strong>Parametre (`isThreadSafe`):</strong>
                            <ul>
                                <li>`true`: Tam iş parçacığı güvenliği. Yapıcı bir kez çalışır.</li>
                                <li>`false`: İş parçacığı güvenliği yok. Yalnızca tek iş parçacıklı kullanım için güvenlidir.</li>
                            </ul>
                        </li>
                        <li><strong>Gereksinim:</strong> `T`'nin public, parametresiz bir yapıcısı olmalıdır.</li>
                        <li><strong>Kullanım Senaryoları:</strong> Genellikle geriye dönük uyumluluk veya çok basit senaryolarda kullanılır. `LazyThreadSafetyMode.PublicationOnly` seçeneğini sunmaz. Eğer iş parçacığı güvenliğini `None` olarak ayarlamak istiyorsanız ve varsayılan yapıcı yeterliyse kullanılabilir, ancak `Lazy(LazyThreadSafetyMode.None)` daha açıklayıcıdır.</li>
                    </ul>
                    <pre><code class="language-csharp">
// Güvenlik yok, sadece tek thread kullanacak (dikkatli kullan!)
Lazy&lt;StringBuilder&gt; unsafeBuilder = new Lazy&lt;StringBuilder&gt;(false);

// Tam güvenlik (lazyService ile aynı davranışı gösterir)
Lazy&lt;ExpensiveService&gt; safeService = new Lazy&lt;ExpensiveService&gt;(true);
                    </code></pre>
                </details>

                <details class="question-block">
                    <summary><h3>4. `public Lazy(LazyThreadSafetyMode mode)` - Varsayılan Yapıcı ile Detaylı Güvenlik Ayarı</h3></summary>
                    <p>
                        Bu yapıcı, `T`'nin varsayılan yapıcısını kullanırken iş parçacığı güvenliği üzerinde tam kontrol sağlar ve genellikle `Lazy(bool isThreadSafe)`'e tercih edilir.
                    </p>
                    <ul>
                        <li><strong>Çalışma Prensibi:</strong> `T`'nin varsayılan yapıcısını (`new T()`) kullanır. İş parçacığı güvenliği davranışını, parametre olarak aldığı `LazyThreadSafetyMode` enum değeri (`None`, `PublicationOnly`, `ExecutionAndPublication`) belirler.</li>
                        <li><strong>Parametre (`mode`):</strong> Seçilen moda göre güvenlik ve performans dengesi ayarlanır. (Detayları bir sonraki bölümde ele alınacaktır).</li>
                        <li><strong>Gereksinim:</strong> `T`'nin public, parametresiz bir yapıcısı olmalıdır. `mode` için geçerli bir enum değeri sağlanmalıdır.</li>
                        <li><strong>Kullanım Senaryoları:</strong>
                            <ul>
                                <li>Varsayılan yapıcı yeterli olduğunda ancak iş parçacığı güvenliği üzerinde hassas kontrol gerektiğinde (örneğin, `PublicationOnly` modunu kullanmak veya `None` modunu açıkça belirtmek için).</li>
                                <li>Kodun okunabilirliğini artırmak için güvenlik modunu doğrudan belirtmek istendiğinde.</li>
                            </ul>
                        </li>
                    </ul>
                    <pre><code class="language-csharp">
// Varsayılan yapıcı, tam güvenlik (en yaygın ve güvenli)
Lazy&lt;ConfigurationManager&gt; configMgr = new Lazy&lt;ConfigurationManager&gt;(LazyThreadSafetyMode.ExecutionAndPublication);

// Varsayılan yapıcı, yayınlama güvenliği (ConfigurationManager() yan etkisiz ve tekrar çalışması sorun değilse)
Lazy&lt;ResourceProvider&gt; resourceProvider = new Lazy&lt;ResourceProvider&gt;(LazyThreadSafetyMode.PublicationOnly);

// Varsayılan yapıcı, güvenlik yok (tek thread için)
Lazy&lt;SessionData&gt; sessionData = new Lazy&lt;SessionData&gt;(LazyThreadSafetyMode.None);
                    </code></pre>
                </details>

                 <details class="question-block">
                    <summary><h3>5. `public Lazy(Func&lt;T&gt; valueFactory, bool isThreadSafe)` - Özel Fabrika ve Basit Güvenlik</h3></summary>
                    <p>
                        Özel bir başlatma mantığı (`valueFactory`) ile `bool` tabanlı güvenlik ayarını birleştirir.
                    </p>
                     <ul>
                        <li><strong>Çalışma Prensibi:</strong> Belirtilen `valueFactory`'yi kullanır. `isThreadSafe` `true` ise `ExecutionAndPublication`, `false` ise `None` modunda çalışır.</li>
                        <li><strong>Gereksinimler:</strong> `valueFactory` null olamaz.</li>
                        <li><strong>Kullanım Senaryoları:</strong> Özel başlatma mantığı gerektiğinde ve güvenlik modu olarak sadece `None` veya `ExecutionAndPublication` arasında seçim yapmak yeterliyse kullanılır. `PublicationOnly` modunu desteklemez. `Lazy(Func<T> valueFactory, LazyThreadSafetyMode mode)` genellikle daha esnek ve açıklayıcıdır.</li>
                    </ul>
                     <pre><code class="language-csharp">
// Güvenli, özel fabrika
Lazy&lt;UserProfile&gt; profile = new Lazy&lt;UserProfile&gt;(() => LoadUserProfile(userId), true);

// Güvensiz (tek thread), özel fabrika
Lazy&lt;TemporaryFile&gt; tempFile = new Lazy&lt;TemporaryFile&gt;(CreateTempFile, false);
                    </code></pre>
                 </details>

                 <details class="question-block">
                    <summary><h3>6. `public Lazy(Func&lt;T&gt; valueFactory, LazyThreadSafetyMode mode)` - En Esnek Yapılandırıcı</h3></summary>
                     <p>
                        Bu yapıcı, hem özel başlatma mantığı (`valueFactory`) hem de ayrıntılı iş parçacığı güvenliği modu (`LazyThreadSafetyMode`) üzerinde tam kontrol sunar. Genellikle en çok tercih edilen ve en güçlü yapılandırıcıdır.
                     </p>
                      <ul>
                        <li><strong>Çalışma Prensibi:</strong> Belirtilen `valueFactory` delegesini kullanarak ve seçilen `LazyThreadSafetyMode` (`None`, `PublicationOnly`, `ExecutionAndPublication`) kurallarına göre nesneyi tembelce başlatır.</li>
                        <li><strong>Gereksinimler:</strong> `valueFactory` null olamaz. `mode` geçerli bir enum değeri olmalıdır.</li>
                        <li><strong>Kullanım Senaryoları:</strong> Neredeyse tüm `Lazy<T>` kullanım durumları için uygundur. Özellikle:
                            <ul>
                                <li>Karmaşık veya özel başlatma mantığı gerektiğinde.</li>
                                <li>İş parçacığı güvenliği üzerinde tam kontrol istendiğinde (performans ve güvenlik arasında bilinçli bir denge kurmak için).</li>
                                <li>Kodun amacını en açık şekilde ifade etmek istendiğinde.</li>
                            </ul>
                        </li>
                    </ul>
                     <pre><code class="language-csharp">
// Singleton deseni için thread-safe fabrika
private static readonly Lazy&lt;MySingleton&gt; instance =
    new Lazy&lt;MySingleton&gt;(() => new MySingleton(), LazyThreadSafetyMode.ExecutionAndPublication);

public static MySingleton Instance => instance.Value;

// Yan etkisiz fabrika ile PublicationOnly modu (performans odaklı)
Lazy&lt;ImmutableData&gt; data = new Lazy&lt;ImmutableData&gt;(
    LoadImmutableData, // Bu metodun tekrar çağrılması sorun yaratmamalı
    LazyThreadSafetyMode.PublicationOnly
);

// Tek thread'de çalışacak özel hesaplama, güvenlik gereksiz
Lazy&lt;CalculationResult&gt; result = new Lazy&lt;CalculationResult&gt;(
    DoExpensiveCalculation,
    LazyThreadSafetyMode.None
);
                    </code></pre>
                     <p>Doğru yapıcı metodu seçmek, `Lazy<T>`'nin davranışını uygulamanızın gereksinimlerine tam olarak uyacak şekilde ayarlamanıza olanak tanır.</p>
                 </details>
            </section>

            <section id="thread-safety" class="content-section">
                 <h2>`LazyThreadSafetyMode`: İş Parçacığı Güvenliği Modlarının Derinlikleri</h2>
                 <p>`Lazy<T>`'nin çoklu iş parçacıklı ortamlarda güvenilirliğini ve performansını belirleyen en kritik faktörlerden biri, yapıcı metotta belirtilen `LazyThreadSafetyMode` değeridir. Bu modlar, başlatma işleminin eş zamanlı erişimlerde nasıl davranacağını tanımlar. Gelin her modu detaylıca inceleyelim.</p>

                <details class="question-block">
                    <summary><h3>`LazyThreadSafetyMode.None`: Güvenlik Yok, Maksimum Hız (Riskli!)</h3></summary>
                    <p>
                        <strong>Tanım:</strong> Bu mod, iş parçacığı güvenliği için hiçbir ek yük veya kontrol getirmez. `Lazy<T>` örneği, sanki tek bir iş parçacığında çalışıyormuş gibi davranır.
                    </p>
                    <p>
                        <strong>Eş Zamanlı Erişimde Davranış:</strong> Eğer birden fazla iş parçacığı, henüz başlatılmamış (`IsValueCreated == false`) bir `Lazy<T>` örneğinin `Value` özelliğine <i>aynı anda</i> erişirse, tam bir <strong>yarış durumu (race condition)</strong> ortaya çıkar. Kilitleme mekanizması olmadığı için, her iş parçacığı `IsValueCreated` kontrolünü geçebilir ve başlatma mantığını (fabrika metodu veya varsayılan yapıcı) çalıştırmaya başlayabilir. Bu durumda:
                        <ul>
                            <li>Başlatma mantığı <strong>birden fazla kez</strong> çalıştırılabilir.</li>
                            <li>`Value` özelliği, farklı iş parçacıkları için potansiyel olarak <strong>farklı nesne örneklerini</strong> döndürebilir (eğer fabrika metodu her çağrıldığında yeni bir örnek oluşturuyorsa).</li>
                            <li>Eğer başlatma mantığı paylaşılan bir durumu değiştiriyorsa veya yan etkileri varsa, bu durumun tutarlılığı bozulabilir (data corruption).</li>
                            <li>Beklenmedik istisnalar veya hatalar meydana gelebilir.</li>
                        </ul>
                        Kısacası, davranış tamamen <strong>tanımsız ve güvenilmezdir</strong>.
                    </p>
                    <p>
                        <strong>Performans:</strong> Hiçbir senkronizasyon (kilitleme vb.) ek yükü olmadığı için, teorik olarak en yüksek performansı sunar.
                    </p>
                    <p>
                        <strong>Ne Zaman Kullanılmalı? (Çok Dikkatli!):</strong> Bu mod, <strong>yalnızca ve yalnızca</strong> ilgili `Lazy<T>` örneğine hayatı boyunca <strong>tek bir iş parçacığından</strong> erişileceğinden %100 emin olduğunuz durumlarda kullanılmalıdır. Bu garantiyi sağlamak çoğu zaman zordur. Potansiyel kullanım alanları şunlar olabilir:
                        <ul>
                            <li>Bir metot içindeki yerel değişken olarak tanımlanan `Lazy<T>`.</li>
                            <li>Kesinlikle sadece UI iş parçacığı tarafından kullanılan bir sınıf üyesi.</li>
                            <li>İş parçacığı güvenliğinin dışarıdan başka mekanizmalarla (örneğin, `lock` ifadeleriyle) sağlandığı özel durumlar (ancak bu genellikle `Lazy<T>`'nin amacını bozar).</li>
                        </ul>
                        <strong>Uyarı:</strong> En ufak bir şüphe durumunda veya gelecekte kodun çoklu iş parçacıklı bir ortamda kullanılma ihtimali varsa, bu moddan kesinlikle kaçınılmalıdır. Sağlayacağı küçük performans kazancı, potansiyel olarak yaratacağı tespit edilmesi zor hatalara değmez.
                    </p>
                </details>

                <details class="question-block">
                    <summary><h3>`LazyThreadSafetyMode.PublicationOnly`: Yarışan Fabrikalar, Kazanan Tek Yayın</h3></summary>
                    <p>
                        <strong>Tanım:</strong> Bu mod, başlatma işleminin birden fazla kez çalışmasına izin verir ancak sonucun yalnızca bir kez yayınlanmasını garanti eder.
                    </p>
                     <p>
                        <strong>Eş Zamanlı Erişimde Davranış:</strong> Henüz başlatılmamış bir `Lazy<T>` örneğinin `Value` özelliğine birden fazla iş parçacığı aynı anda erişirse:
                        <ul>
                            <li>Her iş parçacığı başlatma mantığını (fabrika metodu veya varsayılan yapıcı) çalıştırmaya <strong>başlayabilir</strong>. Yani, fabrika metodu potansiyel olarak <strong>birden fazla kez</strong> çağrılır.</li>
                            <li>Ancak, `Lazy<T>` sınıfı, bu yarışan başlatma işlemlerinden yalnızca <strong>ilk tamamlananın sonucunu</strong> atomik olarak kaydeder ve "yayınlar".</li>
                            <li>Diğer iş parçacıklarının tamamladığı başlatma işlemlerinin sonuçları <strong>yok sayılır (atılır)</strong>.</li>
                            <li>Sonuç olarak, `Value` özelliğine erişen <strong>tüm</strong> iş parçacıkları, başlatma işlemini kimin yaptığına bakılmaksızın, sonunda aynı, tek bir yayınlanmış nesne örneğini veya değeri alırlar.</li>
                        </ul>
                        Hangi iş parçacığının başlatma işleminin "kazanacağı" (yani sonucunun yayınlanacağı) garanti edilmez, bu zamanlamaya bağlıdır.
                    </p>
                    <p>
                        <strong>Performans:</strong> `None` modundan biraz daha yavaştır çünkü sonucun atomik olarak yayınlanması için bir miktar senkronizasyon gerekir. Ancak, `ExecutionAndPublication` modundaki tam kilitlemeye göre genellikle daha performanslıdır, çünkü başlatma işlemi sırasında diğer iş parçacıklarını bloke etmez (sadece sonuç yayınlama anında kısa bir senkronizasyon olabilir).
                    </p>
                    <p>
                        <strong>Ne Zaman Kullanılmalı? (Dikkatli Seçim):</strong> Bu modun güvenle kullanılabilmesi için <strong>kritik ön koşul</strong>, başlatma mantığının (fabrika metodu veya varsayılan yapıcı) <strong>tekrarlanabilir (idempotent)</strong> olması ve önemli <strong>yan etkilerden (side effects) arınmış</strong> olmasıdır. Yani:
                        <ul>
                            <li>Metodun birden fazla kez çalıştırılması, uygulamanın genel durumunu bozmamalıdır (örneğin, aynı dosyayı tekrar tekrar oluşturmaya çalışmamalı, bir sayacı birden fazla kez artırmamalı, aynı veritabanı kaydını tekrar eklemeye çalışmamalıdır).</li>
                            <li>Metot her çalıştığında temelde aynı veya eşdeğer bir sonuç üretmelidir (veya üretilen farklı sonuçların atılmasının bir zararı olmamalıdır).</li>
                        </ul>
                        Bu koşullar sağlandığında, `PublicationOnly` modu şu durumlarda faydalı olabilir:
                        <ul>
                            <li>Başlatma işleminin kendisi çok maliyetli değilse ancak kilit çekişmesinin (lock contention) yüksek olabileceği ve `ExecutionAndPublication` modunun performans darboğazı yaratabileceği senaryolarda.</li>
                            <li>Genellikle değişmez (immutable) nesneler oluşturulduğunda (çünkü bunların tekrar oluşturulmasının yan etkisi yoktur).</li>
                            <li>Önbellek doldurma gibi işlemlerde, aynı verinin birden fazla iş parçacığı tarafından aynı anda getirilmeye çalışılması ancak sadece birinin sonucunun kullanılmasının kabul edilebilir olduğu durumlarda.</li>
                        </ul>
                        <strong>Uyarı:</strong> Eğer başlatma mantığının yan etkileri varsa veya tekrar çalıştırılması sorun yaratacaksa, bu mod kesinlikle kullanılmamalıdır.
                    </p>
                </details>

                <details class="question-block">
                    <summary><h3>`LazyThreadSafetyMode.ExecutionAndPublication` (Varsayılan): Tam Güvenlik, Tek Çalıştırma</h3></summary>
                     <p>
                        <strong>Tanım:</strong> Bu mod, hem başlatma işleminin yalnızca bir kez çalıştırılmasını hem de sonucun güvenli bir şekilde yayınlanmasını garanti eden en katı ve en güvenli moddur. Bu, `Lazy<T>`'nin varsayılan davranışıdır.
                    </p>
                     <p>
                        <strong>Eş Zamanlı Erişimde Davranış:</strong> Henüz başlatılmamış bir `Lazy<T>` örneğinin `Value` özelliğine birden fazla iş parçacığı aynı anda erişirse:
                        <ul>
                            <li>`Lazy<T>` sınıfı dahili bir <strong>kilitleme mekanizması</strong> kullanır.</li>
                            <li>Yalnızca <strong>bir</strong> iş parçacığı kilidi alabilir ve başlatma mantığını (fabrika metodu veya varsayılan yapıcı) çalıştırmaya başlar.</li>
                            <li>Diğer iş parçacıkları, kilidi alan iş parçacığı başlatma işlemini <strong>tamamlayana kadar bekletilir (bloke edilir)</strong>.</li>
                            <li>Başlatma işlemi tamamlandığında, sonuç önbelleğe alınır ve kilit serbest bırakılır.</li>
                            <li>Hem başlatmayı yapan iş parçacığı hem de bekleyen diğer tüm iş parçacıkları, `Value` özelliğinden aynı, önbelleğe alınmış nesne örneğini veya değeri alırlar.</li>
                        </ul>
                        Bu mekanizma, başlatma mantığının <strong>kesinlikle sadece bir kez</strong> çalıştırılacağını garanti eder.
                    </p>
                    <p>
                        <strong>Performans:</strong> Kilitleme mekanizması nedeniyle diğer iki moda göre (özellikle `None`) bir miktar performans ek yükü getirir. Bu ek yük, özellikle kilit üzerinde yoğun çekişme (contention) olduğunda, yani çok sayıda iş parçacığı aynı anda başlatılmamış `Lazy<T>`'ye erişmeye çalıştığında daha belirgin olabilir. Ancak, çoğu tipik uygulama senaryosunda bu ek yük genellikle kabul edilebilir düzeydedir. .NET implementasyonu genellikle optimize edilmiş kilitleme teknikleri (örneğin, double-checked locking'in dikkatli bir implementasyonu) kullanır.
                    </p>
                     <p>
                        <strong>Ne Zaman Kullanılmalı? (Genellikle En İyi Seçim):</strong>
                        <ul>
                            <li>`Lazy<T>` örneğine birden fazla iş parçacığından erişilebilecek <strong>herhangi bir senaryo</strong> için en güvenli seçenektir.</li>
                            <li>Başlatma mantığının (fabrika metodu veya yapıcının) <strong>kesinlikle yalnızca bir kez</strong> çalıştırılması gerekiyorsa (örneğin, yan etkileri varsa, kaynakları başlatıyorsa, Singleton deseni implemente ediyorsa veya işlem çok maliyetliyse).</li>
                            <li>Hangi güvenlik modunun gerekli olduğundan emin değilseniz, varsayılan davranış olduğu için bu modla başlamak en doğrusudur.</li>
                            <li>Performansın mutlak en üst düzeyde kritik olmadığı ve güvenliğin öncelikli olduğu durumlar için idealdir.</li>
                        </ul>
                        <strong>Özetle:</strong> Şüphede kaldığınızda veya en yüksek güvenliği istediğinizde `ExecutionAndPublication` modunu kullanın. Sadece performansın kritik olduğu ve koşulların uygun olduğu (tek thread veya yan etkisiz fabrika) özel durumlarda diğer modları dikkatlice değerlendirin.
                    </p>
                </details>
            </section>

            <section id="temel-ozellikler" class="content-section">
                 <h2>`Lazy&lt;T&gt;`'nin Temel Özellikleri ve Davranışları</h2>
                 <p>`Lazy<T>` sınıfının dış dünyaya açılan arayüzü oldukça yalındır ve temel olarak iki özellik ile bir metot içerir: `Value`, `IsValueCreated` ve `ToString()`.</p>

                 <details class="question-block">
                    <summary><h3>`public T Value { get; }`: Tembel Değere Erişim Kapısı</h3></summary>
                    <p>
                        Bu salt okunur (read-only) özellik, `Lazy<T>` tarafından yönetilen, tembel olarak başlatılan nesneye veya değere erişmenin tek yoludur. Davranışı, özelliğe ilk kez mi yoksa sonraki seferlerde mi erişildiğine bağlı olarak değişir:
                    </p>
                    <ul>
                        <li><strong>İlk Erişim (`IsValueCreated == false` iken):</strong>
                            <ol>
                                <li>Seçilen `LazyThreadSafetyMode`'a göre gerekli senkronizasyon (kilitleme vb.) yapılır.</li>
                                <li>Başlatma mantığı tetiklenir:
                                    <ul>
                                        <li>Eğer yapıcı metoda bir `valueFactory` (Func<T>) sağlandıysa, bu delege çağrılır.</li>
                                        <li>Eğer `valueFactory` sağlanmadıysa, `T` tipinin varsayılan parametresiz yapıcısı (`new T()`) çağrılır.</li>
                                    </ul>
                                </li>
                                <li>Başlatma mantığının döndürdüğü değer (veya oluşturulan nesne) `Lazy<T>` örneği içinde dahili olarak <strong>önbelleğe alınır</strong>.</li>
                                <li>`IsValueCreated` bayrağı `true` olarak ayarlanır.</li>
                                <li>Önbelleğe alınan değer veya nesne, özelliğin çağrıldığı yere döndürülür.</li>
                                <li>Eğer başlatma mantığı sırasında bir <strong>istisna (exception)</strong> fırlatılırsa:
                                    <ul>
                                        <li>Bu istisna yakalanır ve `Lazy<T>` örneği içinde saklanır.</li>
                                        <li>`IsValueCreated` bayrağı `false` kalır (veya bazı implementasyonlarda özel bir "hatalı" duruma geçebilir).</li>
                                        <li>Yakalanan istisna, `Value` özelliğine erişmeye çalışan koda yeniden fırlatılır (re-thrown).</li>
                                        <li><strong>Önemli:</strong> `ExecutionAndPublication` modunda, bu istisna önbelleğe alınır. `Value` özelliğine sonraki tüm erişimlerde, başlatma mantığı tekrar çalıştırılmaz; bunun yerine önbelleğe alınan aynı istisna tekrar tekrar fırlatılır. Bu, başlatma hatasının kalıcı olduğunu gösterir. Diğer modlarda davranış biraz farklı olabilir (örneğin, `PublicationOnly` modunda başka bir thread başarılı olabilir).</li>
                                    </ul>
                                </li>
                                <li>Eğer `T` için varsayılan yapıcı kullanılıyorsa ve bu yapıcı bulunamazsa `MissingMemberException`, erişilemezse `MemberAccessException` fırlatılır.</li>
                                <li>Eğer `valueFactory` kendi içinden yine aynı `Lazy<T>` örneğinin `Value` özelliğine erişmeye çalışırsa (özyinelemeli - recursive - bir durum), `System.InvalidOperationException` fırlatılır.</li>
                            </ol>
                        </li>
                        <li><strong>Sonraki Erişimler (`IsValueCreated == true` iken):</strong>
                            <ul>
                                <li>Başlatma mantığı (fabrika veya yapıcı) <strong>tekrar çalıştırılmaz</strong>.</li>
                                <li>Dahili olarak önbelleğe alınmış olan değer veya nesne doğrudan döndürülür.</li>
                                <li>Bu erişim son derece hızlıdır, çünkü sadece önbellekten okuma yapılır (minimal senkronizasyon maliyeti olabilir, moda bağlı olarak).</li>
                            </ul>
                        </li>
                    </ul>
                    <p>
                        `Value` özelliği, `Lazy<T>`'nin temel işlevselliğini sağlar: isteğe bağlı, güvenli ve önbelleğe alınmış başlatma.
                    </p>
                 </details>

                 <details class="question-block">
                    <summary><h3>`public bool IsValueCreated { get; }`: Başlatma Durumunu Kontrol Etme</h3></summary>
                    <p>
                        Bu salt okunur özellik, `Lazy<T>` örneği için bir değerin (veya nesnenin) başarılı bir şekilde oluşturulup oluşturulmadığını gösteren bir `bool` değeri döndürür.
                    </p>
                    <ul>
                        <li><strong>`false` Değeri:</strong> `Value` özelliğine henüz hiç erişilmemiş veya ilk erişim sırasında bir istisna fırlatılmış ve değer başarıyla oluşturulamamışsa `false` döndürür.</li>
                        <li><strong>`true` Değeri:</strong> `Value` özelliğine en az bir kez başarılı bir şekilde erişilmiş ve başlatma mantığı bir değer üretip bu değer önbelleğe alınmışsa `true` döndürür.</li>
                        <li><strong>Önemli Özellik:</strong> `IsValueCreated` özelliğine erişmek, başlatma işlemini <strong>tetiklemez</strong>. Bu, bir değerin oluşturulup oluşturulmadığını, onu oluşturma maliyetine katlanmadan kontrol etmek için güvenli bir yoldur.</li>
                        <li><strong>Kullanım Senaryoları:</strong>
                            <ul>
                                <li><strong>Hata Ayıklama (Debugging):</strong> Bir `Lazy<T>` örneğinin belirli bir noktada başlatılıp başlatılmadığını kontrol etmek için kullanışlıdır. Visual Studio'nun DebuggerDisplay özelliği de genellikle bu bilgiyi gösterir.</li>
                                <li><strong>Duruma Bağlı Mantık (Nadir Kullanım):</strong> Çok nadiren, bir değerin zaten oluşturulmuş olup olmamasına bağlı olarak farklı bir mantık çalıştırmak isteyebilirsiniz. Ancak bu genellikle `Lazy<T>`'nin amacına aykırıdır; `Lazy<T>`'nin güzelliği, başlatma detaylarını soyutlamasıdır. Genellikle sadece `Value`'ya erişmek yeterlidir.</li>
                                <li><strong>Kaynak Temizleme Senaryoları?:</strong> Bir `Lazy<T>` tarafından oluşturulan nesne `IDisposable` ise ve bu nesnenin sadece oluşturulduysa temizlenmesi gerekiyorsa, `IsValueCreated` kontrol edilerek `Value.Dispose()` çağrısı yapılabilir. Ancak bu manuel yönetim gerektirir ve genellikle `Lazy<T>`'nin kendisi `IDisposable` olmadığından dikkatli olunmalıdır.</li>
                            </ul>
                        </li>
                    </ul>
                     <pre><code class="language-csharp">
Lazy&lt;string&gt; lazyData = new Lazy&lt;string&gt;(() => {
    Console.WriteLine("Veri yükleniyor...");
    return "Yüklenen Veri";
});

if (!lazyData.IsValueCreated) // Başlatmayı tetiklemez
{
    Console.WriteLine("Veri henüz yüklenmedi.");
}

string data = lazyData.Value; // Şimdi yüklenir

if (lazyData.IsValueCreated) // Başlatmayı tetiklemez
{
    Console.WriteLine("Veri şimdi yüklendi.");
}
                    </code></pre>
                 </details>

                 <details class="question-block">
                    <summary><h3>`public override string ToString()`: Durum Bilgisi Veren Temsil</h3></summary>
                    <p>
                        `Lazy<T>` sınıfı, `System.Object`'ten miras aldığı `ToString()` metodunu, örneğin mevcut durumu hakkında bilgi verecek şekilde override eder.
                    </p>
                    <ul>
                        <li><strong>Değer Oluşturulmadıysa (`IsValueCreated == false`):</strong> Genellikle "Value is not created." (Değer oluşturulmadı) veya benzeri bir mesaj içeren bir string döndürür.</li>
                        <li><strong>Değer Oluşturulduysa (`IsValueCreated == true`):</strong> Önbelleğe alınan değerin (`Value` özelliğinin) kendi `ToString()` metodunu çağırır ve onun sonucunu döndürür.</li>
                        <li><strong>Önemli Not:</strong> Eğer değer oluşturulmuşsa, `ToString()` metodunu çağırmak, `Value` özelliğine erişmekle aynı etkiye sahip olabilir (eğer `Value`'nun `ToString()`'u önemli bir iş yapıyorsa). Ancak, değer henüz oluşturulmadıysa, `ToString()` başlatma işlemini <strong>tetiklemez</strong>.</li>
                        <li><strong>İstisna Durumu:</strong> Eğer `Value` null ise ve `ToString()` çağrılırsa `NullReferenceException` fırlatabilir. Eğer başlatma sırasında bir istisna oluşmuşsa, `ToString()`'un davranışı implementasyona göre değişebilir, ancak genellikle hatayı belirtir.</li>
                        <li><strong>Kullanım Amacı:</strong> Öncelikle hata ayıklama ve loglama amaçlıdır. `Lazy<T>` örneğinin o anki durumu hakkında hızlı bir fikir verir.</li>
                    </ul>
                     <pre><code class="language-csharp">
Lazy&lt;int&gt; lazyInt = new Lazy&lt;int&gt;(() => 123);

Console.WriteLine(lazyInt.ToString()); // Muhtemelen "Value is not created." yazar

int value = lazyInt.Value; // Başlatma tetiklenir

Console.WriteLine(lazyInt.ToString()); // "123" yazar (int'in ToString() sonucu)
                    </code></pre>
                 </details>
            </section>

             <section id="kullanim-senaryolari" class="content-section">
                 <h2>Pratik Kullanım Senaryoları ve Desenler</h2>
                 <p>`Lazy<T>` sınıfı, teorik faydalarının ötesinde, birçok yaygın programlama problemine zarif ve verimli çözümler sunar.</p>

                 <details class="question-block">
                     <summary><h3>1. Thread-Safe Singleton Deseni Implementasyonu</h3></summary>
                     <p>
                         Singleton deseni, bir sınıftan yalnızca tek bir örnek (instance) oluşturulmasını ve bu örneğe global bir erişim noktası sağlanmasını amaçlar. Çoklu iş parçacıklı ortamlarda Singleton'ı doğru ve güvenli bir şekilde implemente etmek zor olabilir (double-checked locking gibi teknikler karmaşık ve hataya açıktır). `Lazy<T>`, bu problemi son derece basit ve güvenilir bir şekilde çözer:
                     </p>
                     <pre><code class="language-csharp">
public sealed class MySingleton
{
    // Lazy&lt;T&gt; örneğini static ve readonly olarak tanımla.
    // valueFactory olarak private yapıcıyı çağır.
    // Varsayılan mod (ExecutionAndPublication) tam thread güvenliği sağlar.
    private static readonly Lazy&lt;MySingleton&gt; lazyInstance =
        new Lazy&lt;MySingleton&gt;(() => new MySingleton());

    // Global erişim noktası. Value'ya ilk erişimde instance oluşturulur.
    public static MySingleton Instance => lazyInstance.Value;

    // Yapıcı metodu private yaparak dışarıdan 'new' ile örnek alınmasını engelle.
    private MySingleton()
    {
        Console.WriteLine("MySingleton instance oluşturuluyor...");
        // ... Başlatma işlemleri ...
    }

    public void Log(string message)
    {
        Console.WriteLine($"Singleton Log: {message}");
    }
}

// Kullanım:
MySingleton.Instance.Log("İlk mesaj");
MySingleton.Instance.Log("İkinci mesaj");
// Yapıcı metot sadece ilk Instance erişiminde bir kez çalışır.
                     </code></pre>
                     <p>
                         Bu implementasyon:
                         <ul>
                             <li><strong>Thread-Safe'dir:</strong> `Lazy<T>`'nin varsayılan modu sayesinde, birden fazla iş parçacığı aynı anda `Instance`'a erişse bile yapıcı metot yalnızca bir kez çalıştırılır.</li>
                             <li><strong>Lazy'dir:</strong> Singleton örneği, `Instance` özelliğine ilk kez erişilene kadar oluşturulmaz. Bu, uygulama başlangıcını hızlandırabilir.</li>
                             <li><strong>Basittir:</strong> Karmaşık kilitleme kodları yazmaya gerek kalmaz.</li>
                         </ul>
                         Bu, modern .NET'te Singleton deseni implemente etmenin önerilen yollarından biridir.
                     </p>
                 </details>

                 <details class="question-block">
                    <summary><h3>2. Maliyetli Kaynakların Ertelenmiş Başlatılması</h3></summary>
                    <p>
                        Veritabanı bağlantıları, ağ servis istemcileri, büyük konfigürasyon nesneleri veya yüklenmesi uzun süren veri kümeleri gibi kaynakların başlatılması maliyetlidir ve her zaman hemen ihtiyaç duyulmayabilir.
                    </p>
                    <pre><code class="language-csharp">
public class DataAccessLayer
{
    private readonly Lazy&lt;SqlConnection&gt; _lazyConnection;
    private readonly string _connectionString;

    public DataAccessLayer(string connectionString)
    {
        _connectionString = connectionString;
        // Bağlantı, sadece gerçekten ihtiyaç duyulduğunda oluşturulacak.
        _lazyConnection = new Lazy&lt;SqlConnection&gt;(() => {
            Console.WriteLine("SqlConnection oluşturuluyor ve açılıyor...");
            var connection = new SqlConnection(_connectionString);
            connection.Open(); // Bağlantıyı açma işlemi de tembel olabilir
            return connection;
        }, LazyThreadSafetyMode.ExecutionAndPublication); // Thread-safe
    }

    public SqlConnection Connection => _lazyConnection.Value;

    public IEnumerable&lt;string&gt; GetProductNames()
    {
        // Connection özelliğine ilk erişimde bağlantı oluşturulur ve açılır.
        using (var command = new SqlCommand("SELECT Name FROM Products", Connection))
        using (var reader = command.ExecuteReader())
        {
            while (reader.Read())
            {
                yield return reader.GetString(0);
            }
        }
        // Dikkat: Bağlantının ne zaman kapatılacağı yönetilmelidir!
        // Lazy<T> IDisposable olmadığı için otomatik kapatmaz.
        // Belki ayrı bir Dispose metodu veya using bloğu gerekir.
    }

    // Belki IDisposable implementasyonu ile bağlantıyı kapatmak gerekir
    // public void Dispose() { if (_lazyConnection.IsValueCreated) _lazyConnection.Value.Dispose(); }
}

// Kullanım:
var dal = new DataAccessLayer("...");
Console.WriteLine("DataAccessLayer oluşturuldu."); // Bağlantı henüz kurulmadı

// Sadece bu çağrıda bağlantı kurulacak:
var names = dal.GetProductNames().ToList();
Console.WriteLine("Ürün adları alındı.");
                    </code></pre>
                    <p><strong>Önemli Not (IDisposable):</strong> `Lazy<T>`'nin kendisi `IDisposable` arayüzünü implemente etmez. Eğer `Lazy<T>` tarafından oluşturulan nesne (`T`) `IDisposable` ise (örneğimizdeki `SqlConnection` gibi), bu nesnenin kaynağını serbest bırakmak (yani `Dispose()` metodunu çağırmak) sizin sorumluluğunuzdadır. `Lazy<T>` bunu otomatik olarak yapmaz. Bu genellikle, `Lazy<T>`'yi içeren sınıfın kendisinin `IDisposable` olması ve `Dispose` metodunda `if (lazyInstance.IsValueCreated) lazyInstance.Value.Dispose();` kontrolünü yapmasıyla yönetilir.</p>
                </details>

                 <details class="question-block">
                    <summary><h3>3. Büyük veya Karmaşık Nesnelerin İsteğe Bağlı Yüklenmesi</h3></summary>
                     <p>
                        Bir uygulama, kullanıcının nadiren eriştiği ancak oluşturulması veya yüklenmesi bellek veya zaman açısından pahalı olan büyük veri yapılarına (örneğin, tüm ülke/şehir listesi, büyük bir rapor şablonu) sahip olabilir.
                     </p>
                     <pre><code class="language-csharp">
public class ApplicationSettings
{
    // Basit ayarlar hemen yüklenebilir
    public string Theme { get; set; } = "Default";

    // Tüm dünya ülkelerinin listesi - pahalı olabilir, tembel yükleyelim
    private readonly Lazy&lt;List&lt;Country&gt;&gt; _lazyCountries;

    public ApplicationSettings()
    {
        _lazyCountries = new Lazy&lt;List&lt;Country&gt;&gt;(() =>
        {
            Console.WriteLine("Ülke listesi veritabanından yükleniyor...");
            // ... Veritabanından veya dosyadan yükleme işlemi ...
            return LoadCountriesFromDataSource();
        });
    }

    // Ülke listesine sadece ihtiyaç duyulduğunda erişilir ve yüklenir.
    public List&lt;Country&gt; AllCountries => _lazyCountries.Value;

    private List&lt;Country&gt; LoadCountriesFromDataSource()
    {
        // Simüle edilmiş yükleme
        System.Threading.Thread.Sleep(1500);
        return new List&lt;Country&gt; { /* ... doldurulmuş liste ... */ };
    }
}

// Kullanım:
var settings = new ApplicationSettings();
Console.WriteLine($"Tema: {settings.Theme}"); // Ülke listesi henüz yüklenmedi

// Kullanıcı ülke seçme ekranını açtığında:
Console.WriteLine("Ülkeler yükleniyor...");
var countries = settings.AllCountries; // Bu satırda LoadCountriesFromDataSource çalışır
Console.WriteLine($"Toplam {countries.Count} ülke yüklendi.");
                     </code></pre>
                 </details>

                 <details class="question-block">
                    <summary><h3>4. Karmaşık Hesaplamaların Ertelenmesi</h3></summary>
                     <p>
                        Sonucu her zaman gerekmeyen ancak hesaplanması uzun süren matematiksel işlemler, veri analizleri veya simülasyonlar tembel olarak başlatılabilir.
                     </p>
                     <pre><code class="language-csharp">
public class FinancialReport
{
    private readonly Lazy&lt;decimal&gt; _lazyComplexProjection;

    public FinancialReport(InputData data)
    {
        _lazyComplexProjection = new Lazy&lt;decimal&gt;(() =>
        {
            Console.WriteLine("Karmaşık projeksiyon hesaplanıyor...");
            // ... Saatler sürebilecek bir hesaplama ...
            return CalculateComplexProjection(data);
        });
    }

    // Projeksiyon sonucuna sadece istendiğinde erişilir.
    public decimal ComplexProjection => _lazyComplexProjection.Value;

    private decimal CalculateComplexProjection(InputData data)
    {
        // ... Hesaplama mantığı ...
        System.Threading.Thread.Sleep(5000); // Simülasyon
        return 1234567.89m;
    }
}

// Kullanım:
var report = new FinancialReport(someData);
Console.WriteLine("Rapor nesnesi oluşturuldu."); // Hesaplama henüz başlamadı

// Sadece kullanıcı "Detaylı Projeksiyon Göster" butonuna tıklarsa:
Console.WriteLine("Projeksiyon hesaplanıyor...");
decimal projection = report.ComplexProjection; // Hesaplama burada yapılır
Console.WriteLine($"Projeksiyon Sonucu: {projection}");
                     </code></pre>
                 </details>
                 <p>Bu senaryolar, `Lazy<T>`'nin performans optimizasyonu ve kaynak yönetimi konularında ne kadar esnek ve güçlü bir araç olabileceğini göstermektedir.</p>
            </section>

            <section id="alternatifler-karsilastirma" class="content-section">
                <h2>Alternatifler ve Karşılaştırmalar</h2>
                <p>`Lazy<T>` tembel yükleme için standart ve genellikle en iyi yol olsa da, .NET'te benzer amaçlara hizmet eden veya ilişkili başka mekanizmalar da vardır.</p>

                <details class="question-block">
                    <summary><h3>1. Manuel Tembel Yükleme (Null Kontrolü ve Kilitleme)</h3></summary>
                    <p>
                        `Lazy<T>` öncesinde veya basit senaryolarda geliştiriciler tembel yüklemeyi manuel olarak implemente edebilirlerdi:
                    </p>
                     <pre><code class="language-csharp">
public class ManualLazyService
{
    private ExpensiveService _serviceInstance;
    private readonly object _lock = new object(); // Kilitleme için nesne

    public ExpensiveService Service
    {
        get
        {
            // Double-Checked Locking (Dikkat: Doğru implementasyonu zor!)
            if (_serviceInstance == null) // İlk kontrol (kilitsiz)
            {
                lock (_lock) // Kilit al
                {
                    if (_serviceInstance == null) // İkinci kontrol (kilitliyken)
                    {
                        Console.WriteLine("Manuel olarak başlatılıyor...");
                        _serviceInstance = new ExpensiveService();
                    }
                }
            }
            return _serviceInstance;
        }
    }
}
                    </code></pre>
                     <p>
                         <strong>Karşılaştırma:</strong>
                         <ul>
                             <li><strong>Karmaşıklık:</strong> Manuel implementasyon, özellikle iş parçacığı güvenliği (double-checked locking'in doğru yapılması gibi) açısından `Lazy<T>`'den çok daha karmaşık ve hataya açıktır.</li>
                             <li><strong>Güvenilirlik:</strong> `Lazy<T>`, .NET ekibi tarafından test edilmiş ve optimize edilmiş, kanıtlanmış bir çözümdür. Manuel kodda hata yapma riski daha yüksektir.</li>
                             <li><strong>Esneklik:</strong> `Lazy<T>`'nin farklı thread güvenlik modları gibi özellikleri manuel olarak sağlamak daha zordur.</li>
                             <li><strong>Okunabilirlik:</strong> `Lazy<T>` kullanımı kodu daha kısa ve anlaşılır kılar.</li>
                         </ul>
                         <strong>Sonuç:</strong> Modern .NET'te, manuel tembel yükleme yerine neredeyse her zaman `Lazy<T>` kullanmak tercih edilmelidir.
                     </p>
                 </details>

                 <details class="question-block">
                    <summary><h3>2. `LazyInitializer` Statik Sınıfı</h3></summary>
                    <p>
                        `System.Threading.LazyInitializer` sınıfı, `Lazy<T>`'ye benzer şekilde tembel başlatma için statik yardımcı metotlar sunar. Özellikle mevcut bir alanı (field) tembel olarak başlatmak için kullanılır.
                    </p>
                     <pre><code class="language-csharp">
public class UsingLazyInitializer
{
    private ExpensiveService _service;
    private object _syncLock = null; // Veya önceden oluşturulmuş bir kilit nesnesi

    public ExpensiveService Service
    {
        get
        {
            // EnsureInitialized metodu, _service null ise fabrika metodunu çağırır.
            // Thread güvenliğini yönetir (dahili kilit veya spin-wait kullanabilir).
            LazyInitializer.EnsureInitialized(ref _service, ref _syncLock, () => {
                 Console.WriteLine("LazyInitializer ile başlatılıyor...");
                 return new ExpensiveService();
            });
            return _service;
        }
    }
}
                    </code></pre>
                      <p>
                         <strong>Karşılaştırma:</strong>
                         <ul>
                             <li><strong>Amaç:</strong> `LazyInitializer`, özellikle mevcut bir referans tipindeki alanı (genellikle `null` ile başlar) güvenli bir şekilde başlatmak için tasarlanmıştır. `Lazy<T>` ise değerin kendisini veya nesneyi sarmalar.</li>
                             <li><strong>Kullanım:</strong> `LazyInitializer` doğrudan alan üzerinde çalışır, `Lazy<T>` ise bir sarmalayıcı nesne oluşturur. `LazyInitializer` kullanımı biraz daha düşük seviyeli hissettirebilir.</li>
                             <li><strong>Esneklik:</strong> `Lazy<T>`'nin farklı güvenlik modları ve `IsValueCreated` gibi özellikleri daha fazla esneklik sunar. `LazyInitializer`'ın seçenekleri daha sınırlıdır.</li>
                             <li><strong>Önbellekleme:</strong> Her ikisi de sonucu önbelleğe alır.</li>
                         </ul>
                         <strong>Sonuç:</strong> `Lazy<T>` genellikle daha yüksek seviyeli, daha esnek ve daha okunabilir bir çözüm sunar. `LazyInitializer`, çok özel performans gereksinimleri olan veya doğrudan alan başlatmanın daha uygun olduğu nadir durumlarda düşünülebilir.
                     </p>
                 </details>

                 <details class="question-block">
                    <summary><h3>3. `AsyncLazy&lt;T&gt;` (Asenkron Tembel Yükleme)</h3></summary>
                     <p>
                         `Lazy<T>`'nin önemli bir sınırlaması, başlatma işleminin (fabrika metodunun) <strong>senkron</strong> olması gerektiğidir. Eğer başlatma işlemi asenkron bir işlem içeriyorsa (örneğin, `await` kullanarak bir ağ çağrısı yapmak), `Lazy<T>` doğrudan kullanılamaz. `Func<T>` içinde `async/await` kullanamazsınız ve senkron bir metot içinde `.Result` veya `.Wait()` kullanmak kilitlenmelere (deadlocks) yol açabilir.
                     </p>
                     <p>
                         Bu sorunu çözmek için <strong>`AsyncLazy<T>`</strong> kavramı ortaya çıkmıştır. Ancak `AsyncLazy<T>`, .NET Base Class Library'nin (BCL) standart bir parçası <strong>değildir</strong>. Geliştiriciler genellikle kendi `AsyncLazy<T>` implementasyonlarını yazarlar veya güvenilir kütüphanelerden (örneğin, Stephen Toub'un blog yazılarındaki örnekler veya Stephen Cleary'nin AsyncEx kütüphanesi) faydalanırlar.
                     </p>
                     <p>
                         Tipik bir `AsyncLazy<T>` implementasyonu şuna benzer (kavramsal olarak):
                     </p>
                      <pre><code class="language-csharp">
// Not: Bu BCL'de yer alan bir sınıf DEĞİLDİR! Örnek bir yapı.
public class AsyncLazy&lt;T&gt; : Lazy&lt;Task&lt;T&gt;&gt; // Genellikle Lazy<Task<T>> üzerine kurulur
{
    public AsyncLazy(Func&lt;Task&lt;T&gt;&gt; taskFactory)
        : base(taskFactory, LazyThreadSafetyMode.ExecutionAndPublication) { }

    public TaskAwaiter&lt;T&gt; GetAwaiter()
    {
        return Value.GetAwaiter(); // Lazy<Task<T>>'nin Value'su olan Task'ı await edilebilir yapar
    }
}

// Kullanım:
private readonly AsyncLazy&lt;MyData&gt; _lazyData = new AsyncLazy&lt;MyData&gt;(async () => {
    Console.WriteLine("Asenkron veri yükleniyor...");
    await Task.Delay(1000); // Asenkron işlem simülasyonu
    return await LoadDataFromApiAsync();
});

public async Task&lt;MyData&gt; GetDataAsync()
{
    Console.WriteLine("Veriye erişiliyor...");
    // AsyncLazy doğrudan await edilebilir. Fabrika metodu ilk await'te çalışır.
    MyData data = await _lazyData;
    Console.WriteLine("Veri alındı.");
    return data;
}
                      </code></pre>
                     <p>
                         <strong>Karşılaştırma (`Lazy<T>` vs `AsyncLazy<T>`):</strong>
                         <ul>
                             <li>`Lazy<T>` senkron başlatma içindir.</li>
                             <li>`AsyncLazy<T>` asenkron (`async/await`) başlatma içindir.</li>
                             <li>`Lazy<T>.Value` doğrudan `T` döndürür.</li>
                             <li>`AsyncLazy<T>` genellikle `await` edilerek `T` sonucunu verir (arka planda `Task<T>` yönetir).</li>
                             <li>`AsyncLazy<T>` BCL'de yoktur, harici olarak sağlanmalıdır.</li>
                         </ul>
                         <strong>Sonuç:</strong> Başlatma işleminiz asenkron ise, `Lazy<T>` yerine uygun bir `AsyncLazy<T>` implementasyonu kullanmanız gerekir.
                     </p>
                 </details>

            </section>

            <section id="dikkat-edilmesi-gerekenler" class="content-section">
                 <h2>Önemli Notlar, Tuzaklar ve En İyi Uygulamalar</h2>
                 <p>`Lazy<T>` güçlü bir araç olsa da, etkili ve doğru kullanımı için dikkat edilmesi gereken bazı noktalar ve potansiyel tuzaklar vardır.</p>

                <details class="question-block">
                    <summary><h3>1. İstisna Yönetimi (Exception Handling)</h3></summary>
                    <p>
                        Daha önce de belirtildiği gibi, eğer `valueFactory` (veya varsayılan yapıcı) `Value`'ya ilk erişim sırasında bir istisna fırlatırsa, `ExecutionAndPublication` modunda bu istisna <strong>önbelleğe alınır</strong>. Bu şu anlama gelir:
                    </p>
                    <ul>
                        <li>`Value` özelliğine yapılan sonraki tüm erişimler, başlatma mantığını tekrar çalıştırmak yerine, önbelleğe alınan aynı istisnayı tekrar fırlatacaktır.</li>
                        <li>Bu davranış, başlatma işleminin kalıcı olarak başarısız olduğunu gösterir. "Bir dahaki sefere belki çalışır" mantığı burada işlemez.</li>
                        <li>Eğer başlatma işleminin tekrar denenebilmesini istiyorsanız (örneğin, geçici bir ağ hatası nedeniyle başarısız olduysa), `Lazy<T>`'yi doğrudan kullanamazsınız. Bu durumda, `Lazy<T>`'yi yeniden oluşturmanız veya başlatma mantığını tekrar deneyen özel bir sarmalayıcı (wrapper) sınıf yazmanız gerekebilir.</li>
                        <li>`Value` erişimini her zaman bir `try-catch` bloğu içine almak, özellikle başlatmanın başarısız olma olasılığı varsa (dış bağımlılıklar vb.), iyi bir pratiktir.</li>
                    </ul>
                    <pre><code class="language-csharp">
Lazy&lt;WebClient&gt; lazyClient = new Lazy&lt;WebClient&gt;(() => {
    Console.WriteLine("WebClient oluşturuluyor...");
    // Simüle edilmiş ağ hatası
    throw new System.Net.WebException("Bağlantı kurulamadı!");
    // return new WebClient(); // Bu satıra ulaşılamaz
});

try
{
    WebClient client1 = lazyClient.Value; // İlk erişim, WebException fırlatır
}
catch (System.Net.WebException ex)
{
    Console.WriteLine($"İlk Hata: {ex.Message}");
}

try
{
    // İstisna önbelleğe alındığı için fabrika metodu tekrar çalışmaz.
    WebClient client2 = lazyClient.Value; // İkinci erişim, aynı WebException'ı tekrar fırlatır
}
catch (System.Net.WebException ex)
{
    Console.WriteLine($"İkinci Hata: {ex.Message}");
}

Console.WriteLine($"Değer oluşturuldu mu? {lazyClient.IsValueCreated}"); // False
                    </code></pre>
                </details>

                <details class="question-block">
                    <summary><h3>2. `IDisposable` Nesneler ve Kaynak Yönetimi</h3></summary>
                    <p>
                        Tekrar vurgulamak gerekirse, `Lazy<T>` kendisi `IDisposable` değildir. Eğer `T` tipi `IDisposable` ise (örneğin `FileStream`, `SqlConnection`, `HttpClient`), `Lazy<T>` tarafından oluşturulan bu nesnenin kaynağının serbest bırakılması (yani `Dispose()` metodunun çağrılması) tamamen sizin sorumluluğunuzdadır.
                    </p>
                    <ul>
                        <li>`Lazy<T>`'yi içeren sınıfın kendisini `IDisposable` yapın.</li>
                        <li>Bu sınıfın `Dispose()` metodunda, `lazyInstance.IsValueCreated` kontrolü yaparak, eğer nesne oluşturulduysa `lazyInstance.Value.Dispose()` çağrısını yapın.</li>
                    </ul>
                     <pre><code class="language-csharp">
public class ResourceManager : IDisposable
{
    private readonly Lazy&lt;StreamWriter&gt; _lazyWriter;
    private bool _disposed = false;

    public ResourceManager(string filePath)
    {
        _lazyWriter = new Lazy&lt;StreamWriter&gt;(() =>
        {
            Console.WriteLine("StreamWriter oluşturuluyor...");
            return new StreamWriter(filePath, append: true);
        });
    }

    public void WriteData(string data)
    {
        // Value'ya ilk erişimde StreamWriter oluşturulur.
        _lazyWriter.Value.WriteLine(data);
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!_disposed)
        {
            if (disposing)
            {
                // Yönetilen kaynakları serbest bırak
                if (_lazyWriter.IsValueCreated) // Sadece oluşturulduysa Dispose et
                {
                    Console.WriteLine("StreamWriter Dispose ediliyor...");
                    _lazyWriter.Value.Dispose();
                }
            }
            // Yönetilmeyen kaynaklar burada serbest bırakılır (varsa)
            _disposed = true;
        }
    }
}

// Kullanım:
using (var manager = new ResourceManager("log.txt"))
{
    // manager henüz StreamWriter'ı oluşturmadı.
    manager.WriteData("İlk log mesajı."); // Şimdi oluşturulur ve yazılır.
    manager.WriteData("İkinci log mesajı.");
} // using bloğu bittiğinde manager.Dispose() çağrılır ve StreamWriter kapatılır.
                     </code></pre>
                </details>

                 <details class="question-block">
                    <summary><h3>3. `PublicationOnly` Modunda Yan Etkiler (Side Effects)</h3></summary>
                    <p>
                        `LazyThreadSafetyMode.PublicationOnly` modunu kullanırken çok dikkatli olunmalıdır. Eğer `valueFactory` metodunun yan etkileri varsa (örneğin, global bir durumu değiştiriyorsa, dosyaya yazıyorsa, bir API'yi çağırıyorsa), bu metot birden fazla kez çalıştırılabileceği için beklenmedik ve hatalı sonuçlar ortaya çıkabilir. Bu mod, yalnızca fabrikanın tekrar tekrar çalıştırılmasının güvenli olduğu ve yan etkisiz olduğu durumlarda tercih edilmelidir.
                    </p>
                 </details>

                <details class="question-block">
                    <summary><h3>4. Özyinelemeli Erişim (Recursive Access)</h3></summary>
                    <p>
                        Bir `valueFactory` delegesi, kendi tanımlandığı `Lazy<T>` örneğinin `Value` özelliğine doğrudan veya dolaylı olarak erişmeye çalışırsa, bu sonsuz bir döngüye yol açacağı için `System.InvalidOperationException` fırlatılır.
                    </p>
                    <pre><code class="language-csharp">
Lazy&lt;string&gt; recursiveLazy = null; // Önce null ata
recursiveLazy = new Lazy&lt;string&gt;(() => {
    Console.WriteLine("Recursive factory çalışıyor...");
    // HATA: Kendi Value'suna erişmeye çalışıyor!
    return "Değer: " + recursiveLazy.Value; // InvalidOperationException fırlatır
});

try
{
    string value = recursiveLazy.Value;
}
catch(InvalidOperationException ex)
{
    Console.WriteLine($"Hata: {ex.Message}");
}
                    </code></pre>
                </details>

                 <details class="question-block">
                    <summary><h3>5. Closure (Kapanış) Davranışları</h3></summary>
                    <p>
                        `valueFactory` olarak kullanılan lambda ifadeleri, tanımlandıkları kapsamdaki değişkenleri yakalar (closure). Bu genellikle kullanışlıdır, ancak dikkatli olunması gereken durumlar vardır:
                    </p>
                    <ul>
                        <li><strong>Değişken Ömrü:</strong> Yakalanan değişkenlerin ömrü, `Lazy<T>` örneğinin ömrü kadar (veya daha fazla) uzayabilir. Bu, beklenenden daha fazla belleğin tutulmasına neden olabilir.</li>
                        <li><strong>Değişen Değerler:</strong> Eğer yakalanan değişkenin değeri, `valueFactory` çalıştırılmadan önce değişirse, fabrika çalıştığında bu <i>değişmiş</i> değeri kullanır. Bu, beklenen davranış olabilir ancak bazen kafa karıştırıcı olabilir.</li>
                    </ul>
                    <pre><code class="language-csharp">
int counter = 5;
Lazy&lt;string&gt; lazyWithClosure = new Lazy&lt;string&gt;(() => {
    Console.WriteLine("Factory çalışıyor, counter = " + counter);
    return $"Sayaç değeri: {counter}";
});

counter = 10; // Değişkenin değeri factory çalışmadan önce değişti

Console.WriteLine(lazyWithClosure.Value); // Çıktı: "Factory çalışıyor, counter = 10" ve "Sayaç değeri: 10"
                    </code></pre>
                </details>

                <details class="question-block">
                    <summary><h3>6. Performans: Ne Zaman Endişelenmeli?</h3></summary>
                    <p>
                        Daha önce belirtildiği gibi, `Lazy<T>`'nin getirdiği ek yük (özellikle `ExecutionAndPublication` modunda) çoğu uygulama için ihmal edilebilir düzeydedir. Ancak, saniyede milyonlarca kez erişilen çok yüksek performans gerektiren kod yollarında (hot paths) bu ek yük fark yaratabilir.
                    </p>
                    <ul>
                        <li><strong>Önce Ölçün:</strong> Performans konusunda endişeleriniz varsa, varsayımlara dayanmak yerine bir profil aracı (profiler) kullanarak uygulamanızdaki gerçek darboğazları tespit edin. Sorunun gerçekten `Lazy<T>`'nin ek yükünden kaynaklandığından emin olun.</li>
                        <li><strong>Modu Gözden Geçirin:</strong> Eğer `Lazy<T>` bir darboğaz ise ve koşullar uygunsa (`None` için tek thread garantisi veya `PublicationOnly` için yan etkisiz fabrika), güvenlik modunu değiştirmeyi düşünebilirsiniz.</li>
                        <li><strong>Alternatifleri Değerlendirin:</strong> Çok ekstrem durumlarda `LazyInitializer` veya dikkatle yazılmış manuel bir mekanizma daha iyi performans verebilir, ancak bu genellikle son çare olmalıdır ve güvenlik riskleri göz önünde bulundurulmalıdır.</li>
                        <li><strong>Genellikle Sorun Başka Yerde:</strong> Çoğu zaman performans sorunları, `Lazy<T>`'nin kendisinden ziyade, `valueFactory`'nin yaptığı işin (algoritma, G/Ç, veritabanı sorgusu vb.) verimsiz olmasından kaynaklanır. Optimizasyona oradan başlamak genellikle daha etkilidir.</li>
                    </ul>
                </details>

            </section>

            <section id="sonuc" class="content-section conclusion-section">
                <h2>Sonuç: Erdemli Tembellik ile Daha İyi Yazılımlar</h2>
                <p>
                    `System.Lazy<T>`, .NET geliştiricisinin cephaneliğindeki küçük ama keskin bir kılıç gibidir. Tembel yükleme prensibini zarif, güvenli ve standart bir şekilde uygulayarak, uygulamalarımızın performansını optimize etmemize, kaynakları daha verimli kullanmamıza ve kodumuzu daha temiz hale getirmemize olanak tanır. Erken yüklemenin getirdiği yavaş başlangıç süreleri, gereksiz kaynak tüketimi ve potansiyel kırılganlıklar gibi sorunlara karşı etkili bir çözüm sunar.
                </p>
                <p>
                    Farklı yapıcı metotları ve özellikle `LazyThreadSafetyMode` seçenekleri, `Lazy<T>`'nin davranışını çok çeşitli senaryolara uyacak şekilde ince ayarlamamıza imkan verir. `None` modu en yüksek hızı sunarken risk taşır, `PublicationOnly` modu yan etkisiz fabrikalar için bir performans optimizasyonu sunarken dikkatli kullanım gerektirir, `ExecutionAndPublication` ise varsayılan olarak en yüksek güvenliği sağlar. Doğru modu seçmek, uygulamanın hem doğruluğu hem de performansı açısından kritiktir.
                </p>
                <p>
                    Thread-safe Singleton implementasyonundan maliyetli kaynakların ertelenmiş başlatılmasına, isteğe bağlı veri yüklemeden karmaşık hesaplamaların ertelenmesine kadar birçok pratik kullanım alanı bulunan `Lazy<T>`, modern .NET uygulamalarının ayrılmaz bir parçası haline gelmiştir. İstisna yönetimi ve `IDisposable` kaynakların yönetimi gibi dikkat edilmesi gereken noktalar olsa da, sağladığı faydalar genellikle bu dikkat gereksinimini fazlasıyla karşılar.
                </p>
                <p>
                    Sonuç olarak, `Lazy<T>`'yi anlamak ve doğru bir şekilde kullanmak, sadece anlık performans sorunlarını çözmekle kalmaz, aynı zamanda daha sağlam, daha ölçeklenebilir ve bakımı daha kolay yazılımlar tasarlama yeteneğimizi de geliştirir. Bu "erdemli tembellik" aracı, kodumuzda gereksiz işleri erteleyerek, gerçekten önemli olan anlara odaklanmamızı sağlar ve .NET ile yazılım geliştirme sanatında ustalığa giden yolda önemli bir adımdır.
                </p>
            </section>

        </main>
    </div>

    <footer class="footer">
        <a href="https://abdulkadirgungor86.github.io/cv/" target="_blank" rel="noopener noreferrer">© 2025 Abdulkadir Güngör</a><br/>
        <a href="https://abdulkadirgungor86.github.io/sitemap.xml" target="_blank" rel="noopener noreferrer">Sitemap (XML)</a>
    </footer>
    <script src="../assets/js/blog_script.js"></script>
</body>
</html>
