<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="siteTitle">Yazılımın Geleceği ve Yükselen Trendler: Bir Geliştirici Rehberi</title>
    <meta name="description" content="Yazılım geliştirmenin geleceğini şekillendiren teknolojiler ve trendler üzerine kapsamlı bir rehber. Yapay Zeka ve Makine Öğrenmesi (AI/ML), WebAssembly (WASM), Low-Code/No-Code platformları ve Blockchain teknolojilerinin yazılıma etkileri, kullanım alanları ve gelecek potansiyelleri detaylı olarak incelenmektedir. Abdulkadir Güngör tarafından hazırlanmıştır.">
    <meta name="keywords" content="Yazılım Trendleri, Geleceğin Teknolojileri, Yapay Zeka, AI, Makine Öğrenmesi, ML, GitHub Copilot, WebAssembly, WASM, Low-Code, No-Code, Blockchain, Kripto, Akıllı Kontrat, Smart Contract, Web3, Yazılım Geliştirme, Teknoloji Trendleri, Programlama Geleceği, Abdulkadir Güngör">
    <meta name="author" content="Abdulkadir Güngör">
    <link rel="canonical" href="https://abdulkadirgungor86.github.io/blog/blog_page_22.html" />

    <link rel="icon" type="image/png" href="../assets/images/icons/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="../assets/images/icons/favicon.svg" />
    <link rel="shortcut icon" href="../assets/images/icons/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="../assets/images/icons/apple-touch-icon.png" />
    <link rel="manifest" href="../assets/images/icons/site.webmanifest" />

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="../assets/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <link rel="sitemap" type="application/xml" title="Sitemap" href="https://abdulkadirgungor86.github.io/sitemap.xml">
    <link rel="sitemap" type="text/html" title="HTML Sitemap" href="https://abdulkadirgungor86.github.io/sitemap.html">
    
    <script type="application/ld+json" id="siteData">
    {
      "@context": "https://schema.org",
      "@type": "Article", 
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://abdulkadirgungor86.github.io/blog/blog_page_22.html"
      },
      "headline": "Yazılımın Geleceği ve Yükselen Trendler: Bir Geliştirici Rehberi",
      "name": "Yazılımın Geleceği ve Yükselen Trendler | Abdulkadir Güngör", 
      "author": {
        "@type": "Person",
        "name": "Abdulkadir Güngör"
      },
      "publisher": {
        "@type": "Organization",
        "name": "Abdulkadir Güngör",
        "logo": {
          "@type": "ImageObject",
          "url": "https://abdulkadirgungor86.github.io/assets/images/icons/favicon-96x96.png" 
        }
      },
      "datePublished": "2025-05-13", 
      "dateModified": "2025-05-13", 
      "description": "Yazılım geliştirmenin geleceğini şekillendiren teknolojiler ve trendler üzerine kapsamlı bir rehber.",
      "isPartOf": {
        "@type": "WebSite",
        "@id": "https://abdulkadirgungor86.github.io/"
      },
      "footerText": "© {YEAR} Abdulkadir Güngör. Tüm Hakları Saklıdır." 
    }
    </script>

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-5GFQC3DYZF"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-5GFQC3DYZF');
    </script>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-5L6M34JW');</script>
    
</head>
<body id="pageTop"> 
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5L6M34JW"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    
    <main class="section-padding">
        <div class="container">
            <article id="giris" class="content-section intro-section">
                <h1>Yazılımın Ufukları: Geleceği Şekillendiren Trendler ve Teknolojiler</h1>
                <p>
                    Yazılım geliştirme dünyası, belki de tarihin hiçbir döneminde olmadığı kadar hızlı bir dönüşüm ve evrim sürecinden geçiyor. Her gün yeni teknolojiler filizleniyor, mevcut paradigmalar sorgulanıyor ve geliştiricilerin çalışma şekilleri kökten değişiyor. Bu dinamik ortamda, sadece mevcut araçlara hakim olmak yeterli değil; aynı zamanda ufukta beliren trendleri anlamak, potansiyel etkilerini öngörmek ve geleceğin teknolojilerine hazırlıklı olmak, başarılı bir kariyer için kritik önem taşıyor. Yapay Zekanın kodlama süreçlerine entegrasyonundan, web'in performans sınırlarını zorlayan WebAssembly'e, yazılım geliştirmeyi demokratikleştiren Low-Code/No-Code platformlarından, güven ve şeffaflık vaadiyle gelen Blockchain teknolojilerine kadar birçok yenilik, yazılımın geleceğini şekillendiriyor.
                </p>
                <p>
                    Yapay Zeka (AI) ve Makine Öğrenmesi (ML), artık sadece akademik araştırma konuları olmaktan çıkıp, kodlama asistanları (GitHub Copilot gibi), otomatik hata ayıklama, akıllı test üretimi gibi araçlarla geliştiricilerin günlük iş akışlarına doğrudan etki etmeye başladı. ML modellerinin uygulamalara entegrasyonu ise yazılımlara daha önce görülmemiş yetenekler kazandırıyor. WebAssembly (WASM), C++, Rust gibi dillerde yazılmış yüksek performanslı kodların web tarayıcılarında neredeyse yerel hızda çalıştırılmasına olanak tanıyarak, web'in yeteneklerini oyunlar, video düzenleme ve bilimsel hesaplamalar gibi alanlara taşıyor.
                </p>
                 <p>
                    Diğer yandan, Low-Code/No-Code platformları, geleneksel kodlama bilgisine sahip olmayan kişilerin bile sürükle-bırak arayüzleri ve görsel modelleme araçlarıyla iş uygulamaları oluşturmasını mümkün kılarak yazılım geliştirme sürecini demokratikleştiriyor ve hızlandırıyor. Bu durum, profesyonel geliştiricilerin rolünü de yeniden şekillendirme potansiyeli taşıyor. Son olarak, Blockchain ve ilişkili kripto teknolojileri, merkeziyetsiz uygulamalar (dApps), akıllı kontratlar ve Web3 vizyonuyla, verinin sahipliği, güvenliği ve şeffaflığı konularında yeni paradigmalar sunuyor. Bu rehber, yazılım geliştirmenin geleceğine yön veren bu dört ana akımı (AI/ML, WASM, Low-Code/No-Code, Blockchain) derinlemesine inceleyecek, temel kavramlarını açıklayacak, potansiyel etkilerini tartışacak ve geliştiricilerin bu yeni döneme nasıl hazırlanabileceğine dair bir perspektif sunacaktır.
                </p>
            </article>

            <section id="ai-ml" class="content-section">
                <h2>Yapay Zeka ve Makine Öğrenmesinin Yazılıma Etkisi: Akıllı Kodlama ve Ötesi</h2>
                <p>
                    Yapay Zeka (AI) ve onun bir alt dalı olan Makine Öğrenmesi (ML), son yıllarda teknoloji dünyasında devrim yaratırken, yazılım geliştirme süreçlerini ve geliştiricilerin çalışma şekillerini de derinden etkilemeye başladı. Artık sadece uygulamalara akıllı özellikler katmakla kalmıyor, aynı zamanda kod yazma, test etme, hata ayıklama ve hatta proje yönetimi gibi geliştirme yaşam döngüsünün birçok aşamasında geliştiricilere yardımcı oluyorlar.
                </p>

                <details class="question-block">
                    <summary><h3>AI Destekli Kodlama Araçları (Copilot, Tabnine vb.)</h3></summary>
                    <p>Yapay zeka destekli kodlama asistanları, geliştiricilerin kod yazma sürecini hızlandırmayı ve kolaylaştırmayı amaçlayan araçlardır. Bu araçlar, genellikle büyük dil modellerini (LLM'ler - Large Language Models) temel alır ve milyonlarca satır açık kaynak koddan öğrenerek geliştiricilere kod önerileri sunar, kod parçacıkları tamamlar ve hatta bazen basit fonksiyonları veya testleri tamamen yazabilirler.</p>
                    <p><strong>Popüler Araçlar:</strong></p>
                    <ul>
                        <li><strong>GitHub Copilot:</strong> OpenAI'nin Codex modeli (GPT tabanlı) üzerine kurulu, en popüler araçlardan biridir. Kod editörüne (VS Code, JetBrains IDE'leri vb.) entegre olur ve yorumlardan veya yazılmaya başlanan koddan yola çıkarak kod satırları veya tüm fonksiyonlar önerebilir.</li>
                        <li><strong>Tabnine:</strong> Farklı modeller kullanan ve hem bulut tabanlı hem de yerel çalışma seçenekleri sunan bir başka popüler kod tamamlama aracıdır.</li>
                        <li><strong>Amazon CodeWhisperer:</strong> AWS tarafından sunulan, güvenlik taraması gibi ek özellikler de içeren bir kodlama asistanıdır.</li>
                        <li><strong>Google Cloud Code AI / Duet AI for Developers:</strong> Google Cloud platformuyla entegre AI destekli geliştirme araçları.</li>
                    </ul>
                    <p><strong>Nasıl Çalışırlar?</strong> Bu araçlar, geliştiricinin yazdığı kodu ve çevresindeki bağlamı (yorumlar, dosya adı, diğer açık dosyalar) analiz eder. Ardından, eğitildikleri devasa kod veri tabanındaki desenlere dayanarak bir sonraki en olası kod parçasını tahmin eder ve öneri olarak sunar.</p>
                    <p><strong>Avantajları:</strong></p>
                    <ul>
                        <li><strong>Hız ve Verimlilik Artışı:</strong> Tekrarlayan kodları (boilerplate) veya standart algoritmaları hızla yazmayı sağlar.</li>
                        <li><strong>Yeni Şeyler Öğrenme:</strong> Farklı kütüphanelerin veya dil özelliklerinin nasıl kullanılacağına dair örnekler sunabilir.</li>
                        <li><strong>Daha Az Yazım Hatası:</strong> Kod tamamlama özelliği basit yazım hatalarını azaltabilir.</li>
                        <li><strong>Odaklanmayı Artırma:</strong> Geliştiricinin daha çok problem çözme ve tasarım gibi üst düzey görevlere odaklanmasını sağlayabilir.</li>
                    </ul>
                    <p><strong>Dezavantajları ve Riskleri:</strong></p>
                    <ul>
                        <li><strong>Kod Kalitesi ve Doğruluğu:</strong> Önerilen kod her zaman doğru, verimli veya güvenli olmayabilir. Geliştiricinin önerilen kodu dikkatlice incelemesi ve anlaması gerekir.</li>
                        <li><strong>Güvenlik Açıkları:</strong> Araç, eğitildiği verideki güvensiz kodlama pratiklerini içeren kodlar önerebilir.</li>
                        <li><strong>"Kara Kutu" Etkisi:</strong> Kodun nasıl çalıştığını tam olarak anlamadan sadece önerileri kabul etmek, geliştiricinin öğrenme sürecini engelleyebilir ve bakım zorlukları yaratabilir.</li>
                        <li><strong>Lisanslama ve Fikri Mülkiyet:</strong> Önerilen kodun kaynağı bazen belirsiz olabilir ve açık kaynak lisanslarıyla ilgili potansiyel sorunlar ortaya çıkabilir (GitHub Copilot bu konuda filtreleme mekanizmaları sunmaktadır).</li>
                        <li><strong>Bağımlılık Yaratma:</strong> Geliştiricilerin temel problem çözme ve kodlama becerilerini zayıflatma potansiyeli.</li>
                    </ul>
                    <p>AI destekli kodlama araçları güçlü yardımcılardır ancak eleştirel düşünme ve dikkatli inceleme ile birlikte kullanılmalıdırlar. Geliştiricinin yerini almaktan çok, yeteneklerini artıran birer "yardımcı pilot" olarak görülmelidirler.</p>
                      <pre><code class="language-python">
# GitHub Copilot Örneği (Yorumdan Kod Üretme)

# Python'da bir listedeki tüm çift sayıları bulan bir fonksiyon yaz
# --- Copilot Önerisi (muhtemel) ---
# def cift_sayilari_bul(liste):
#     ciftler = []
#     for sayi in liste:
#         if sayi % 2 == 0:
#             ciftler.append(sayi)
#     return ciftler

# --- Veya daha Pythonic bir öneri ---
# def cift_sayilari_bul_comprehension(liste):
#     return [sayi for sayi in liste if sayi % 2 == 0]

# Kullanıcının öneriyi kabul etmesi veya düzenlemesi gerekir.
                    </code></pre>
                </details>

                <details class="question-block">
                    <summary><h3>ML Modellerini Uygulamalara Entegre Etme</h3></summary>
                    <p>Yapay zeka ve makine öğrenmesinin bir diğer önemli etkisi, eğitilmiş ML modellerinin çeşitli uygulamalara entegre edilerek onlara akıllı yetenekler kazandırılmasıdır. Görüntü tanıma, doğal dil işleme (NLP), öneri sistemleri, anomali tespiti gibi birçok alanda ML modelleri kullanılmaktadır.</p>
                    <p><strong>Entegrasyon Yöntemleri:</strong></p>
                    <ul>
                        <li><strong>API Çağrıları (Bulut Tabanlı ML Servisleri):</strong> En yaygın yöntemlerden biridir. Model, AWS SageMaker, Azure Machine Learning, Google AI Platform gibi bir bulut platformunda veya özel bir sunucuda barındırılır ve uygulama bu modele API (genellikle RESTful) üzerinden istek göndererek tahmin alır.
                            <ul>
                                <li><strong>Avantajları:</strong> Uygulama kodunu basit tutar, modelin eğitimi ve yönetimi ayrı yapılır, ölçeklenebilirlik kolaydır.</li>
                                <li><strong>Dezavantajları:</strong> Ağ gecikmesi performansı etkileyebilir, internet bağlantısı gerektirir, API kullanım maliyetleri olabilir.</li>
                            </ul>
                        </li>
                        <li><strong>Modeli Uygulamaya Gömme (On-Device/Edge ML):</strong> Eğitilmiş model (genellikle optimize edilmiş bir formatta - örn. TensorFlow Lite, ONNX, Core ML) doğrudan istemci uygulamasına (mobil, web tarayıcısı, IoT cihazı) veya sunucu uygulamasına dahil edilir. Tahminler cihaz üzerinde yapılır.
                            <ul>
                                <li><strong>Avantajları:</strong> Düşük gecikme süresi, çevrimdışı çalışabilme, veri gizliliği (veriler cihazdan ayrılmaz).</li>
                                <li><strong>Dezavantajları:</strong> Modelin boyutu uygulama boyutunu artırabilir, cihaz kaynaklarını (CPU, RAM, pil) tüketebilir, modeli güncellemek için uygulamanın güncellenmesi gerekebilir.</li>
                            </ul>
                        </li>
                        <li><strong>Veritabanı İçinde ML:</strong> Bazı modern veritabanları (örn. PostgreSQL eklentileri, SQL Server Machine Learning Services) doğrudan veritabanı içinde ML modellerini çalıştırma yeteneği sunar.</li>
                    </ul>
                     <p><strong>Kullanılan Kütüphane ve Araçlar:</strong></p>
                     <ul>
                         <li><strong>Python (Backend/Eğitim):</strong> Scikit-learn, TensorFlow, PyTorch, Keras (Model eğitimi ve API oluşturma - Flask/Django/FastAPI ile).</li>
                         <li><strong>JavaScript (Frontend/Backend):</strong> TensorFlow.js (Tarayıcıda ve Node.js'de model çalıştırma), ONNX.js (ONNX modellerini çalıştırma).</li>
                         <li><strong>Mobil:</strong> TensorFlow Lite (Android/iOS), Core ML (iOS), ML Kit (Android/iOS).</li>
                         <li><strong>Model Formatları:</strong> SavedModel (TensorFlow), ONNX (Open Neural Network Exchange - farklı framework'ler arası taşınabilirlik), HDF5 (Keras).</li>
                     </ul>
                      <p><strong>Zorluklar:</strong></p>
                      <ul>
                        <li><strong>Veri Yönetimi ve Ön İşleme:</strong> Modelin beklediği formatta veriyi hazırlamak.</li>
                        <li><strong>Model Sürümleme ve Yönetimi (MLOps):</strong> Farklı model sürümlerini takip etmek, dağıtmak ve izlemek.</li>
                        <li><strong>Performans Optimizasyonu:</strong> Modelin tahmin süresini (inference time) ve kaynak kullanımını optimize etmek.</li>
                        <li><strong>İzleme ve Güncelleme:</strong> Modelin performansını üretim ortamında izlemek ve gerektiğinde yeniden eğitip güncellemek.</li>
                        <li><strong>Etik ve Güvenlik:</strong> Modelin adil olması (bias), açıklanabilirliği ve kötüye kullanıma karşı güvenliği.</li>
                      </ul>
                       <pre><code class="language-javascript">
// TensorFlow.js ile Tarayıcıda Basit Model Kullanımı (Konsept)

// <html>
// <body>
//   <img id="resim" src="kedi.jpg" width="200">
//   <div id="sonuc">Tahmin bekleniyor...</div>

//   <!-- TensorFlow.js ve MobileNet modelini yükle -->
//   <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
//   <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet"></script>

//   <script>
//     const imgElement = document.getElementById('resim');
//     const sonucDiv = document.getElementById('sonuc');

//     async function tahminEt() {
//       try {
//         console.log('Model yükleniyor...');
//         const model = await mobilenet.load(); // Önceden eğitilmiş modeli yükle
//         console.log('Model yüklendi.');

//         console.log('Tahmin yapılıyor...');
//         const predictions = await model.classify(imgElement); // Resim üzerinde tahmin yap
//         console.log('Tahminler:', predictions);

//         if (predictions &amp;&amp; predictions.length > 0) {
//           sonucDiv.textContent = `Tahmin: ${predictions[0].className} (${(predictions[0].probability * 100).toFixed(1)}%)`;
//         } else {
//           sonucDiv.textContent = 'Tahmin yapılamadı.';
//         }
//       } catch (error) {
//         console.error("Hata:", error);
//         sonucDiv.textContent = 'Bir hata oluştu.';
//       }
//     }

//     imgElement.onload = tahminEt; // Resim yüklendiğinde tahmini başlat
//   </script>
// </body>
// </html>
                       </code></pre>
                      <p>AI ve ML'nin yazılım geliştirmeye entegrasyonu giderek artacak ve geliştiricilerin bu teknolojilere aşina olması önem kazanacaktır.</p>
                </details>
            </section>

            <section id="wasm" class="content-section">
                 <h2>WebAssembly (WASM): Web'de Yerel Hız Performansı</h2>
                 <p>
                    WebAssembly (kısaca WASM), modern web tarayıcılarında çalışabilen, taşınabilir, düşük seviyeli, kompakt bir ikili (binary) komut formatıdır. JavaScript'in yanında, web üzerinde yüksek performans gerektiren kodları çalıştırmak için tasarlanmıştır. C, C++, Rust gibi dillerde yazılmış kodların derlenerek web tarayıcılarında neredeyse yerel hızda çalıştırılmasına olanak tanır.
                 </p>

                 <details class="question-block">
                     <summary><h3>WASM Nedir ve Nasıl Çalışır?</h3></summary>
                     <p>WASM, bir programlama dili değil, bir <strong>derleme hedefidir</strong>. Yani, genellikle doğrudan WASM kodu yazmak yerine, C, C++, Rust, Go (deneysel), C# (Blazor ile) gibi dillerde yazılan kodlar, Emscripten, WASM-Pack gibi araçlar kullanılarak WASM bytecode'una derlenir.</p>
                     <p>Çalışma Mantığı:</p>
                     <ol>
                         <li>Yüksek seviyeli dilde (örn. C++) kod yazılır.</li>
                         <li>Bu kod, bir WASM derleyicisi (örn. Emscripten) ile <code>.wasm</code> uzantılı ikili dosyaya ve genellikle bu WASM modülünü yükleyip JavaScript ile etkileşime geçmesini sağlayan bir JavaScript "glue" (yapıştırıcı) koduna (<code>.js</code>) derlenir.</li>
                         <li>HTML sayfasından JavaScript kullanılarak <code>.wasm</code> modülü yüklenir ve başlatılır (instantiate edilir).</li>
                         <li>JavaScript, WASM modülü tarafından dışa aktarılan (exported) fonksiyonları çağırabilir.</li>
                         <li>WASM modülü de, JavaScript tarafından kendisine sağlanan (imported) fonksiyonları (örneğin DOM manipülasyonu veya API çağrıları için) çağırabilir.</li>
                     </ol>
                     <p>WASM kodu, tarayıcı içinde güvenli bir sanal alanda (sandbox) çalışır, yani doğrudan işletim sistemine veya dosya sistemine erişimi yoktur (WASI bu durumu değiştirmeyi hedefler).</p>
                 </details>

                 <details class="question-block">
                     <summary><h3>Ne Vaat Ediyor? Avantajları</h3></summary>
                     <ul>
                         <li><strong>Performans:</strong> WASM, JavaScript'e göre genellikle çok daha hızlı çalışır (özellikle CPU-yoğun işlemlerde). İkili formatı sayesinde indirmesi ve ayrıştırması (parse) JavaScript'e göre daha hızlıdır ve optimize edilmiş makine koduna daha verimli bir şekilde derlenebilir.</li>
                         <li><strong>Taşınabilirlik:</strong> WASM ikili formatı platformdan bağımsızdır ve tüm modern tarayıcılarda (ve hatta Node.js gibi tarayıcı dışı ortamlarda) çalışabilir.</li>
                         <li><strong>Dil Çeşitliliği:</strong> Geliştiricilerin C, C++, Rust gibi farklı dillerdeki uzmanlıklarını ve mevcut kod tabanlarını web'e taşımalarına olanak tanır.</li>
                         <li><strong>Öngörülebilir Performans:</strong> JavaScript'in JIT (Just-In-Time) derlemesindeki bazı belirsizliklerin aksine, WASM genellikle daha öngörülebilir bir performans sunar.</li>
                         <li><strong>Kompaktlık:</strong> İkili formatı sayesinde genellikle eşdeğer JavaScript kodundan daha küçüktür (indirme süresini kısaltır).</li>
                         <li><strong>Güvenlik:</strong> Güvenli bir sanal alanda (sandbox) çalışır ve yetenekleri (örn. DOM erişimi) JavaScript aracılığıyla kontrol edilir.</li>
                     </ul>
                 </details>

                 <details class="question-block">
                     <summary><h3>Kullanım Alanları</h3></summary>
                     <p>WASM, özellikle performansın kritik olduğu veya mevcut C/C++ gibi kod tabanlarının web'e taşınmasının istendiği alanlarda parlar:</p>
                     <ul>
                         <li><strong>Web Tabanlı Oyunlar:</strong> Yüksek performanslı grafikler ve fizik motorları (Unity, Unreal Engine web'e export ederken WASM kullanır).</li>
                         <li><strong>Video ve Ses İşleme/Düzenleme:</strong> Tarayıcıda gerçek zamanlı video/ses efektleri uygulama, kodlama/kod çözme (encoding/decoding).</li>
                         <li><strong>CAD ve 3D Modelleme Yazılımları:</strong> Karmaşık görselleştirmeler ve hesaplamalar (örn: Figma, AutoCAD Web).</li>
                         <li><strong>Bilimsel Simülasyonlar ve Hesaplamalar:</strong> Yoğun matematiksel işlemler gerektiren uygulamalar.</li>
                         <li><strong>Kriptografi Kütüphaneleri:</strong> Performans kritik şifreleme/hash algoritmaları.</li>
                         <li><strong>Mevcut Masaüstü Uygulamalarını Web'e Taşıma:</strong> C/C++ ile yazılmış kütüphaneleri veya uygulamaları web'de çalıştırma.</li>
                         <li><strong>Performans Kritik Kütüphaneler:</strong> Belirli algoritmaları veya veri işleme görevlerini hızlandırma.</li>
                         <li><strong>Platformlar Arası Geliştirme:</strong> .NET Blazor gibi framework'ler C# kodunu WASM ile tarayıcıda çalıştırır.</li>
                     </ul>
                 </details>

                 <details class="question-block">
                    <summary><h3>JavaScript ile Etkileşimi ve Geleceği</h3></summary>
                    <p>WASM, JavaScript'in yerini almak için değil, onu <strong>tamamlamak</strong> için tasarlanmıştır. Web'in temel dili hala JavaScript'tir ve WASM'ın web platformuyla (DOM, Web API'leri) etkileşime girmesi genellikle JavaScript aracılığıyla olur.</p>
                    <ul>
                        <li>JavaScript, WASM modüllerini yükler, başlatır ve fonksiyonlarını çağırır.</li>
                        <li>WASM, dış dünyayla (DOM, ağ istekleri vb.) iletişim kurmak için JavaScript'e fonksiyonlar çağırabilir.</li>
                        <li>DOM manipülasyonu gibi UI odaklı görevler genellikle JavaScript ile daha kolay ve verimlidir. WASM daha çok hesaplama yoğun (CPU-bound) işler için uygundur.</li>
                    </ul>
                    <p><strong>Geleceği ve Zorluklar:</strong></p>
                    <ul>
                        <li><strong>Ekosistem ve Araçlar:</strong> WASM ekosistemi hızla gelişiyor ancak hala JavaScript kadar olgun değil. Derleme ve hata ayıklama araçları gelişmeye devam ediyor.</li>
                        <li><strong>DOM Erişimi:</strong> WASM'ın doğrudan DOM'a erişimi şu anda verimli değil, genellikle JavaScript köprüsü gerektiriyor. Bu alanda iyileştirmeler (Interface Types gibi) bekleniyor.</li>
                        <li><strong>WASI (WebAssembly System Interface):</strong> WASM'ın tarayıcı dışında, işletim sistemi kaynaklarına (dosya sistemi, ağ soketleri vb.) standart bir şekilde erişmesini sağlamayı hedefleyen bir arayüzdür. Bu, WASM'ı sunucu tarafında, edge computing'de ve diğer ortamlarda daha yetenekli hale getirebilir.</li>
                        <li><strong>Çoklu Thread Desteği, GC Entegrasyonu:</strong> Bu konularda da çalışmalar devam etmektedir.</li>
                    </ul>
                    <p>WebAssembly, web platformunun yeteneklerini önemli ölçüde artıran ve gelecekte daha da yaygınlaşması beklenen heyecan verici bir teknolojidir.</p>
                 </details>
            </section>

            <section id="lc-nc" class="content-section">
                 <h2>Low-Code / No-Code Platformlar: Yazılım Geliştirmenin Demokratikleşmesi mi?</h2>
                 <p>Low-Code ve No-Code (LC/NC) platformları, geleneksel programlama dilleriyle uzun kodlar yazmak yerine, görsel arayüzler, sürükle-bırak bileşenler, hazır şablonlar ve konfigürasyon tabanlı yaklaşımlar kullanarak uygulama geliştirmeyi sağlayan araçlardır. Amaçları, yazılım geliştirme sürecini hızlandırmak, basitleştirmek ve daha geniş bir kitleye (teknik olmayan kullanıcılar dahil) açmaktır.</p>

                 <details class="question-block">
                     <summary><h3>Low-Code vs No-Code Farkı Nedir?</h3></summary>
                     <ul>
                         <li><strong>No-Code:</strong> Hedef kitlesi genellikle iş kullanıcıları, analistler veya "citizen developer" olarak adlandırılan, hiç kodlama bilgisi olmayan kişilerdir. Tamamen görsel arayüzler ve hazır bileşenlerle, kod yazmadan basit iş akışları, formlar, web siteleri veya temel uygulamalar oluşturmayı sağlar. Esneklik ve özelleştirme genellikle sınırlıdır. (Örnekler: Zapier, Airtable, Google AppSheet, Bubble (bazı özellikleri low-code'a kayabilir)).</li>
                         <li><strong>Low-Code:</strong> Hem profesyonel geliştiricilere hem de teknik bilgisi olan iş kullanıcılarına hitap eder. Görsel geliştirme araçlarının yanı sıra, gerektiğinde özel kod (JavaScript, Python, SQL vb.) yazarak platformun yeteneklerini genişletme ve özelleştirme imkanı sunar. No-Code'a göre daha karmaşık uygulamalar ve entegrasyonlar oluşturmaya olanak tanır. (Örnekler: OutSystems, Mendix, Microsoft Power Apps, Salesforce Platform, Retool).</li>
                     </ul>
                     <p>Genellikle ikisi arasında keskin bir ayrım yapmak zor olabilir ve bazı platformlar her iki yaklaşımın özelliklerini de barındırabilir.</p>
                 </details>

                 <details class="question-block">
                     <summary><h3>Yazılım Geliştirmeyi Nasıl Değiştiriyorlar? Avantajları</h3></summary>
                     <ul>
                         <li><strong>Hızlandırılmış Geliştirme:</strong> Tekrarlayan görevleri ve standart bileşenleri (formlar, tablolar, iş akışları) otomatikleştirerek veya hazır sunarak geliştirme süresini önemli ölçüde kısaltırlar.</li>
                         <li><strong>Daha Düşük Maliyet:</strong> Geliştirme süresinin kısalması ve bazen daha az sayıda uzman geliştiriciye ihtiyaç duyulması maliyetleri düşürebilir.</li>
                         <li><strong>"Citizen Developer" Akımı:</strong> İş birimlerindeki teknik olmayan kullanıcıların kendi ihtiyaçlarına yönelik basit uygulamaları veya otomasyonları geliştirmesine olanak tanır, IT departmanının yükünü azaltabilir.</li>
                         <li><strong>Hızlı Prototipleme:</strong> Fikirleri hızla çalışan prototiplere dönüştürmek için idealdirler.</li>
                         <li><strong>Kolay Dağıtım ve Bakım (Platform İçinde):</strong> Platformlar genellikle dağıtım ve temel bakım süreçlerini basitleştirir.</li>
                         <li><strong>İnovasyonu Teşvik Etme:</strong> İş birimlerinin IT'ye bağımlılığını azaltarak yeni fikirlerin daha hızlı denenmesini sağlayabilir.</li>
                     </ul>
                 </details>

                 <details class="question-block">
                    <summary><h3>Dezavantajları ve Sınırlamaları</h3></summary>
                    <ul>
                        <li><strong>Sınırlı Esneklik ve Özelleştirme:</strong> Platformun sunduğu bileşenler ve yeteneklerle sınırlısınızdır. Çok özel veya karmaşık iş mantıklarını veya benzersiz kullanıcı arayüzlerini implemente etmek zor veya imkansız olabilir.</li>
                        <li><strong>Platforma Bağımlılık (Vendor Lock-in):</strong> Uygulama tamamen belirli bir platforma bağımlı hale gelir. Platformun fiyatlandırması, özellikleri veya geleceği üzerindeki kontrolünüz sınırlıdır. Platformdan ayrılmak genellikle zordur veya uygulamanın yeniden yazılmasını gerektirir.</li>
                        <li><strong>Ölçeklenebilirlik ve Performans Endişeleri:</strong> Çok yüksek trafikli veya yoğun hesaplama gerektiren uygulamalar için platformun ölçeklenebilirlik ve performans sınırları yetersiz kalabilir.</li>
                        <li><strong>Karmaşık Entegrasyonlar:</strong> Mevcut sistemlerle veya üçüncü parti API'lerle karmaşık entegrasyonlar yapmak zor olabilir veya ek kodlama gerektirebilir.</li>
                        <li><strong>Güvenlik ve Uyumluluk:</strong> Verilerin platform sağlayıcısında tutulması veya platformun güvenlik mekanizmalarına bağımlı olunması bazı güvenlik ve uyumluluk endişeleri doğurabilir.</li>
                        <li><strong>Gizli Karmaşıklık:</strong> Başlangıçta basit görünse de, uygulama büyüdükçe görsel arayüzlerdeki mantığı yönetmek ve hata ayıklamak karmaşıklaşabilir.</li>
                        <li><strong>Maliyet (Uzun Vadede):</strong> Kullanıcı sayısı veya özellik kullanımı arttıkça platform maliyetleri beklenenden fazla artabilir.</li>
                    </ul>
                 </details>

                 <details class="question-block">
                     <summary><h3>Yazılımcılar İçin Anlamı: Tehdit mi, Fırsat mı?</h3></summary>
                     <p>LC/NC platformlarının yükselişi, bazı geliştiricilerde işlerini kaybetme endişesi yaratabilse de, genel kanı bunun bir tehditten çok bir <strong>fırsat ve evrim</strong> olduğudur:</p>
                     <ul>
                         <li><strong>Rutin Görevlerden Kurtulma:</strong> Basit CRUD uygulamaları, formlar veya temel iş akışları gibi tekrarlayan ve standart görevleri bu platformlara devrederek, geliştiriciler daha karmaşık, yaratıcı ve katma değerli problemlere odaklanabilirler.</li>
                         <li><strong>Hızlandırıcı Olarak Kullanım:</strong> Geliştiriciler, projelerin belirli kısımlarını (örn: admin paneli, basit raporlama arayüzleri) hızla oluşturmak için LC/NC araçlarını kullanabilirler.</li>
                         <li><strong>Entegrasyon ve Özelleştirme Rolü:</strong> LC/NC platformlarının yeteneklerinin yetersiz kaldığı durumlarda, özel kod yazarak entegrasyonları sağlamak veya platformu genişletmek için profesyonel geliştiricilere ihtiyaç duyulacaktır.</li>
                         <li><strong>Platform Geliştirme ve Yönetimi:</strong> LC/NC platformlarının kendilerini geliştiren veya kurum içinde bu platformları yöneten, en iyi pratikleri belirleyen yeni roller ortaya çıkabilir.</li>
                         <li><strong>"Citizen Developer"lara Destek:</strong> Profesyonel geliştiriciler, iş birimlerindeki "citizen developer"lara rehberlik edebilir, onların oluşturduğu uygulamaların güvenliğini ve kalitesini denetleyebilir.</li>
                     </ul>
                     <p>Sonuç olarak, LC/NC platformları geleneksel kodlamanın yerini tamamen almayacak, ancak yazılım geliştirme manzarasını değiştirecektir. Geliştiricilerin bu araçları anlaması, ne zaman ve nasıl kullanacaklarını bilmesi ve kendi becerilerini daha karmaşık problemlere odaklayacak şekilde evrimleştirmesi önemlidir.</p>
                 </details>
            </section>

            <section id="blockchain" class="content-section">
                <h2>Blockchain ve Kripto Teknolojileri: Merkeziyetsiz Gelecek mi?</h2>
                <p>
                    Blockchain (Blokzincir), en basit tanımıyla, işlemlerin değiştirilemez ve şeffaf bir şekilde kaydedildiği, dağıtık bir dijital defterdir. Bitcoin ile popülerleşen bu teknoloji, kripto paraların ötesinde, tedarik zincirinden oylama sistemlerine, dijital kimlikten merkeziyetsiz uygulamalara (dApps) kadar birçok potansiyel kullanım alanı sunmaktadır.
                </p>

                <details class="question-block">
                    <summary><h3>Temel Kavramlar</h3></summary>
                    <ul>
                        <li><strong>Blokzincir (Blockchain):</strong> Birbirine kriptografik olarak bağlanmış (her blok kendinden önceki bloğun hash'ini içerir) işlem kayıtlarının (bloklar) tutulduğu, sürekli büyüyen bir listedir.</li>
                        <li><strong>Dağıtık Defter (Distributed Ledger):</strong> Blokzincirin kopyaları, ağdaki birçok katılımcı (node) tarafından tutulur ve güncellenir. Tek bir merkezi otorite yoktur.</li>
                        <li><strong>Değiştirilemezlik (Immutability):</strong> Bir blok zincire eklendikten sonra, içindeki verileri değiştirmek veya silmek kriptografik olarak neredeyse imkansızdır. Bu, kayıtların güvenilirliğini sağlar.</li>
                        <li><strong>Şeffaflık (Transparency):</strong> Genel (public) blokzincirlerde (Bitcoin, Ethereum gibi), tüm işlemler genellikle herkes tarafından görülebilir (ancak katılımcıların kimlikleri anonim veya psödonim olabilir). Özel (private) veya konsorsiyum (consortium) blokzincirlerinde erişim kısıtlıdır.</li>
                        <li><strong>Kriptografi:</strong> Blokzincirin güvenliğini sağlayan temel teknolojidir.
                            <ul>
                                <li><strong>Hashing:</strong> Veriyi sabit boyutlu, benzersiz bir özete (hash) dönüştüren algoritmalar (SHA-256 gibi). Blokları birbirine bağlamak ve veri bütünlüğünü kontrol etmek için kullanılır.</li>
                                <li><strong>Public/Private Key Cryptography (Açık/Özel Anahtar Şifrelemesi):</strong> İşlemleri dijital olarak imzalamak (kimlik doğrulama ve inkar edilemezlik) ve adresleri oluşturmak için kullanılır.</li>
                            </ul>
                        </li>
                         <li><strong>Konsensüs Mekanizmaları:</strong> Ağdaki katılımcıların blokzincirin mevcut durumu üzerinde nasıl anlaşmaya varacaklarını belirleyen kurallardır (örn: Proof-of-Work - PoW (Bitcoin), Proof-of-Stake - PoS (Ethereum 2.0)).</li>
                         <li><strong>Kripto Paralar:</strong> Blokzincir teknolojisini kullanan dijital veya sanal para birimleridir (Bitcoin, Ethereum, Solana vb.). Blokzincirin güvenliğini ve işleyişini teşvik etmek için de kullanılırlar.</li>
                         <li><strong>Merkeziyetsizlik (Decentralization):</strong> Kontrolün tek bir merkezde toplanması yerine ağdaki katılımcılar arasında dağıtılması felsefesidir. Sansüre dayanıklılık ve tek hata noktasından kaçınma gibi avantajları vardır.</li>
                    </ul>
                </details>

                 <details class="question-block">
                     <summary><h3>Akıllı Kontratlar (Smart Contracts)</h3></summary>
                     <p>Akıllı kontratlar, belirli koşullar gerçekleştiğinde otomatik olarak çalışan, kendi kendini yürüten ve şartları doğrudan kod içinde yazılı olan sözleşmelerdir. Blokzincir üzerinde çalışırlar ve aracılara olan ihtiyacı ortadan kaldırmayı hedeflerler.</p>
                     <ul>
                         <li><strong>Nasıl Çalışır?:</strong> Belirli bir olayın (örn: ödeme alındı, son tarih geldi) gerçekleşmesiyle tetiklenirler. Sözleşmedeki kod (mantık) blokzincir üzerinde çalıştırılır ve sonuçlar (örn: para transferi, varlık devri) yine blokzincire kaydedilir.</li>
                         <li><strong>Platformlar:</strong> Ethereum, akıllı kontratları popülerleştiren ana platformdur. Solidity, Ethereum üzerinde akıllı kontrat yazmak için en yaygın kullanılan programlama dilidir. Diğer platformlar: Solana, Cardano, Binance Smart Chain, Polkadot vb.</li>
                         <li><strong>Kullanım Alanları:</strong>
                            <ul>
                                <li><strong>Merkeziyetsiz Finans (DeFi):</strong> Borç alma/verme, otomatik piyasa yapıcılar (AMM), sigorta gibi finansal işlemleri aracısız gerçekleştirme.</li>
                                <li><strong>NFT'ler (Non-Fungible Tokens):</strong> Dijital veya fiziksel varlıkların benzersizliğini ve sahipliğini blokzincir üzerinde temsil etme.</li>
                                <li><strong>Tedarik Zinciri Yönetimi:</strong> Ürünlerin kaynağını ve hareketlerini şeffaf ve değiştirilemez bir şekilde takip etme.</li>
                                <li><strong>Oylama Sistemleri:</strong> Şeffaf ve güvenli oylama süreçleri oluşturma.</li>
                                <li><strong>Dijital Kimlik:</strong> Kullanıcıların kendi kimlik verilerini kontrol etmelerini sağlama.</li>
                            </ul>
                         </li>
                     </ul>
                      <pre><code class="language-solidity">
// SPDX-License-Identifier: MIT
// Basit bir Solidity Akıllı Kontrat Örneği (Ethereum)
pragma solidity ^0.8.0;

contract BasitDepolama {
    uint256 private saklananVeri; // Durum değişkeni (state variable)

    // Veriyi değiştiren bir fonksiyon (işlem gerektirir)
    function set(uint256 x) public {
        saklananVeri = x;
        // Olay (event) yayınlama (dış dünyanın dinlemesi için)
        emit VeriDegisti(x);
    }

    // Veriyi okuyan bir fonksiyon (gas harcamaz)
    function get() public view returns (uint256) {
        return saklananVeri;
    }

    // Olay tanımı
    event VeriDegisti(uint256 yeniDeger);
}

                      </code></pre>
                 </details>

                 <details class="question-block">
                    <summary><h3>Yazılıma Etkileri ve Web3</h3></summary>
                    <p>Blockchain ve akıllı kontratlar, yazılım geliştirme paradigmalarını ve uygulama mimarilerini etkileme potansiyeline sahiptir:</p>
                    <ul>
                        <li><strong>Merkeziyetsiz Uygulamalar (dApps):</strong> Geleneksel uygulamaların aksine, backend mantığı merkezi sunucular yerine blokzincir üzerindeki akıllı kontratlarda çalışır. Frontend (genellikle JavaScript framework'leri ile) kullanıcıların blokzincir ile etkileşim kurmasını sağlar (MetaMask gibi cüzdanlar aracılığıyla).</li>
                        <li><strong>Web3:</strong> İnternetin bir sonraki evresi olarak tanımlanan, merkeziyetsizlik, blokzincir, kripto paralar ve kullanıcı veri sahipliği üzerine kurulu bir vizyondur. dApps, DeFi, NFT'ler bu vizyonun parçalarıdır.</li>
                        <li><strong>Yeni Güven Modelleri:</strong> Aracılara güvenmek yerine, kodun (akıllı kontrat) ve kriptografinin sağladığı güvene dayanır.</li>
                        <li><strong>Veri Yönetimi Yaklaşımları:</strong> Değiştirilemez ve şeffaf veri saklama ihtiyacı yeni veri yönetimi modellerini gerektirebilir (IPFS gibi dağıtık depolama çözümleriyle birlikte).</li>
                        <li><strong>Backend Mimarileri:</strong> Bazı durumlarda geleneksel backend sunucularının rolü değişebilir veya akıllı kontratlarla tamamlanabilir.</li>
                    </ul>
                 </details>

                 <details class="question-block">
                    <summary><h3>Zorluklar ve Gelecek</h3></summary>
                     <ul>
                         <li><strong>Ölçeklenebilirlik ve Performans:</strong> Birçok blokzincir ağı, saniyede işleyebileceği işlem sayısı (TPS) açısından hala sınırlıdır. Layer 2 ölçeklendirme çözümleri (Rollups, State Channels) bu sorunu çözmeye çalışmaktadır.</li>
                         <li><strong>Kullanıcı Deneyimi (UX):</strong> dApp'leri kullanmak genellikle kripto cüzdanları ve gas ücretleri gibi ek adımlar gerektirdiğinden son kullanıcılar için karmaşık olabilir.</li>
                         <li><strong>Güvenlik Riskleri:</strong> Akıllı kontratlardaki hatalar veya zafiyetler geri döndürülemez kayıplara yol açabilir. Kapsamlı test ve denetim (audit) süreçleri kritiktir.</li>
                         <li><strong>Enerji Tüketimi:</strong> Özellikle PoW tabanlı blokzincirlerin enerji tüketimi önemli bir eleştiri konusudur (PoS'a geçiş bunu azaltmayı hedefler).</li>
                         <li><strong>Düzenleyici Belirsizlikler (Regulatory Uncertainty):</strong> Kripto paralar ve blokzincir uygulamaları üzerindeki yasal düzenlemeler hala gelişmektedir ve belirsizlikler içermektedir.</li>
                         <li><strong>Karmaşıklık:</strong> Dağıtık sistemlerin ve kriptografinin doğası gereği teknolojinin kendisi karmaşıktır.</li>
                     </ul>
                     <p>Blockchain teknolojisi hala genç ve hızla gelişen bir alandır. Potansiyeli yüksek olmakla birlikte, yaygın olarak benimsenmesi için mevcut zorlukların üstesinden gelinmesi gerekmektedir. Geliştiriciler için Solidity, Rust (Solana, Polkadot için), Go (Hyperledger Fabric için) gibi dilleri öğrenmek ve merkeziyetsiz sistem tasarımı prensiplerini anlamak yeni kariyer fırsatları yaratabilir.</p>
                 </details>
            </section>

            <section id="sonuc" class="content-section">
                 <h2>Sonuç: Değişimin Ritmini Yakalamak</h2>
                 <p>
                    Yazılım geliştirme dünyası, Yapay Zeka'nın kodlama asistanlığından Makine Öğrenmesi modellerinin entegrasyonuna, WebAssembly'nin performans vaatlerinden Low-Code/No-Code platformlarının erişilebilirliğine ve Blockchain'in merkeziyetsizlik vizyonuna kadar heyecan verici ve dönüştürücü bir çağın içinde bulunuyor. Bu teknolojiler, sadece yazdığımız kodları değil, aynı zamanda geliştirme süreçlerimizi, kullandığımız araçları ve hatta geliştirici olarak rollerimizi yeniden şekillendiriyor.
                 </p>
                 <p>
                    AI destekli araçlar verimliliği artırma potansiyeli sunarken, eleştirel düşünme ve kod kalitesine odaklanma ihtiyacını da beraberinde getiriyor. WebAssembly, web'in sınırlarını zorlayarak daha önce mümkün olmayan uygulama türlerini tarayıcıya taşırken, JavaScript ile olan simbiyotik ilişkisini de koruyor. Low-Code/No-Code, yazılım geliştirmeyi demokratikleştirirken, profesyonel geliştiricilerin daha karmaşık entegrasyonlara ve platform yönetimine odaklanması için yeni fırsatlar yaratıyor. Blockchain ise, getirdiği zorluklara rağmen, güven, şeffaflık ve merkeziyetsizlik üzerine kurulu yeni nesil uygulamaların kapısını aralıyor.
                 </p>
                 <p>
                    Bu trendleri takip etmek, potansiyellerini ve sınırlılıklarını anlamak, günümüz geliştiricisi için bir lüks değil, bir gerekliliktir. Sürekli öğrenme, yeni teknolojileri deneme cesareti ve değişime adapte olma yeteneği, bu hızlı evrilen alanda relevant kalmanın anahtarıdır. Gelecek belirsizliklerle dolu olsa da, bu yeni araçları ve paradigmaları anlayarak ve benimseyerek, yazılımın geleceğini şekillendirmede aktif bir rol oynayabiliriz.
                 </p>
            </section>
        </div>
    </main>

    <div class="back-to-top-container">
        <a href="#pageTop" class="back-to-top" aria-label="Sayfanın başına dön">
            <i class="fas fa-chevron-up"></i>
        </a>
   </div>

    <footer id="mainFooter">
        <div class="container">
            <div class="footer-layout">
                <div class="footer-left-links">
                    <h4>Hızlı Bağlantılar</h4>
                    <ul class="footer-nav-links">
                        <li><a href="https://abdulkadirgungor86.github.io/">Ana Sayfa</a></li>
                        <li><a href="https://abdulkadirgungor86.github.io/cv" target="_blank" rel="noopener noreferrer">Özgeçmiş</a></li>
                        <li><a href="https://abdulkadirgungor86.github.io/blog" target="_blank" rel="noopener noreferrer">Blog</a></li>
                    </ul>
                </div>
                <div class="footer-center-content">
                    <h4 class="sitemap-link-heading">
                        <a href="https://abdulkadirgungor86.github.io/sitemap.xml" target="_blank" rel="noopener noreferrer">Sitemap</a>
                    </h4>
                    <p id="footerTextContent">
                        <!-- Content will be loaded by script.js -->
                    </p>
                </div>
            </div>
        </div>
    </footer>
    
    <script src="../assets/js/script.js" defer></script>
</body>
</html>