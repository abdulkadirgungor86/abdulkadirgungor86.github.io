<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="siteTitle">Kapsamlı CSS Öğrenme Rehberi: Web Tasarımının Gücü</title>
    <meta name="description" content="CSS (Cascading Style Sheets) öğrenmek için temelden ileri seviyeye uzanan kapsamlı bir rehber. Seçiciler, özellikler, değerler, kutu modeli, flexbox, grid, duyarlı tasarım, animasyonlar ve en iyi uygulamalar hakkında detaylı bilgi ve örnekler içerir. Abdulkadir Güngör tarafından hazırlanmıştır.">
    <meta name="keywords" content="CSS, CSS Öğren, CSS Dersleri, Web Tasarımı, Frontend, CSS Nedir, CSS Seçiciler, CSS Özellikler, Kutu Modeli, Box Model, CSS Yerleşim, Flexbox, CSS Grid, Duyarlı Tasarım, Responsive Design, Media Queries, CSS Animasyonları, CSS Transitions, CSS Değişkenleri, CSS Temelleri, CSS Kılavuzu, CSS Rehberi, Abdulkadir Güngör, CSS Tutorial Türkçe">
    <meta name="author" content="Abdulkadir Güngör">
    <link rel="canonical" href="https://abdulkadirgungor.com/blog/blog_page_9.html" />

    <link rel="icon" type="image/png" href="../assets/images/icons/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="../assets/images/icons/favicon.svg" />
    <link rel="shortcut icon" href="../assets/images/icons/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="../assets/images/icons/apple-touch-icon.png" />
    <link rel="manifest" href="../assets/images/icons/site.webmanifest" />

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="../assets/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <link rel="sitemap" type="application/xml" title="Sitemap" href="https://abdulkadirgungor.com/sitemap.xml">
    <link rel="sitemap" type="text/html" title="HTML Sitemap" href="https://abdulkadirgungor.com/sitemap.html">
    
    <script type="application/ld+json" id="siteData">
    {
      "@context": "https://schema.org",
      "@type": "BlogPosting",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://abdulkadirgungor.com/blog/blog_page_9.html"
      },
      "headline": "Kapsamlı CSS Öğrenme Rehberi: Web Tasarımının Gücü",
      "name": "Kapsamlı CSS Öğrenme Rehberi | Abdulkadir Güngör", 
  "author": {
    "@type": "Person",
    "name": "Abdulkadir Güngör",
    "url": "https://abdulkadirgungor.com/",
    "image": "https://abdulkadirgungor.com/assets/images/cv-profile.jpg",
    "sameAs": [
      "https://www.linkedin.com/in/abdulkadir-güngör/",
      "https://github.com/abdulkadirgungor86",
      "https://github.com/abdulkadir-gungor",
      "https://scholar.google.com/citations?user=1Ov789YAAAAJ",
      "https://polen.itu.edu.tr/bitstreams/f268d04c-e4a9-49bd-b336-929c1e52e4b9/download",
      "https://books.google.com.tr/books?id=GWMhEAAAQBAJ",
      "https://books.google.com.tr/books?id=u0CLEAAAQBAJ",
      "https://www.wikidata.org/wiki/Q134932691",
      "https://www.imdb.com/name/nm17368974"
    ]
  },
      "publisher": {
        "@type": "Organization",
        "name": "Abdulkadir Güngör",
        "logo": {
          "@type": "ImageObject",
          "url": "https://abdulkadirgungor.com/assets/images/icons/favicon-96x96.png" 
        }
      },
      "datePublished": "2025-05-13", 
      "dateModified": "2025-05-13", 
      "description": "CSS (Cascading Style Sheets) öğrenmek için temelden ileri seviyeye uzanan kapsamlı bir rehber.",
      "isPartOf": {
        "@type": "WebSite",
        "@id": "https://abdulkadirgungor.com/"
      }
    }
    </script>

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-5GFQC3DYZF"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-5GFQC3DYZF');
    </script>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-5L6M34JW');</script>
    
</head>
<body id="pageTop"> 
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5L6M34JW"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    
    <main class="section-padding">
        <div class="container">
            <article id="giris" class="content-section intro-section">
                <h1>CSS: Web Sayfalarına Stil Kazandırma Sanatı</h1>
                <p>
                    Web'in görsel dünyasını şekillendiren temel teknolojilerden biri olan CSS (Cascading Style Sheets - Basamaklı Stil Şablonları), HTML ile yapılandırılmış içeriğin nasıl görüneceğini tanımlayan bir stil dilidir. HTML, bir web sayfasının iskeletini ve içeriğini oluştururken, CSS bu iskeletin üzerine giydirilen elbiseler gibidir; renkleri, yazı tiplerini, yerleşimi, boyutları ve hatta animasyonları kontrol ederek kullanıcı deneyimini zenginleştirir. Modern web tasarımının ayrılmaz bir parçası olan CSS, web sitelerine estetik bir görünüm kazandırmanın yanı sıra, farklı cihazlarda tutarlı ve erişilebilir bir deneyim sunmak için de kritik bir rol oynar.
                </p>
                <p>
                    CSS olmadan web, büyük ölçüde siyah-beyaz metinlerden ve temel bağlantılardan ibaret kalırdı. CSS'in gücü, içeriği (HTML) sunumdan (stil) ayırmasından gelir. Bu ayrım, kodun daha temiz, yönetilebilir ve esnek olmasını sağlar. Bir web sitesinin tüm sayfalarının görünümünü tek bir CSS dosyasından kontrol etmek, tasarım değişikliklerini kolaylaştırır ve bakım maliyetlerini düşürür. Ayrıca, aynı HTML içeriği farklı cihazlar veya kullanıcı tercihleri için farklı CSS kuralları ile biçimlendirilebilir (örneğin, ekranlar için farklı, yazıcılar için farklı bir görünüm).
                </p>
                 <p>
                    CSS'in tarihi, HTML gibi web'in ilk günlerine dayanır. İlk olarak 1996'da W3C tarafından standartlaştırılan CSS1'den bu yana, dil önemli ölçüde gelişti. CSS2 ve ardından CSS3 ile birlikte seçiciler, yerleşim modelleri (Flexbox, Grid), geçişler, animasyonlar, özel yazı tipleri ve daha birçok güçlü özellik eklendi. Günümüzde CSS, modüler bir yapıya sahip olup sürekli olarak yeni özellikler ve iyileştirmelerle güncellenmektedir. Bu rehber, CSS'in temel sözdiziminden başlayarak modern yerleşim tekniklerine, duyarlı tasarıma ve ileri seviye konulara kadar geniş bir yelpazede bilgi sunarak, web sayfalarınıza profesyonel bir görünüm kazandırmanız için size yol gösterecektir.
                </p>
            </article>

            <section id="temeller" class="content-section">
                <h2>CSS Temelleri: Sözdizimi ve Uygulama Yöntemleri</h2>
                <p>
                    CSS'in temelini anlamak, stil kurallarının nasıl yazıldığını ve HTML belgelerine nasıl entegre edildiğini öğrenmekle başlar. Temel sözdizimi oldukça basittir ancak CSS'in gücü, bu basit kuralların birleşerek karmaşık tasarımlar oluşturmasından gelir.
                </p>

                <details class="question-block">
                    <summary><h3>CSS Kural Yapısı (Sözdizimi) Nasıldır?</h3></summary>
                    <p>
                        Bir CSS kuralı temel olarak iki bölümden oluşur: Seçici (Selector) ve Bildirim Bloğu (Declaration Block).
                    </p>
                    <pre><code class="language-css">
secici {
  ozellik: deger;
  baska-ozellik: baska-deger;
}
                    </code></pre>
                    <ul>
                        <li><strong>Seçici (Selector):</strong> Hangi HTML eleman(lar)ına stil uygulanacağını hedefler. Örneğin, tüm paragrafları (<code>p</code>), belirli bir sınıfa (<code>.uyari</code>) sahip elemanları veya benzersiz bir ID'ye (<code>#logo</code>) sahip elemanı seçebilir. Seçiciler oldukça çeşitlidir ve güçlü hedefleme yetenekleri sunar (daha sonra detaylandırılacaktır).</li>
                        <li><strong>Bildirim Bloğu (Declaration Block):</strong> Süslü parantezler (<code>{ }</code>) içine alınmış bir veya daha fazla bildirimden oluşur.</li>
                        <li><strong>Bildirim (Declaration):</strong> Seçilen elemanlara uygulanacak stil kuralını tanımlar. Bir özellik (property) ve bir değerden (value) oluşur, aralarına iki nokta üst üste (<code>:</code>) konur ve bildirim noktalı virgül (<code>;</code>) ile sonlandırılır.
                            <ul>
                                <li><strong>Özellik (Property):</strong> Değiştirilmek istenen stil özelliğidir (örn: <code>color</code>, <code>font-size</code>, <code>background-color</code>).</li>
                                <li><strong>Değer (Value):</strong> Özelliğe atanacak değerdir (örn: <code>red</code>, <code>16px</code>, <code>#ffffff</code>).</li>
                            </ul>
                        </li>
                    </ul>
                    <p>Örnek:</p>
                    <pre><code class="language-css">
/* Tüm paragraf metinlerini mavi yapar */
p {
  color: blue;
  font-size: 14px; /* Yazı tipi boyutunu 14 piksel yapar */
}

/* 'baslik' ID'sine sahip elemanın arka planını gri yapar */
#baslik {
  background-color: lightgray;
}

/* 'vurgu' sınıfına sahip elemanları kalın yapar */
.vurgu {
  font-weight: bold;
}
                    </code></pre>
                    <p>CSS'te yorumlar <code>/*</code> ile başlar ve <code>*/</code> ile biter. Çok satırlı olabilirler.</p>
                </details>

                <details class="question-block">
                    <summary><h3>CSS HTML'e Nasıl Eklenir? (Uygulama Yöntemleri)</h3></summary>
                    <p>CSS kurallarını bir HTML belgesine uygulamanın üç temel yolu vardır:</p>
                    <ol>
                        <li><strong>Harici Stil Şablonu (External Style Sheet):</strong> En yaygın ve tavsiye edilen yöntemdir. CSS kuralları ayrı bir <code>.css</code> dosyasına yazılır ve HTML belgesinin <code><head></code> bölümü içine <code><link></code> etiketi kullanılarak bağlanır.
                            <pre><code class="language-html">
<!DOCTYPE html>
<html>
<head>
  <title>Harici CSS Örneği</title>
  <link rel="stylesheet" href="stilim.css">
</head>
<body>
  <!-- Sayfa içeriği -->
</body>
</html>
                            </code></pre>
                            <p><code>stilim.css</code> dosyası:</p>
                            <pre><code class="language-css">
body {
  font-family: Arial, sans-serif;
}
h1 {
  color: navy;
}
                            </code></pre>
                            <p><strong>Avantajları:</strong> İçeriği sunumdan tamamen ayırır, birden fazla HTML sayfasının aynı stil dosyasını kullanmasını sağlar (tutarlılık ve kolay bakım), tarayıcılar CSS dosyasını önbelleğe alarak sonraki sayfa yüklemelerini hızlandırabilir, kod daha temiz ve organize olur.</p>
                        </li>
                        <li><strong>Dahili Stil Şablonu (Internal Style Sheet):</strong> CSS kuralları, HTML belgesinin <code>&lt;head></code> bölümü içine açılan <code>&lt;style></code> etiketleri arasına yazılır.
                             <pre><code class="language-html">
&lt;!DOCTYPE html>
&lt;html>
&lt;head>
  &lt;title>Dahili CSS Örneği</title>
  &lt;style>
    body {
      background-color: linen;
    }
    h1 {
      color: maroon;
      margin-left: 40px;
    }
  &lt;/style>
&lt;/head>
&lt;body>
  &lt;h1>Bu bir başlıktır</h1>
  &lt;p>Bu bir paragraftır.</p>
&lt;/body>
&lt;/html>
                            </code></pre>
                            <p><strong>Avantajları:</strong> Tek bir HTML sayfası için hızlı stil tanımlamaları yapılabilir. <strong>Dezavantajları:</strong> Stiller sadece o HTML sayfasına özgüdür, birden fazla sayfada aynı stilleri kullanmak için kopyala-yapıştır gerekir (bakımı zorlaştırır), içerik ve sunum aynı dosyada karışır.</p>
                        </li>
                        <li><strong>Satır İçi Stiller (Inline Styles):</strong> CSS kuralları doğrudan stil uygulanacak HTML elemanının <code>style</code> niteliği içine yazılır.
                            <pre><code class="language-html">
<!DOCTYPE html>
<html>
<body>
  <h1 style="color: blue; text-align: center;">Mavi ve Ortalanmış Başlık</h1>
  <p style="color: red;">Kırmızı renkli paragraf.</p>
</body>
</html>
                            </code></pre>
                            <p><strong>Avantajları:</strong> Çok spesifik ve tekil bir elemana hızlıca stil vermek için kullanılabilir (örneğin JavaScript ile dinamik olarak stil değiştirirken). <strong>Dezavantajları:</strong> En az tavsiye edilen yöntemdir. İçerik ve sunumu en fazla karıştıran yöntemdir, kodun okunabilirliğini ve bakımını çok zorlaştırır, CSS'in tekrar kullanılabilirlik avantajını ortadan kaldırır, özgüllüğü (specificity) çok yüksek olduğu için diğer stilleri ezmesi zordur.</p>
                        </li>
                    </ol>
                    <p>Genel olarak, projelerinizde <strong>harici stil şablonları</strong> kullanmaya özen gösterin.</p>
                </details>

                <details class="question-block">
                    <summary><h3>CSS Kademelenme, Özgüllük ve Kalıtım (Cascade, Specificity, Inheritance)</h3></summary>
                    <p>Bir HTML elemanına birden fazla CSS kuralı uygulanmaya çalıştığında, tarayıcının hangi kuralın geçerli olacağını belirlemek için kullandığı mekanizmalar vardır:</p>
                    <ul>
                        <li><strong>Kademelenme (Cascade):</strong> Tarayıcı, bir eleman için geçerli olabilecek tüm CSS kurallarını farklı kaynaklardan (tarayıcı varsayılan stilleri, kullanıcı stil şablonları, harici/dahili/inline stiller) toplar. Ardından bu kuralları belirli bir öncelik sırasına göre uygular. Genel kural şudur:
                            <ol>
                                <li>Satır İçi Stiller (Inline Styles): En yüksek önceliğe sahiptir.</li>
                                <li>Harici ve Dahili Stil Şablonları: Öncelikleri özgüllüklerine (specificity) ve kod içindeki sıralarına göre belirlenir.</li>
                                <li>Kullanıcı Stil Şablonları: Tarayıcıya kullanıcı tarafından eklenen özel stiller.</li>
                                <li>Tarayıcı Varsayılan Stilleri: Tarayıcının HTML elemanlarına uyguladığı temel stiller.</li>
                            </ol>
                            Aynı öncelik seviyesindeki kurallardan daha sonra tanımlanan kural, öncekini ezer. <code>!important</code> kuralı, bu sıralamayı bozmak için kullanılabilir (ancak genellikle kaçınılması önerilir).
                            <pre><code class="language-css">
p { color: blue; }
p { color: red; } /* Bu kural geçerli olur (daha sonra tanımlandı) */

p { color: green !important; } /* Bu kural diğerlerini ezer */
p { color: yellow; } /* !important olmadığı için green'i ezemez */
                            </code></pre>
                        </li>
                        <li><strong>Özgüllük (Specificity):</strong> Kademelenme sırasında aynı öncelik seviyesindeki kurallar arasında hangisinin uygulanacağını belirleyen bir ağırlıklandırma sistemidir. Daha özgül (spesifik) olan seçici, daha az özgül olanı ezer. Özgüllük genellikle şu sırayla hesaplanır (en yüksekten en düşüğe):
                            <ol>
                                <li>Satır içi stiller (<code>style="..."</code>)</li>
                                <li>ID seçiciler (<code>#id</code>)</li>
                                <li>Sınıf (<code>.class</code>), nitelik (<code>[type="text"]</code>) ve sözde sınıf (<code>:hover</code>) seçicileri</li>
                                <li>Tür (eleman) seçicileri (<code>p</code>, <code>div</code>) ve sözde eleman (<code>::before</code>) seçicileri</li>
                                <li>Evrensel seçici (<code>*</code>) ve kalıtım yoluyla gelen değerler en düşük özgüllüğe sahiptir.</li>
                            </ol>
                            Tarayıcı, her kuralın seçicisindeki ID, sınıf/nitelik/sözde-sınıf ve tür/sözde-eleman sayısını sayarak bir özgüllük değeri hesaplar.
                            <pre><code class="language-css">
p { color: blue; }                /* Özgüllük: 0,0,1 */
.paragraf { color: green; }       /* Özgüllük: 0,1,0 (daha özgül, blue'yu ezer) */
#giris p { color: red; }          /* Özgüllük: 1,0,1 (daha özgül, green'i ezer) */
<p class="paragraf" style="color: purple;">...</p> /* Satır içi stil (en özgül, red'i ezer) */
                            </code></pre>
                        </li>
                        <li><strong>Kalıtım (Inheritance):</strong> Bazı CSS özellikleri (genellikle metinle ilgili olanlar: <code>color</code>, <code>font-family</code>, <code>font-size</code>, <code>line-height</code> vb.) üst elemanlardan alt elemanlara otomatik olarak aktarılır. Eğer bir alt eleman için o özellik doğrudan tanımlanmamışsa, üst elemanından bu değeri miras alır. Tüm özellikler kalıtılmaz (örn: <code>border</code>, <code>padding</code>, <code>margin</code>, <code>background-color</code> kalıtılmaz). Kalıtım, <code>inherit</code> değeri kullanılarak zorlanabilir veya <code>initial</code> (varsayılan değere dön) / <code>unset</code> (kalıtılıyorsa inherit, değilse initial) değerleri ile sıfırlanabilir.</li>
                    </ul>
                    <p>Bu üç mekanizmayı anlamak, CSS'in neden bazen beklediğiniz gibi çalışmadığını anlamanıza ve stilleri daha etkili bir şekilde yönetmenize yardımcı olur.</p>
                </details>
            </section>

            <section id="seciciler" class="content-section">
                <h2>CSS Seçicileri: HTML Elemanlarını Hedeflemek</h2>
                <p>Seçiciler, CSS'in hangi HTML elemanlarına stil uygulayacağını belirleyen güçlü desenlerdir. Doğru seçicileri kullanmak, istediğiniz elemanları hassas bir şekilde hedeflemenizi sağlar.</p>

                <details class="question-block">
                    <summary><h3>Temel Seçiciler: Tür, Sınıf, ID</h3></summary>
                    <ul>
                        <li><strong>Tür Seçici (Type Selector / Element Selector):</strong> Belirli bir HTML etiket adına sahip tüm elemanları seçer.
                            <pre><code class="language-css">
/* Tüm <p> elemanları */
p { margin-bottom: 1em; }

/* Tüm <h2> elemanları */
h2 { color: #333; }

/* Tüm <li> elemanları */
li { list-style-type: square; }
                            </code></pre>
                        </li>
                        <li><strong>Sınıf Seçici (Class Selector):</strong> Belirli bir <code>class</code> niteliğine sahip tüm elemanları seçer. Seçici, bir nokta (<code>.</code>) ile başlar ve ardından sınıf adı gelir. Bir eleman birden fazla sınıfa sahip olabilir (<code>class="sinif1 sinif2"</code>) ve bir sınıf birden fazla elemana uygulanabilir. En yaygın kullanılan seçici türlerinden biridir.
                            <pre><code class="language-css">
/* 'uyari' sınıfına sahip tüm elemanlar */
.uyari {
  color: red;
  font-weight: bold;
  border: 1px solid red;
  padding: 10px;
}

/* 'buton' sınıfına sahip tüm elemanlar */
.buton {
  display: inline-block;
  padding: 8px 15px;
  background-color: blue;
  color: white;
  text-decoration: none;
  border-radius: 4px;
}

/* Hem 'buton' hem de 'birincil' sınıfına sahip elemanlar (daha özgül) */
.buton.birincil {
    background-color: green;
}
                            </code></pre>
                        </li>
                        <li><strong>ID Seçici (ID Selector):</strong> Belirli bir <code>id</code> niteliğine sahip tek bir elemanı seçer. Seçici, bir diyez (<code>#</code>) işareti ile başlar ve ardından ID adı gelir. Bir HTML belgesinde her ID benzersiz olmalıdır (sadece bir eleman o ID'ye sahip olabilir). Yüksek özgüllüğe sahiptir, bu nedenle dikkatli kullanılmalıdır (genellikle sınıf seçiciler daha esnektir).
                            <pre><code class="language-css">
/* 'ana-menu' ID'sine sahip eleman */
#ana-menu {
  list-style: none;
  padding: 0;
}

/* 'logo' ID'sine sahip eleman */
#logo {
  width: 150px;
  height: auto;
}
                            </code></pre>
                        </li>
                    </ul>
                </details>

                <details class="question-block">
                    <summary><h3>Birleştiriciler (Combinators)</h3></summary>
                    <p>İki veya daha fazla seçici arasındaki ilişkiyi tanımlayarak daha spesifik hedefleme yapmayı sağlarlar:</p>
                    <ul>
                        <li><strong>Soy Seçici (Descendant Combinator) (Boşluk):</strong> Birinci seçicinin içinde yer alan (herhangi bir seviyede) ikinci seçiciye uyan tüm elemanları seçer.
                            <pre><code class="language-css">
/* 'icerik' ID'li elemanın içindeki tüm <p> elemanları */
#icerik p {
  line-height: 1.6;
}

/* <ul> içindeki tüm <a> elemanları */
ul a {
  color: purple;
}
                            </code></pre>
                        </li>
                        <li><strong>Çocuk Seçici (Child Combinator) (<code>&gt;</code>):</strong> Birinci seçicinin doğrudan çocuğu olan (hemen bir alt seviyesindeki) ikinci seçiciye uyan elemanları seçer.
                            <pre><code class="language-css">
/* 'ana-menu' ID'li elemanın doğrudan çocuğu olan <li> elemanları */
#ana-menu > li {
  display: inline-block;
  margin-right: 10px;
}

/* &lt;body>'nin doğrudan çocuğu olan <p> elemanları */
body > p {
  font-style: italic;
}
                            </code></pre>
                        </li>
                        <li><strong>Bitişik Kardeş Seçici (Adjacent Sibling Combinator) (<code>+</code>):</strong> Birinci seçici ile aynı üst elemana sahip olan ve birinci seçiciden hemen sonra gelen ikinci seçiciye uyan elemanı seçer.
                            <pre><code class="language-css">
/* Bir &lt;h2>'den hemen sonra gelen <p> elemanı */
h2 + p {
  margin-top: 0;
  font-size: 1.1em;
  color: gray;
}

/* 'aktif' sınıfına sahip bir <li>'den hemen sonra gelen <li> elemanı */
li.aktif + li {
  border-top: 1px solid #eee;
}
                            </code></pre>
                        </li>
                        <li><strong>Genel Kardeş Seçici (General Sibling Combinator) (<code>~</code>):</strong> Birinci seçici ile aynı üst elemana sahip olan ve birinci seçiciden sonra gelen (hemen sonra olması gerekmez) ikinci seçiciye uyan tüm elemanları seçer.
                            <pre><code class="language-css">
/* Bir &lt;h2>'den sonra gelen tüm &lt;p> elemanları (aynı seviyede) */
h2 ~ p {
  text-indent: 20px;
}

/* 'etiket' sınıfından sonra gelen tüm 'etiket' sınıfına sahip elemanlar */
.etiket ~ .etiket {
  margin-left: 5px;
}
                            </code></pre>
                        </li>
                    </ul>
                </details>

                <details class="question-block">
                    <summary><h3>Nitelik Seçiciler (Attribute Selectors)</h3></summary>
                    <p>HTML elemanlarının sahip olduğu niteliklere veya nitelik değerlerine göre seçim yapmayı sağlar:</p>
                    <ul>
                        <li><strong><code>[nitellik]</code>:</strong> Belirtilen niteliğe sahip tüm elemanları seçer (değerine bakmaz).
                            <pre><code class="language-css">
/* 'target' niteliğine sahip tüm &lt;a> elemanları */
a[target] {
  background-color: yellow;
}
/* 'disabled' niteliğine sahip tüm &lt;input> elemanları */
input[disabled] {
  opacity: 0.5;
  cursor: not-allowed;
}
                            </code></pre>
                        </li>
                        <li><strong><code>[nitellik="deger"]</code>:</strong> Belirtilen niteliğe tam olarak belirtilen değere sahip elemanları seçer.
                            <pre><code class="language-css">
/* 'type' niteliği tam olarak "text" olan &lt;input> elemanları */
input[type="text"] {
  border: 1px solid #ccc;
  padding: 5px;
}
/* 'href' niteliği "#" olan <a> elemanları */
a[href="#"] {
  color: gray;
  text-decoration: none;
}
                            </code></pre>
                        </li>
                        <li><strong><code>[nitellik~="deger"]</code>:</strong> Belirtilen niteliğin boşlukla ayrılmış değer listesi içinde belirtilen değeri içeren elemanları seçer (örn: <code>class="a b c"</code> içindeki "b" yi bulur).
                             <pre><code class="language-css">
/* 'class' niteliği içinde 'logo' kelimesini içeren elemanlar */
[class~="logo"] {
  border: 2px dashed blue;
}
                            </code></pre>
                        </li>
                        <li><strong><code>[nitellik|="deger"]</code>:</strong> Belirtilen niteliğin değeri tam olarak belirtilen değerle veya belirtilen değerle başlayıp hemen ardından tire (-) ile devam eden elemanları seçer (genellikle dil kodları için kullanılır <code>lang="en-US"</code> gibi).
                             <pre><code class="language-css">
/* 'lang' niteliği 'en' veya 'en-' ile başlayan elemanlar */
[lang|="en"] {
  font-style: italic;
}
                            </code></pre>
                        </li>
                        <li><strong><code>[nitellik^="deger"]</code>:</strong> Belirtilen niteliğin değeri belirtilen değerle başlayan elemanları seçer.
                             <pre><code class="language-css">
/* 'href' niteliği "https://" ile başlayan <a> elemanları */
a[href^="https://"] {
  padding-right: 15px;
  /* background: url('external-link-icon.png') no-repeat right center; */
}
                            </code></pre>
<code class="language-css">
/* 'href' niteliği ".pdf" ile biten <a> elemanları */
a[href$=".pdf"]::after {
  content: " (PDF)";
  font-size: 0.8em;
}                        </li>
                        <li><strong><code>[nitellik$="deger"]</code>:</strong> Belirtilen niteliğin değeri belirtilen değerle biten elemanları seçer.
                            <pre>
                            </code></pre>
                        </li>
                        <li><strong><code>[nitellik*="deger"]</code>:</strong> Belirtilen niteliğin değeri içinde belirtilen değeri içeren (herhangi bir yerinde) elemanları seçer.
                            <pre><code class="language-css">

                            </code></pre>
                        </li>
                    </ul>
                     <p>Nitelik seçicilere <code>i</code> bayrağı eklenerek büyük/küçük harf duyarsız eşleşme sağlanabilir (örn: <code>[type="text" i]</code>). Ancak bu özellik tüm tarayıcılarda henüz tam desteklenmeyebilir.</p>
                </details>




                <details class="question-block">
                    <summary><h3>Sözde Sınıflar (Pseudo-classes)</h3></summary>
                    <p>Bir elemanın belirli bir durumda (state) olduğunu belirtmek veya belirli yapısal konumdaki elemanları seçmek için kullanılır. Seçicide iki nokta üst üste (<code>:</code>) ile başlarlar.</p>
                    <ul>
                        <li><strong>Durum (State) Sözde Sınıfları:</strong>
                            <ul>
                                <li><code>:link</code>: Henüz ziyaret edilmemiş bağlantılar.</li>
                                <li><code>:visited</code>: Daha önce ziyaret edilmiş bağlantılar.</li>
                                <li><code>:hover</code>: Fare imleci üzerine getirilen elemanlar.</li>
                                <li><code>:active</code>: Etkinleştirilen (genellikle tıklanma anındaki) elemanlar (özellikle bağlantılar ve düğmeler).</li>
                                <li><code>:focus</code>: Odaklanılmış elemanlar (genellikle klavye ile gezinirken veya form elemanına tıklandığında).</li>
                                <li><code>:checked</code>: Seçili olan <code><input type="radio"></code> veya <code><input type="checkbox"></code> elemanları.</li>
                                <li><code>:disabled</code>: Devre dışı bırakılmış form elemanları (<code>disabled</code> niteliği olanlar).</li>
                                <li><code>:enabled</code>: Etkin olan (devre dışı bırakılmamış) form elemanları.</li>
                                <li><code>:required</code>: Doldurulması zorunlu (<code>required</code> niteliği olan) form elemanları.</li>
                                <li><code>:optional</code>: Doldurulması isteğe bağlı form elemanları.</li>
                                <li><code>:valid</code> / <code>:invalid</code>: Giriş değeri geçerli / geçersiz olan form elemanları (HTML5 doğrulamasına göre).</li>
                                <li><code>:target</code>: URL'deki fragment identifier (<code>#id</code>) ile eşleşen ID'ye sahip eleman.</li>
                            </ul>
                        </li>
                        <li><strong>Yapısal (Structural) Sözde Sınıflar:</strong>
                            <ul>
                                <li><code>:root</code>: Belgenin kök elemanını (genellikle <code>&lt;html></code>) seçer. CSS değişkenlerini tanımlamak için sıkça kullanılır.</li>
                                <li><code>:first-child</code>: Üst elemanının ilk çocuğu olan elemanları seçer.</li>
                                <li><code>:last-child</code>: Üst elemanının son çocuğu olan elemanları seçer.</li>
                                <li><code>:nth-child(n)</code>: Üst elemanının n'inci çocuğu olan elemanları seçer. <code>n</code> bir sayı (<code>1</code>, <code>2</code>, ...), <code>even</code> (çift), <code>odd</code> (tek) veya bir formül (<code>2n+1</code>, <code>3n</code>, <code>-n+5</code>) olabilir.</li>
                                <li><code>:nth-last-child(n)</code>: Sondan başlayarak n'inci çocuğu seçer.</li>
                                <li><code>:first-of-type</code>: Üst elemanı içinde kendi türünün ilk örneği olan elemanları seçer.</li>
                                <li><code>:last-of-type</code>: Üst elemanı içinde kendi türünün son örneği olan elemanları seçer.</li>
                                <li><code>:nth-of-type(n)</code>: Üst elemanı içinde kendi türünün n'inci örneği olan elemanları seçer.</li>
                                <li><code>:nth-last-of-type(n)</code>: Sondan başlayarak kendi türünün n'inci örneğini seçer.</li>
                                <li><code>:only-child</code>: Üst elemanının tek çocuğu olan elemanları seçer.</li>
                                <li><code>:only-of-type</code>: Üst elemanı içinde kendi türünün tek örneği olan elemanları seçer.</li>
                                <li><code>:empty</code>: Hiçbir çocuğu (metin düğümleri dahil) olmayan elemanları seçer.</li>
                            </ul>
                        </li>
                         <li><strong>Diğer Sözde Sınıflar:</strong>
                            <ul>
                                 <li><code>:not(selector)</code>: Belirtilen seçiciye uymayan elemanları seçer.</li>
                                 <li><code>:lang(language-code)</code>: Belirtilen dildeki (<code>lang</code> niteliği) elemanları seçer.</li>
                            </ul>
                         </li>
                    </ul>
                    <pre><code class="language-css">
/* Bağlantı stilleri */
a:link { color: blue; }
a:visited { color: purple; }
a:hover { text-decoration: underline; color: orange; }
a:active { color: red; }

/* Odaklanmış input alanı */
input:focus {
  outline: 2px solid skyblue;
  border-color: skyblue;
}

/* İşaretli checkbox'tan sonra gelen label */
input[type="checkbox"]:checked + label {
  font-weight: bold;
  color: green;
}

/* Tablodaki çift satırlar */
tbody tr:nth-child(even) {
  background-color: #f2f2f2;
}

/* Bir listenin ilk ve son elemanı */
ul li:first-child { padding-top: 0; }
ul li:last-child { border-bottom: none; }

/* 'uyari' sınıfına sahip olmayan paragraflar */
p:not(.uyari) {
  color: #555;
}
                    </code></pre>
                </details>

                <details class="question-block">
                    <summary><h3>Sözde Elemanlar (Pseudo-elements)</h3></summary>
                    <p>Bir elemanın belirli bir bölümüne stil vermek için kullanılır. Seçicide çift iki nokta üst üste (<code>::</code>) ile başlarlar (eski CSS sürümleri tek <code>:</code> kabul etse de, sözde sınıflardan ayırmak için <code>::</code> kullanmak standarttır).</p>
                    <ul>
                        <li><strong><code>::before</code>:</strong> Seçilen elemanın içeriğinden hemen önce sanal bir eleman oluşturur. Genellikle <code>content</code> özelliği ile birlikte ikon veya metin eklemek için kullanılır.</li>
                        <li><strong><code>::after</code>:</strong> Seçilen elemanın içeriğinden hemen sonra sanal bir eleman oluşturur. <code>::before</code> gibi, <code>content</code> özelliği gereklidir.</li>
                        <li><strong><code>::first-line</code>:</strong> Bir blok seviyesi elemanın yalnızca ilk satırına stil uygular.</li>
                        <li><strong><code>::first-letter</code>:</strong> Bir blok seviyesi elemanın yalnızca ilk harfine stil uygular (büyük harf efekti gibi).</li>
                        <li><strong><code>::marker</code>:</strong> Bir liste öğesinin (<code><li></code>) madde işaretine veya numarasına stil uygular.</li>
                        <li><strong><code>::selection</code>:</strong> Kullanıcının fare veya klavye ile seçtiği metin bölümüne stil uygular.</li>
                        <li><strong><code>::placeholder</code>:</strong> Form elemanlarındaki (<code><input></code>, <code>&lt;textarea></code>) yer tutucu metne (placeholder) stil uygular.</li>
                    </ul>
                    <pre><code class="language-css">
/* Dış bağlantılardan sonra bir ikon ekleme */
a[target="_blank"]::after {
  content: " ↗"; /* Veya bir resim: content: url(ikon.png); */
  font-size: 0.8em;
}

/* Paragrafların ilk harfini büyütme ve renklendirme */
p::first-letter {
  font-size: 2em;
  color: maroon;
  float: left; /* Metnin etrafında akmasını sağlar */
  margin-right: 4px;
}

/* Liste madde işaretlerini değiştirme */
ul li::marker {
  content: "► ";
  color: green;
}

/* Seçilen metnin arka planını ve rengini değiştirme */
::selection {
  background-color: yellow;
  color: black;
}

/* Input placeholder rengini değiştirme */
input::placeholder {
  color: lightgray;
  font-style: italic;
}
                    </code></pre>
                </details>
            </section>

             <section id="kutu-modeli" class="content-section">
                <h2>CSS Kutu Modeli (Box Model)</h2>
                <p>Web sayfasındaki her HTML elemanı, tarayıcı tarafından dikdörtgen bir kutu olarak temsil edilir. CSS Kutu Modeli, bu kutuların yapısını ve boyutlarını nasıl kontrol edeceğimizi tanımlar. Her kutu dört temel bölümden oluşur (içten dışa):</p>
                <ol>
                    <li><strong>İçerik (Content):</strong> Elemanın metin, resim veya diğer iç içe geçmiş kutuları içeren asıl alanıdır. Boyutları <code>width</code> ve <code>height</code> özellikleri ile belirlenir.</li>
                    <li><strong>Dolgu (Padding):</strong> İçerik alanı ile kenarlık (border) arasındaki boşluktur. Elemanın arka plan rengi padding alanını da kapsar. <code>padding-top</code>, <code>padding-right</code>, <code>padding-bottom</code>, <code>padding-left</code> veya kısayol <code>padding</code> özelliği ile kontrol edilir.</li>
                    <li><strong>Kenarlık (Border):</strong> Dolgu alanını çevreleyen çizgidir. Kalınlığı (<code>border-width</code>), stili (<code>border-style</code>: solid, dashed, dotted vb.) ve rengi (<code>border-color</code>) veya kısayol <code>border</code> özelliği ile kontrol edilir.</li>
                    <li><strong>Dış Boşluk (Margin):</strong> Kenarlığın dışındaki, elemanı diğer elemanlardan ayıran şeffaf boşluktur. <code>margin-top</code>, <code>margin-right</code>, <code>margin-bottom</code>, <code>margin-left</code> veya kısayol <code>margin</code> özelliği ile kontrol edilir. Dikey margin'ler bazı durumlarda "çökebilir" (margin collapsing).</li>
                </ol>

                <details class="question-block">
                    <summary><h3><code>width</code>, <code>height</code>, <code>padding</code>, <code>border</code>, <code>margin</code> Özellikleri</h3></summary>
                    <p>Bu özellikler kutu modelinin temelini oluşturur:</p>
                    <pre><code class="language-css">
.kutu {
  /* İçerik Alanı Boyutları */
  width: 300px;       /* Kutu içeriğinin genişliği */
  height: 150px;      /* Kutu içeriğinin yüksekliği */

  /* Dolgu (İç Boşluk) */
  padding-top: 10px;
  padding-right: 20px;
  padding-bottom: 10px;
  padding-left: 20px;
  /* Padding Kısayolu (üst sağ alt sol) */
  padding: 10px 20px; /* üst/alt=10px, sağ/sol=20px */
  /* Padding Kısayolu (üst sağ alt sol) */
  /* padding: 10px 15px 20px 25px; */
  /* Padding Kısayolu (tüm kenarlar aynı) */
  /* padding: 15px; */

  /* Kenarlık */
  border-width: 2px;
  border-style: solid;
  border-color: black;
  /* Border Kısayolu */
  border: 2px solid black;
  /* Tek kenar için: border-left: 5px dotted blue; */
  border-radius: 5px; /* Kenarları yuvarlatma */

  /* Dış Boşluk */
  margin-top: 15px;
  margin-right: auto; /* Sağa doğru otomatik boşluk (ortalamada kullanılabilir) */
  margin-bottom: 30px;
  margin-left: auto;  /* Sola doğru otomatik boşluk (ortalamada kullanılabilir) */
  /* Margin Kısayolu (üst sağ alt sol) */
  margin: 15px auto 30px; /* üst=15px, sağ/sol=auto, alt=30px */
  /* Margin Kısayolu (üst/alt sağ/sol) */
  /* margin: 10px 20px; */
  /* Margin Kısayolu (tüm kenarlar aynı) */
  /* margin: 20px; */

  background-color: lightblue; /* İçerik ve Padding alanını kapsar */
}
                    </code></pre>
                    <p><strong>Önemli Not (Ortalama):</strong> Bir blok seviyesi elemanı (örn: <code><div></code>) yatayda ortalamak için genellikle <code>width</code> değeri belirlenir ve <code>margin-left: auto; margin-right: auto;</code> (veya kısayol <code>margin: 0 auto;</code> gibi) kullanılır.</p>
                </details>

                <details class="question-block">
                    <summary><h3><code>box-sizing</code> Özelliği</h3></summary>
                    <p>Varsayılan olarak (<code>box-sizing: content-box;</code>), bir elemana atanan <code>width</code> ve <code>height</code> özellikleri sadece içerik alanının boyutlarını belirler. Padding ve border bu boyutlara <strong>eklenir</strong>, bu da elemanın toplam kapladığı alanın beklenenden büyük olmasına neden olabilir.</p>
                    <p><code>box-sizing: border-box;</code> değeri ise <code>width</code> ve <code>height</code> özelliklerinin padding ve border'ı <strong>dahil ederek</strong> toplam kutu boyutunu belirlemesini sağlar. Bu, yerleşimi ve boyutlandırmayı çok daha sezgisel ve yönetilebilir hale getirir.</p>
                     <pre><code class="language-css">
.kutu-content {
  width: 200px;
  padding: 20px;
  border: 5px solid red;
  box-sizing: content-box; /* Varsayılan */
  /* Toplam genişlik = 200px (içerik) + 20px*2 (padding) + 5px*2 (border) = 250px */
  background-color: lightcoral;
  margin-bottom: 10px;
}

.kutu-border {
  width: 200px;
  padding: 20px;
  border: 5px solid green;
  box-sizing: border-box; /* Önerilen */
  /* Toplam genişlik = 200px (width ile belirlenen) */
  /* İçerik genişliği = 200px - 20px*2 (padding) - 5px*2 (border) = 150px */
  background-color: lightgreen;
}

/* Genel olarak tüm elemanlara border-box uygulamak yaygın bir pratiktir: */
*,
*::before,
*::after {
  box-sizing: border-box;
}
                    </code></pre>
                    <p>Modern CSS geliştirmede, projenin başında tüm elemanlar için <code>box-sizing: border-box;</code> ayarlamak yaygın ve önerilen bir pratiktir.</p>
                </details>
            </section>

            <section id="yerlesim" class="content-section">
                <h2>CSS Yerleşim (Layout) Teknikleri</h2>
                <p>Web sayfalarındaki elemanların konumlandırılması ve düzenlenmesi CSS'in en önemli görevlerinden biridir. Zaman içinde farklı teknikler gelişmiştir ve modern CSS, Flexbox ve Grid gibi güçlü ve esnek yerleşim modülleri sunar.</p>

                <details class="question-block">
                    <summary><h3><code>display</code> Özelliği</h3></summary>
                    <p>Bir elemanın sayfa akışında nasıl davranacağını ve nasıl bir kutu türü oluşturacağını belirler. En yaygın değerleri:</p>
                    <ul>
                        <li><strong><code>block</code>:</strong> Elemanı bir blok seviyesi kutu yapar. Yeni bir satırda başlar ve genellikle mevcut tüm genişliği kaplar (örn: <code><div></code>, <code><p></code>, <code><h1></code>-<code><h6></code>, <code><ul></code>, <code><li></code>). <code>width</code>, <code>height</code>, <code>margin</code>, <code>padding</code> uygulanabilir.</li>
                        <li><strong><code>inline</code>:</strong> Elemanı bir satır içi kutu yapar. Yeni bir satırda başlamaz ve sadece içeriği kadar genişlik kaplar (örn: <code><span></code>, <code><a></code>, <code><strong></code>, <code><em></code>, <code><img></code>). <code>width</code> ve <code>height</code> doğrudan uygulanamaz. Dikey <code>margin</code> ve <code>padding</code> beklenen etkiyi göstermeyebilir.</li>
                        <li><strong><code>inline-block</code>:</strong> Hem <code>inline</code> hem de <code>block</code> özelliklerini birleştirir. Eleman satır içinde kalır (yeni satıra geçmez) ancak <code>width</code>, <code>height</code>, dikey <code>margin</code> ve <code>padding</code> uygulanabilir. Yan yana durması gereken ama boyutlandırılması da gereken kutular (örn: butonlar, küçük kartlar) için kullanışlıdır.</li>
                        <li><strong><code>none</code>:</strong> Elemanı tamamen gizler ve sayfa düzeninden kaldırır (sanki hiç yokmuş gibi). <code>visibility: hidden;</code>'dan farklıdır (<code>visibility: hidden;</code> elemanı gizler ama yerini korur).</li>
                        <li><strong><code>flex</code>:</strong> Elemanı bir esnek (flex) kutu konteyneri yapar ve içindeki elemanları (flex item) esnek bir şekilde yerleştirmek için Flexbox modelini etkinleştirir (aşağıda detaylı anlatılacak).</li>
                        <li><strong><code>grid</code>:</strong> Elemanı bir grid konteyneri yapar ve içindeki elemanları (grid item) satır ve sütunlardan oluşan bir ızgara üzerinde yerleştirmek için Grid modelini etkinleştirir (aşağıda detaylı anlatılacak).</li>
                        <li><strong><code>inline-flex</code> / <code>inline-grid</code>:</strong> Konteynerin kendisi satır içi (inline) gibi davranırken, içindeki elemanlar flex/grid modeliyle yerleştirilir.</li>
                        <li><strong><code>table</code>, <code>table-row</code>, <code>table-cell</code> vb.:</strong> Elemanların tablo gibi davranmasını sağlar. Modern yerleşimler için genellikle Flexbox veya Grid tercih edilir.</li>
                    </ul>
                     <pre><code class="language-css">
span {
  display: block; /* Span elemanını blok seviyesine çevirir */
  width: 100px;
  height: 50px;
  background-color: yellow;
}

li {
  display: inline-block; /* Liste elemanlarını yan yana getirir */
  margin: 5px;
  padding: 10px;
  border: 1px solid gray;
}

.gizli-bolum {
  display: none; /* Bu bölüm hiç görünmez */
}
                    </code></pre>
                </details>

                <details class="question-block">
                    <summary><h3><code>position</code> Özelliği</h3></summary>
                    <p>Bir elemanın sayfa üzerindeki konumlandırma yöntemini belirler.</p>
                    <ul>
                        <li><strong><code>static</code>:</strong> Varsayılan değerdir. Eleman normal sayfa akışına göre konumlanır. <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> ve <code>z-index</code> özellikleri bu eleman üzerinde etkili olmaz.</li>
                        <li><strong><code>relative</code>:</strong> Eleman normal sayfa akışına göre konumlanır, ancak ardından <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> özellikleri kullanılarak normal konumuna <strong>göre</strong> kaydırılabilir. Diğer elemanlar, eleman kaydırılmamış gibi davranır (yani elemanın orijinal yeri boş kalmaz). Genellikle mutlak konumlandırılmış (<code>absolute</code>) çocuk elemanlar için bir referans noktası (containing block) oluşturmak amacıyla kullanılır.</li>
                        <li><strong><code>absolute</code>:</strong> Elemanı normal sayfa akışından tamamen çıkarır. Konumu, <code>position</code> değeri <code>static</code> olmayan en yakın üst elemanına (containing block) göre belirlenir. Eğer böyle bir üst eleman yoksa, ilk containing block <code>&lt;html></code> elemanı olur. Konumu <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> ile ayarlanır. Diğer elemanlar, bu eleman hiç yokmuş gibi davranır.</li>
                        <li><strong><code>fixed</code>:</strong> Elemanı normal sayfa akışından çıkarır ve tarayıcı penceresine (viewport) göre sabitler. Sayfa kaydırılsa bile eleman aynı konumda kalır. Konumu <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> ile ayarlanır. Genellikle sabit başlıklar, alt bilgiler veya "üste dön" butonları için kullanılır.</li>
                        <li><strong><code>sticky</code>:</strong> Eleman, normal sayfa akışı içinde (<code>relative</code> gibi) davranır, ancak kullanıcı sayfayı kaydırdığında belirli bir eşik noktasına (<code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> ile tanımlanır) ulaştığında, o noktada sabitlenir (<code>fixed</code> gibi). Eşik noktası geçildiğinde tekrar normal akışa dönebilir. Modern tarayıcı desteği iyidir. Genellikle kaydırılan listedeki başlıkları sabitlemek için kullanılır.</li>
                    </ul>
                    <p><code>relative</code>, <code>absolute</code>, <code>fixed</code>, ve <code>sticky</code> konumlandırma yöntemleri ile birlikte <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> özellikleri kullanılarak elemanın kenarlara olan mesafesi belirlenir. <code>z-index</code> özelliği ise üst üste binen konumlandırılmış elemanların yığın sırasını (hangisinin üstte görüneceğini) belirler (daha büyük <code>z-index</code> değeri daha üstte görünür).</p>
                    <pre><code class="language-css">
.konteyner {
  position: relative; /* Absolute konumlu çocuk için referans */
  width: 400px;
  height: 300px;
  border: 1px solid black;
}

.mutlak-kutu {
  position: absolute;
  top: 20px;
  right: 20px;
  width: 100px;
  height: 100px;
  background-color: rgba(255, 0, 0, 0.5); /* Yarı şeffaf kırmızı */
}

.sabit-kutu {
  position: fixed;
  bottom: 10px;
  right: 10px;
  padding: 10px;
  background-color: lightblue;
  z-index: 100; /* Diğer elemanların üzerinde görünmesi için */
}

.yapışkan-başlık {
  position: sticky;
  top: 0; /* Sayfanın en üstüne yapışır */
  background-color: white;
  padding: 10px;
  border-bottom: 1px solid #ccc;
  z-index: 50;
}
                    </code></pre>
                </details>

                 <details class="question-block">
                    <summary><h3><code>float</code> Özelliği ve <code>clear</code></h3></summary>
                    <p><code>float</code> özelliği, bir elemanı normal akıştan çıkarıp sola (<code>left</code>) veya sağa (<code>right</code>) yaslayarak diğer içeriklerin etrafında akmasını sağlar. Eskiden çok sütunlu yerleşimler için sıkça kullanılırdı, ancak modern yerleşimler için Flexbox ve Grid daha uygundur. <code>float</code> hala resimleri metin içinde sola/sağa yaslamak gibi durumlar için kullanışlıdır.</p>
                    <p><code>float</code> kullanılan elemanlar, çevreleyen konteynerin yüksekliğini etkilemez (konteyner çökebilir). Bu sorunu çözmek için çeşitli "clearfix" teknikleri kullanılır veya modern yöntemde konteynere <code>display: flow-root;</code> verilebilir.</p>
                    <p><code>clear</code> özelliği, bir elemanın hangi taraftaki (<code>left</code>, <code>right</code>, <code>both</code>) float'lı elemanların altına ineceğini belirler. Genellikle float'lardan sonra gelen elemanların normal akışa dönmesi için kullanılır.</p>
                     <pre><code class="language-css">
.resim-sola {
  float: left;
  margin-right: 15px; /* Resimle metin arasına boşluk */
  margin-bottom: 5px;
}

.resim-saga {
  float: right;
  margin-left: 15px;
  margin-bottom: 5px;
}

.footer-bolumu {
  clear: both; /* Hem sol hem de sağ float'lardan sonra başlar */
  border-top: 1px solid gray;
  margin-top: 20px;
  padding-top: 10px;
}

/* Konteynerin float'lı elemanları sarması için */
.clearfix::after { /* Klasik clearfix hack */
  content: "";
  display: table;
  clear: both;
}
/* VEYA Modern Yöntem */
.konteyner-flow-root {
    display: flow-root;
}
                    </code></pre>
                     <pre><code class="language-html">
<div class="clearfix"> <!-- Veya class="konteyner-flow-root" -->
    <img src="profil.jpg" alt="Profil Resmi" class="resim-sola" width="100">
    <p>Bu metin, sola yaslanmış resmin etrafında akacaktır. Float özelliği, elemanı normal akıştan çıkarır ve belirtilen yöne yaslar...</p>
</div>
<footer class="footer-bolumu">
    Alt bilgi içeriği...
</footer>
                    </code></pre>
                 </details>

                <details class="question-block">
                    <summary><h3>Flexbox (Esnek Kutu Modeli)</h3></summary>
                    <p>Flexbox, bir konteyner içindeki elemanları (öğeleri) tek bir boyut (satır veya sütun) boyunca hizalamak, dağıtmak ve sıralamak için tasarlanmış güçlü bir yerleşim modülüdür. Özellikle bileşenleri (menüler, kart listeleri vb.) ve basit yerleşimleri oluşturmak için idealdir.</p>
                    <p>Flexbox kullanmak için:</p>
                    <ol>
                        <li>Üst elemana (konteyner) <code>display: flex;</code> veya <code>display: inline-flex;</code> uygulanır.</li>
                        <li>Konteyner özellikleri (<code>flex-direction</code>, <code>justify-content</code>, <code>align-items</code>, <code>flex-wrap</code>, <code>align-content</code>) ile öğelerin ana eksen ve çapraz eksendeki davranışları kontrol edilir.</li>
                        <li>Gerekirse, içindeki öğelere (flex item) özel özellikler (<code>flex-grow</code>, <code>flex-shrink</code>, <code>flex-basis</code>, <code>order</code>, <code>align-self</code>) uygulanır.</li>
                    </ol>
                    <p><strong>Konteyner Özellikleri:</strong></p>
                    <ul>
                        <li><strong><code>flex-direction</code>:</strong> Öğelerin dizilim yönünü belirler (<code>row</code> (varsayılan - yatay), <code>row-reverse</code>, <code>column</code> (dikey), <code>column-reverse</code>). Bu, ana ekseni (main axis) tanımlar.</li>
                        <li><strong><code>justify-content</code>:</strong> Öğeleri ana eksen boyunca nasıl hizalayacağını/dağıtacağını belirler (<code>flex-start</code> (varsayılan), <code>flex-end</code>, <code>center</code>, <code>space-between</code>, <code>space-around</code>, <code>space-evenly</code>).</li>
                        <li><strong><code>align-items</code>:</strong> Öğeleri çapraz eksen (cross axis - ana eksene dik olan eksen) boyunca nasıl hizalayacağını belirler (<code>stretch</code> (varsayılan - konteyner boyutuna uzatır), <code>flex-start</code>, <code>flex-end</code>, <code>center</code>, <code>baseline</code>).</li>
                        <li><strong><code>flex-wrap</code>:</strong> Öğeler konteynere sığmadığında alt satıra/sütuna geçip geçmeyeceğini belirler (<code>nowrap</code> (varsayılan - sığdırmaya çalışır), <code>wrap</code>, <code>wrap-reverse</code>).</li>
                        <li><strong><code>align-content</code>:</strong> Birden fazla satır/sütun oluştuğunda (<code>flex-wrap: wrap;</code> kullanıldığında) bu satırların/sütunların çapraz eksen boyunca nasıl hizalanacağını/dağıtılacağını belirler (<code>stretch</code> (varsayılan), <code>flex-start</code>, <code>flex-end</code>, <code>center</code>, <code>space-between</code>, <code>space-around</code>). <code>align-items</code>'dan farklıdır, bu tüm satırları bir bütün olarak hizalar.</li>
                        <li><strong><code>gap</code> (veya <code>row-gap</code>, <code>column-gap</code>):</strong> Flex öğeleri arasındaki boşluğu belirler.</li>
                    </ul>
                     <p><strong>Öğe (Item) Özellikleri:</strong></p>
                     <ul>
                        <li><strong><code>order</code>:</strong> Öğelerin varsayılan sıralamasını değiştirir (küçük değer önce gelir, varsayılan 0).</li>
                        <li><strong><code>flex-grow</code>:</strong> Konteynerde boş alan varsa, öğenin bu alanı diğer öğelere göre ne kadar büyüyeceğini belirler (varsayılan 0 - büyümez). Pozitif bir sayı alır.</li>
                        <li><strong><code>flex-shrink</code>:</strong> Öğeler konteynere sığmadığında, öğenin diğer öğelere göre ne kadar küçüleceğini belirler (varsayılan 1 - küçülür). 0 verilirse küçülmez.</li>
                        <li><strong><code>flex-basis</code>:</strong> Öğenin ana eksendeki varsayılan boyutunu belirler (<code>auto</code> (varsayılan) veya bir uzunluk değeri <code>100px</code>, <code>30%</code> gibi).</li>
                        <li><strong><code>flex</code> (Kısayol):</strong> <code>flex-grow</code>, <code>flex-shrink</code> ve <code>flex-basis</code> özelliklerini sırayla tek bir özellikte birleştirir (örn: <code>flex: 0 1 auto;</code> (varsayılan), <code>flex: 1;</code> (<code>1 1 0%</code> anlamına gelir), <code>flex: auto;</code> (<code>1 1 auto</code>)).</li>
                        <li><strong><code>align-self</code>:</strong> Tek bir öğenin çapraz eksendeki hizalamasını, konteynerin <code>align-items</code> ayarını geçersiz kılarak belirler (<code>auto</code> (varsayılan - konteynerden alır), <code>stretch</code>, <code>flex-start</code>, <code>flex-end</code>, <code>center</code>, <code>baseline</code>).</li>
                     </ul>
                     <pre><code class="language-css">
.flex-konteyner {
  display: flex;
  flex-direction: row; /* Yatay dizilim (varsayılan) */
  justify-content: space-around; /* Ana eksende aralıklı dağıt */
  align-items: center; /* Çapraz eksende ortala */
  flex-wrap: wrap; /* Sığmazsa alt satıra geç */
  gap: 10px; /* Öğeler arası boşluk */
  height: 200px; /* align-items'ı görmek için */
  background-color: lightgray;
  padding: 10px;
}

.flex-oge {
  background-color: dodgerblue;
  color: white;
  padding: 15px;
  text-align: center;
  border-radius: 4px;
  /* flex: 1; */ /* Öğelerin boş alanı eşit paylaşmasını sağlar */
}

.oge-farkli {
  flex-grow: 2; /* Diğerlerinden 2 kat fazla büyür */
  align-self: flex-start; /* Konteynerin align-items'ını ezer, yukarı hizalar */
  order: -1; /* En başa alır */
  background-color: tomato;
}
                    </code></pre>
                     <pre><code class="language-html">
<div class="flex-konteyner">
  <div class="flex-oge">Öğe 1</div>
  <div class="flex-oge oge-farkli">Öğe 2 (Farklı)</div>
  <div class="flex-oge">Öğe 3</div>
  <div class="flex-oge">Öğe 4</div>
</div>
                    </code></pre>
                </details>

                <details class="question-block">
                    <summary><h3>CSS Grid Layout</h3></summary>
                    <p>CSS Grid, hem satırları hem de sütunları tanımlayarak iki boyutlu karmaşık web sayfası yerleşimleri oluşturmak için tasarlanmış çok güçlü bir yerleşim sistemidir. Flexbox genellikle tek boyutlu yerleşimler için daha uygunken, Grid tüm sayfa düzenini veya karmaşık bileşenleri ızgara üzerinde hassas bir şekilde kontrol etmek için idealdir.</p>
                     <p>Grid kullanmak için:</p>
                    <ol>
                        <li>Üst elemana (konteyner) <code>display: grid;</code> veya <code>display: inline-grid;</code> uygulanır.</li>
                        <li><code>grid-template-columns</code> ve <code>grid-template-rows</code> özellikleri ile ızgaranın sütun ve satır yapısı (sayısı ve boyutları) tanımlanır. Yeni <code>fr</code> birimi (fraction - oran) esnek boyutlandırma sağlar.</li>
                        <li>Öğeler (grid item) varsayılan olarak ızgaranın hücrelerine sırayla yerleşir.</li>
                        <li>Gerekirse, öğelerin ızgara üzerindeki konumları ve yayılımları <code>grid-column-start</code>, <code>grid-column-end</code>, <code>grid-row-start</code>, <code>grid-row-end</code> (veya kısayolları <code>grid-column</code>, <code>grid-row</code>) veya <code>grid-area</code> özellikleri ile hassas bir şekilde belirlenir.</li>
                        <li>Hizalama için <code>justify-items</code>, <code>align-items</code> (hücre içindeki öğe hizalaması) ve <code>justify-content</code>, <code>align-content</code> (tüm ızgaranın konteyner içindeki hizalaması) özellikleri kullanılır.</li>
                        <li><code>gap</code> (veya <code>row-gap</code>, <code>column-gap</code>) ile ızgara çizgileri arasındaki boşluk ayarlanır.</li>
                    </ol>
                    <p><strong>Temel Konteyner Özellikleri:</strong></p>
                    <ul>
                        <li><strong><code>grid-template-columns</code>:</strong> Sütunların genişliğini tanımlar (örn: <code>100px 1fr 2fr</code> - ilk sütun 100px, ikinci sütun kalan alanın 1/3'ü, üçüncü sütun 2/3'ü). <code>repeat()</code> fonksiyonu kullanılabilir (örn: <code>repeat(3, 1fr)</code> - 3 eşit sütun).</li>
                        <li><strong><code>grid-template-rows</code>:</strong> Satırların yüksekliğini tanımlar (örn: <code>auto 100px repeat(2, 50px)</code>).</li>
                        <li><strong><code>grid-template-areas</code>:</strong> Izgara alanlarına isim vererek daha görsel bir yerleşim tanımı sağlar.</li>
                        <li><strong><code>gap</code>, <code>row-gap</code>, <code>column-gap</code>:</strong> Izgara çizgileri arasındaki boşluklar.</li>
                        <li><strong>Hizalama:</strong> <code>justify-items</code> (satır ekseninde hücre içi), <code>align-items</code> (sütun ekseninde hücre içi), <code>justify-content</code> (satır ekseninde tüm grid), <code>align-content</code> (sütun ekseninde tüm grid). Değerler genellikle <code>start</code>, <code>end</code>, <code>center</code>, <code>stretch</code>, <code>space-between</code>, <code>space-around</code>, <code>space-evenly</code> olabilir.</li>
                    </ul>
                    <p><strong>Temel Öğe (Item) Özellikleri:</strong></p>
                     <ul>
                        <li><strong><code>grid-column-start</code> / <code>grid-column-end</code>:</strong> Öğenin hangi sütun çizgisinde başlayıp biteceğini belirler.</li>
                        <li><strong><code>grid-row-start</code> / <code>grid-row-end</code>:</strong> Öğenin hangi satır çizgisinde başlayıp biteceğini belirler.</li>
                        <li><strong><code>grid-column</code> (Kısayol):</strong> <code>grid-column-start / grid-column-end</code> (örn: <code>1 / 3</code>, <code>1 / span 2</code> - 1. çizgiden başla, 2 sütun yayıl).</li>
                        <li><strong><code>grid-row</code> (Kısayol):</strong> <code>grid-row-start / grid-row-end</code>.</li>
                        <li><strong><code>grid-area</code>:</strong> Öğeyi isimlendirilmiş bir ızgara alanına yerleştirir (<code>grid-template-areas</code> ile kullanılır) VEYA dört çizgi değerini (row-start / col-start / row-end / col-end) tanımlar.</li>
                        <li><strong>Hizalama:</strong> <code>justify-self</code> (hücre içinde yatay hizalama), <code>align-self</code> (hücre içinde dikey hizalama). Konteynerin <code>justify-items</code>/<code>align-items</code> ayarlarını geçersiz kılar.</li>
                     </ul>
                    <pre><code class="language-css">
.grid-konteyner {
  display: grid;
  /* 3 sütun: ilk 150px, diğer ikisi kalan alanı eşit paylaşır */
  grid-template-columns: 150px 1fr 1fr;
  /* 2 satır: ilki içeriğe göre, ikincisi 100px yükseklikte */
  grid-template-rows: auto 100px;
  gap: 15px; /* Satır ve sütun aralığı */
  width: 100%;
  background-color: #eee;
  padding: 10px;

  /* İsimlendirilmiş alanlarla alternatif tanım */
  /* grid-template-areas:
    "baslik baslik baslik"
    "menu icerik kenar"
    "altbilgi altbilgi altbilgi";
  grid-template-columns: 150px 1fr 200px;
  grid-template-rows: auto 1fr auto; */
}

.grid-oge {
  background-color: lightcoral;
  padding: 20px;
  border: 1px solid darkred;
  text-align: center;
}

.oge1 {
  grid-column-start: 1;
  grid-column-end: 4; /* 1. sütundan başla 4. çizgide bitir (3 sütun kapla) */
  /* Kısayol: grid-column: 1 / 4; */
  /* grid-area: baslik; */ /* İsimlendirilmiş alan kullanılıyorsa */
}

.oge2 {
  grid-row: 2 / 4; /* 2. satırdan başla 4. çizgide bitir (2 satır kapla) */
  /* Kısayol: grid-row: 2 / span 2; */
   /* grid-area: menu; */
}

.oge3 {
    grid-column: 2 / span 2; /* 2. sütundan başla, 2 sütun yayıl */
     /* grid-area: icerik; */
     align-self: start; /* Hücre içinde yukarı hizala */
}
                    </code></pre>
                    <pre><code class="language-html">
<div class="grid-konteyner">
  <div class="grid-oge oge1">Başlık (1)</div>
  <div class="grid-oge oge2">Menü (2)</div>
  <div class="grid-oge oge3">İçerik (3)</div>
  <div class="grid-oge">Kenar (4)</div>
  <div class="grid-oge">Alt Bilgi (5)</div>
</div>
                    </code></pre>
                </details>
            </section>

            <section id="duyarli" class="content-section">
                <h2>Duyarlı Web Tasarımı (Responsive Web Design - RWD)</h2>
                <p>Duyarlı web tasarımı, bir web sitesinin düzeninin ve içeriğinin, kullanıldığı cihazın ekran boyutuna, yönlendirmesine ve çözünürlüğüne (masaüstü, tablet, telefon vb.) otomatik olarak uyum sağlaması yaklaşımıdır. Amaç, tüm cihazlarda optimum görüntüleme ve etkileşim deneyimi sunmaktır.</p>
                <p>RWD'nin temel bileşenleri şunlardır:</p>
                <ul>
                    <li><strong>Esnek Izgaralar (Fluid Grids):</strong> Sabit piksel değerleri yerine yüzdeler (<code>%</code>) veya esnek birimler (<code>fr</code>, <code>vw</code>, <code>vh</code>) kullanarak esnek ve orantılı yerleşimler oluşturmak.</li>
                    <li><strong>Esnek Görseller (Flexible Images):</strong> Görsellerin ve diğer medya içeriklerinin, içinde bulundukları konteynerin boyutlarına uyum sağlaması (genellikle <code>max-width: 100%; height: auto;</code> ile).</li>
                    <li><strong>Medya Sorguları (Media Queries):</strong> Farklı cihaz özellikleri (genişlik, yükseklik, yönlendirme, çözünürlük vb.) için farklı CSS kuralları uygulamayı sağlayan CSS3 özelliğidir.</li>
                </ul>

                 <details class="question-block">
                    <summary><h3>Medya Sorguları (<code>@media</code>)</h3></summary>
                    <p>Medya sorguları, belirli koşullar sağlandığında uygulanacak CSS kurallarını tanımlar. Bu, RWD'nin temel taşıdır.</p>
                    <p>Sözdizimi:</p>
                    <pre><code class="language-css">
@media media-türü and (özellik: değer) {
  /* Koşul sağlandığında uygulanacak CSS kuralları */
  secici {
    ozellik: deger;
  }
}
                    </code></pre>
                    <ul>
                        <li><strong><code>@media</code>:</strong> Medya sorgusu bloğunu başlatır.</li>
                        <li><strong><code>media-türü</code> (isteğe bağlı):</strong> Kuralın hangi medya türü için geçerli olduğunu belirtir (<code>all</code> (varsayılan), <code>print</code> (yazdırma), <code>screen</code> (ekranlar), <code>speech</code> (ekran okuyucular)).</li>
                        <li><strong><code>and</code> / <code>not</code> / <code>only</code> (isteğe bağlı):</strong> Mantıksal operatörlerle birden fazla koşul birleştirilebilir veya koşul tersine çevrilebilir. <code>only</code> eski tarayıcıların sorguyu yok saymasını sağlar.</li>
                        <li><strong><code>(özellik: değer)</code>:</strong> Asıl koşuldur. Parantez içinde belirtilir. En yaygın kullanılan özellikler:
                            <ul>
                                <li><code>width</code> / <code>height</code>: Tarayıcı penceresinin (viewport) genişliği/yüksekliği.</li>
                                <li><code>min-width</code> / <code>max-width</code>: Minimum/maksimum genişlik.</li>
                                <li><code>min-height</code> / <code>max-height</code>: Minimum/maksimum yükseklik.</li>
                                <li><code>orientation</code>: Cihazın yönlendirmesi (<code>portrait</code> (dikey) veya <code>landscape</code> (yatay)).</li>
                                <li><code>aspect-ratio</code> / <code>min-aspect-ratio</code> / <code>max-aspect-ratio</code>: Görüntü alanının en/boy oranı.</li>
                                <li><code>resolution</code> / <code>min-resolution</code> / <code>max-resolution</code>: Cihazın piksel yoğunluğu (örn: <code>dpi</code>, <code>dpcm</code>).</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>Yaklaşımlar:</strong></p>
                    <ul>
                        <li><strong>Desktop First:</strong> Önce masaüstü stilleri yazılır, ardından daha küçük ekranlar için <code>max-width</code> ile medya sorguları kullanılarak stiller uyarlanır.</li>
                        <li><strong>Mobile First:</strong> Önce mobil cihaz stilleri yazılır, ardından daha büyük ekranlar için <code>min-width</code> ile medya sorguları kullanılarak stiller genişletilir. Modern web geliştirmede genellikle <strong>Mobile First</strong> yaklaşımı tercih edilir çünkü daha basit stillerle başlayıp gerektiğinde karmaşıklık eklemeyi sağlar ve mobil kullanıcı deneyimini önceliklendirir.</li>
                    </ul>
                     <pre><code class="language-css">
/* Mobile First Yaklaşımı Örneği */

/* Varsayılan stiller (Mobil için) */
body {
  font-size: 16px;
}
.konteyner {
  width: 95%;
  margin: 0 auto;
}
.menu {
  /* Mobil menü stilleri (belki gizli, butonla açılır) */
  display: none;
}
.kolon {
  width: 100%; /* Kolonlar alt alta */
  margin-bottom: 15px;
}

/* Tablet Boyutu (Örn: 600px ve üzeri) */
@media screen and (min-width: 600px) {
  .konteyner {
    width: 90%;
  }
  .menu {
     display: block; /* Menüyü göster */
     /* Belki yatay menü stilleri */
  }
  .kolon {
     width: 48%; /* İki kolon yan yana */
     display: inline-block; /* Veya Flexbox/Grid kullanılır */
     margin-right: 4%;
  }
  .kolon:last-child {
      margin-right: 0;
  }
}

/* Masaüstü Boyutu (Örn: 992px ve üzeri) */
@media screen and (min-width: 992px) {
  body {
    font-size: 18px;
  }
  .konteyner {
    width: 80%;
    max-width: 1200px; /* Maksimum genişlik */
  }
   /* Belki 3 veya 4 kolonlu yapı */
  .kolon {
     width: 30%;
     margin-right: 5%;
   }
  .kolon:nth-child(3n) { /* Her 3. kolondan sonra sağ boşluğu kaldır */
      margin-right: 0;
  }
   .kolon:last-child { /* Eğer 3'ün katı değilse son elemanın boşluğunu ayarla */
       margin-right: 0; /* Veya duruma göre ayarlanır */
   }
}

/* Sadece Yazdırma İçin Stiller */
@media print {
  body {
    font-family: 'Times New Roman', serif;
    color: black;
    background-color: white;
  }
  a::after {
    content: " (" attr(href) ")"; /* Bağlantı URL'lerini göster */
  }
  .menu, .reklamlar, .footer-nav {
    display: none; /* Yazdırmada gereksiz elemanları gizle */
  }
}
                    </code></pre>
                    <p>Unutmayın, RWD için HTML'de <code><meta name="viewport" content="width=device-width, initial-scale=1.0"></code> etiketinin bulunması kritik öneme sahiptir.</p>
                 </details>
            </section>

            <section id="ileri" class="content-section">
                <h2>İleri CSS Konuları</h2>
                <p>CSS'in temellerini ve yerleşim modellerini öğrendikten sonra, tasarımlarınıza daha fazla dinamizm katacak ve kodunuzu daha verimli hale getirecek ileri konulara geçebilirsiniz.</p>

                 <details class="question-block">
                    <summary><h3>CSS Geçişleri (Transitions)</h3></summary>
                    <p>CSS geçişleri, bir CSS özelliğinin değeri değiştiğinde (örneğin <code>:hover</code> durumunda), bu değişikliğin ani olmak yerine belirli bir süre içinde yumuşak bir şekilde gerçekleşmesini sağlar. Basit animasyon efektleri oluşturmak için kullanılır.</p>
                    <p>Temel Özellikler:</p>
                    <ul>
                        <li><strong><code>transition-property</code>:</strong> Geçiş efekti uygulanacak CSS özelliğini (veya özelliklerini <code>all</code> ile) belirtir.</li>
                        <li><strong><code>transition-duration</code>:</strong> Geçişin ne kadar süreceğini belirtir (örn: <code>0.5s</code>, <code>300ms</code>).</li>
                        <li><strong><code>transition-timing-function</code>:</strong> Geçişin hız eğrisini belirler (nasıl başlayıp nasıl biteceği) (<code>ease</code> (varsayılan), <code>linear</code>, <code>ease-in</code>, <code>ease-out</code>, <code>ease-in-out</code>, <code>cubic-bezier(...)</code>).</li>
                        <li><strong><code>transition-delay</code>:</strong> Geçişin başlamadan önce ne kadar bekleyeceğini belirtir.</li>
                        <li><strong><code>transition</code> (Kısayol):</strong> Yukarıdaki dört özelliği sırayla tek bir satırda tanımlar. En sık kullanılan sıra: <code>property duration timing-function delay</code>.</li>
                    </ul>
                     <pre><code class="language-css">
.buton {
  background-color: blue;
  color: white;
  padding: 10px 20px;
  border: none;
  border-radius: 5px;
  cursor: pointer;

  /* Kısayol transition tanımı:
     Arka plan rengi 0.3 saniyede ease-out ile,
     transform 0.2 saniyede ease-in ile değişsin */
  transition: background-color 0.3s ease-out, transform 0.2s ease-in;

  /* Veya tüm özellikler için: */
  /* transition: all 0.3s ease; */
}

.buton:hover {
  background-color: darkblue;
  transform: scale(1.1); /* Butonu hafifçe büyüt */
}

.kutu {
    width: 100px;
    height: 100px;
    background-color: red;
    opacity: 1;
    transition: width 2s linear, height 1s ease-in 1s, opacity 0.5s; /* Birden fazla özellik farklı süre/zamanlama/gecikme ile */
}

.kutu:hover {
    width: 200px;
    height: 150px;
    opacity: 0.5;
}
                    </code></pre>
                 </details>

                 <details class="question-block">
                    <summary><h3>CSS Animasyonları (<code>@keyframes</code> ve <code>animation</code>)</h3></summary>
                    <p>CSS animasyonları, geçişlerden daha karmaşık ve kontrol edilebilir animasyonlar oluşturmayı sağlar. Animasyonlar, <code>@keyframes</code> kuralı ile tanımlanır ve ardından <code>animation</code> özellikleri ile bir elemana uygulanır.</p>
                    <p><strong><code>@keyframes</code> Kuralı:</strong> Animasyonun farklı aşamalarındaki (keyframe) stilleri tanımlar. Yüzdeler (<code>0%</code>'dan <code>100%</code>'e) veya anahtar kelimeler (<code>from</code> (<code>0%</code> ile aynı), <code>to</code> (<code>100%</code> ile aynı)) kullanılır.</p>
                    <pre><code class="language-css">
/* Basit bir renk değiştirme animasyonu */
@keyframes renkDegistir {
  from { background-color: red; }
  to { background-color: yellow; }
}

/* Daha karmaşık bir sallanma animasyonu */
@keyframes salla {
  0% { transform: translateX(0); }
  25% { transform: translateX(-10px) rotate(-5deg); }
  50% { transform: translateX(10px) rotate(5deg); }
  75% { transform: translateX(-5px) rotate(-3deg); }
  100% { transform: translateX(0) rotate(0); }
}
                    </code></pre>
                    <p><strong><code>animation</code> Özellikleri:</strong></p>
                     <ul>
                        <li><strong><code>animation-name</code>:</strong> Uygulanacak <code>@keyframes</code> kuralının adını belirtir.</li>
                        <li><strong><code>animation-duration</code>:</strong> Animasyonun bir döngüsünün ne kadar süreceğini belirtir.</li>
                        <li><strong><code>animation-timing-function</code>:</strong> Animasyonun hız eğrisini belirler (<code>transition-timing-function</code> ile aynı değerleri alır).</li>
                        <li><strong><code>animation-delay</code>:</strong> Animasyonun başlamadan önce ne kadar bekleyeceğini belirtir.</li>
                        <li><strong><code>animation-iteration-count</code>:</strong> Animasyonun kaç kez tekrarlanacağını belirtir (bir sayı veya <code>infinite</code> (sonsuz)).</li>
                        <li><strong><code>animation-direction</code>:</strong> Animasyonun döngülerde tersine oynatılıp oynatılmayacağını belirler (<code>normal</code> (varsayılan), <code>reverse</code>, <code>alternate</code> (ileri-geri), <code>alternate-reverse</code>).</li>
                        <li><strong><code>animation-fill-mode</code>:</strong> Animasyon başlamadan önce veya bittikten sonra elemanın hangi stilleri alacağını belirler (<code>none</code> (varsayılan), <code>forwards</code> (son keyframe stilini korur), <code>backwards</code> (ilk keyframe stilini başlangıçta uygular), <code>both</code>).</li>
                        <li><strong><code>animation-play-state</code>:</strong> Animasyonun çalışıp (<code>running</code> - varsayılan) duraklatıldığını (<code>paused</code>) kontrol eder (genellikle JavaScript ile kullanılır).</li>
                        <li><strong><code>animation</code> (Kısayol):</strong> Yukarıdaki özellikleri (play-state hariç) tek satırda tanımlar. Sıra genellikle: <code>name duration timing-function delay iteration-count direction fill-mode</code>.</li>
                    </ul>
                     <pre><code class="language-css">
.animasyonlu-kutu {
  width: 100px;
  height: 100px;
  background-color: red; /* 'from' ile aynı olmalı (eğer fill-mode: backwards isteniyorsa) */

  /* Kısayol animation tanımı */
  animation: renkDegistir 3s ease-in-out 1s infinite alternate;
  /* İsim: renkDegistir, Süre: 3s, Zamanlama: ease-in-out, Gecikme: 1s, Tekrar: sonsuz, Yön: ileri-geri */
}

.sallanan-ikon {
    display: inline-block;
    animation: salla 1s ease-in-out infinite;
}

/* Hover durumunda animasyonu duraklatma */
.animasyonlu-kutu:hover {
  animation-play-state: paused;
}
                    </code></pre>
                 </details>

                 <details class="question-block">
                    <summary><h3>CSS Değişkenleri (Custom Properties)</h3></summary>
                    <p>CSS Değişkenleri (resmi adıyla Custom Properties for Cascading Variables), CSS içinde tekrar tekrar kullanılan değerleri (renkler, font boyutları, boşluklar vb.) tanımlamak ve yönetmek için güçlü bir mekanizmadır. Değişkenler, kod tekrarını azaltır, bakımı kolaylaştırır ve tema oluşturmayı basitleştirir.</p>
                    <p><strong>Tanımlama:</strong> Değişkenler genellikle <code>:root</code> sözde sınıfı içinde (tüm belgeye uygulanması için) tanımlanır. İsimleri iki tire (<code>--</code>) ile başlar.</p>
                    <p><strong>Kullanma:</strong> Değişken değeri, <code>var()</code> fonksiyonu kullanılarak çağrılır.</p>
                     <pre><code class="language-css">
/* Değişkenleri :root içinde tanımlama */
:root {
  --ana-renk: #007bff;
  --ikincil-renk: #6c757d;
  --golge-rengi: rgba(0, 0, 0, 0.1);
  --ana-font: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  --kenar-boslugu: 15px;
  --kutu-golgesi: 0 2px 5px var(--golge-rengi);
}

/* Değişkenleri kullanma */
body {
  font-family: var(--ana-font);
  color: var(--ikincil-renk);
}

.buton-birincil {
  background-color: var(--ana-renk);
  color: white;
  padding: var(--kenar-boslugu);
  border: none;
  box-shadow: var(--kutu-golgesi);
}

.kart {
  padding: var(--kenar-boslugu);
  margin-bottom: var(--kenar-boslugu);
  box-shadow: var(--kutu-golgesi);
  border-left: 5px solid var(--ana-renk);
}

/* Bir değişken için varsayılan (fallback) değer tanımlama */
.ozel-alan {
    color: var(--tanimsiz-degisken, black); /* Eğer --tanimsiz-degisken yoksa black kullanılır */
}

/* Değişkenler JavaScript ile değiştirilebilir (Tema değiştirme vb.) */
/* document.documentElement.style.setProperty('--ana-renk', 'darkred'); */
                    </code></pre>
                    <p>CSS Değişkenleri, kademelenme ve kalıtım kurallarına uyar, yani belirli bir seçici içinde tanımlanarak sadece o kapsamdaki değeri geçersiz kılabilirler.</p>
                 </details>

                <details class="question-block">
                    <summary><h3>CSS Ön İşlemcileri (Preprocessors): Sass, Less, Stylus</h3></summary>
                    <p>CSS ön işlemcileri, standart CSS'in yeteneklerini artıran, daha verimli ve yönetilebilir stil dosyaları yazmayı sağlayan betik dilleridir. Yazılan özel sözdizimi (değişkenler, iç içe kurallar, mixin'ler, fonksiyonlar, kalıtım vb. özellikler içerir) derlenerek tarayıcıların anlayabileceği standart CSS koduna dönüştürülür.</p>
                    <p>En popüler ön işlemciler:</p>
                    <ul>
                        <li><strong>Sass (Syntactically Awesome Style Sheets):</strong> En yaygın kullanılanlardan biridir. İki farklı sözdizimi sunar: SCSS (CSS'e çok benzer, <code>{ }</code> ve <code>;</code> kullanır) ve SASS (girintiye dayalı, daha kısa).</li>
                        <li><strong>Less (Leaner Style Sheets):</strong> Sass'a benzer özellikler sunar, JavaScript tabanlıdır.</li>
                        <li><strong>Stylus:</strong> Çok esnek bir sözdizimine sahiptir (süslü parantez, iki nokta üst üste, noktalı virgül kullanımı isteğe bağlıdır).</li>
                    </ul>
                    <p><strong>Sağladığı Avantajlar:</strong></p>
                    <ul>
                        <li><strong>Değişkenler:</strong> Renkleri, fontları vb. merkezi olarak tanımlama (standart CSS değişkenlerinden önce popülerdi).</li>
                        <li><strong>İç İçe Kurallar (Nesting):</strong> HTML yapısını yansıtan, daha okunabilir CSS kuralları yazma.</li>
                        <li><strong>Mixin'ler:</strong> Tekrar kullanılabilir stil blokları oluşturma (parametre alabilirler).</li>
                        <li><strong>Kalıtım (Inheritance / Extend):</strong> Bir seçicinin stillerini başka bir seçiciye kopyalama.</li>
                        <li><strong>Fonksiyonlar:</strong> Değerleri hesaplamak veya dönüştürmek için özel fonksiyonlar tanımlama.</li>
                        <li><strong>Parçalar (Partials) ve İçe Aktarma (Import):</strong> CSS kodunu daha küçük, yönetilebilir dosyalara bölme ve bunları ana dosyada birleştirme.</li>
                        <li><strong>Operatörler:</strong> Matematiksel işlemler yapma.</li>
                    </ul>
                     <p>Örnek SCSS Kodu:</p>
                     <pre><code class="language-scss">
$ana-renk: #3498db;
$kenarlik-rengi: darken($ana-renk, 10%);
$varsayilan-bosluk: 1rem;

@mixin kutu-stili($arka-plan: white, $kenarlik: 1px solid $kenarlik-rengi) {
  padding: $varsayilan-bosluk;
  background-color: $arka-plan;
  border: $kenarlik;
  border-radius: 4px;
}

.mesaj {
  @include kutu-stili;
  margin-bottom: $varsayilan-bosluk;
  color: #333;

  &.uyari { /* İç içe kural ve & (üst seçiciye referans) */
    border-left: 5px solid red;
    background-color: lighten(red, 40%);

    a { /* İç içe kural */
       color: darken(red, 10%);
       text-decoration: none;

       &:hover { /* İç içe kural */
           text-decoration: underline;
       }
    }
  }
}

.buton {
   @extend .mesaj; /* .mesaj stillerini miras al */
   display: inline-block;
   background-color: $ana-renk;
   color: white;
}
                    </code></pre>
                    <p>Ön işlemciler, büyük projelerde CSS kodunu organize etmek ve yönetmek için oldukça faydalıdır, ancak bir derleme adımı gerektirirler.</p>
                 </details>
            </section>

            <section id="uygulamalar" class="content-section">
                 <h2>CSS En İyi Uygulamaları ve İpuçları</h2>
                 <p>Etkili, yönetilebilir ve performanslı CSS kodu yazmak için bazı en iyi uygulamaları takip etmek önemlidir.</p>

                 <details class="question-block">
                     <summary><h3>Kod Organizasyonu ve Yönetimi</h3></summary>
                     <ul>
                         <li><strong>CSS'i Ayrı Dosyalarda Tutun:</strong> Harici stil şablonları (<code>.css</code> dosyaları) kullanın. Bu, içeriği sunumdan ayırır ve bakımı kolaylaştırır.</li>
                         <li><strong>Mantıksal Gruplama:</strong> CSS dosyanızı mantıksal bölümlere ayırın (örn: temel stiller, yerleşim, bileşenler, yardımcı sınıflar) ve yorumlarla bu bölümleri belirtin.</li>
                         <li><strong>İsimlendirme Kuralları (Naming Conventions):</strong> Tutarlı ve anlamlı sınıf isimleri kullanın. BEM (Block, Element, Modifier), SMACSS (Scalable and Modular Architecture for CSS) veya OOCSS (Object-Oriented CSS) gibi metodolojiler, büyük projelerde sınıf isimlerini organize etmek için faydalı olabilir.
                             <ul>
                                 <li><strong>BEM Örneği:</strong> <code>.card__title--large</code> (Blok: <code>card</code>, Eleman: <code>title</code>, Değiştirici: <code>large</code>)</li>
                             </ul>
                         </li>
                         <li><strong>Ön İşlemci Kullanımı:</strong> Büyük projeler için Sass veya Less gibi ön işlemciler kullanarak değişkenler, mixin'ler ve iç içe kurallar gibi özelliklerden yararlanın.</li>
                         <li><strong>Kod Tekrarından Kaçının (DRY - Don't Repeat Yourself):</strong> Ortak stilleri tekrar tekrar yazmak yerine, bunları temel sınıflarda veya mixin'lerde tanımlayın ve gerektiğinde kullanın veya genişletin.</li>
                         <li><strong>Stil Rehberi (Style Guide):</strong> Projenin tasarım dilini (renk paleti, tipografi, boşluklar, bileşenler) belgeleyen bir stil rehberi oluşturmak tutarlılığı artırır.</li>
                     </ul>
                 </details>

                 <details class="question-block">
                     <summary><h3>Performans İpuçları</h3></summary>
                     <ul>
                         <li><strong>Seçici Verimliliği:</strong> Tarayıcılar seçicileri sağdan sola doğru okur. Aşırı karmaşık veya gereksiz yere özgül seçiciler (örn: <code>body #main ul li a.aktif</code>) performansı düşürebilir. Mümkün olduğunca basit ve doğrudan seçiciler (özellikle sınıflar) kullanın. ID seçiciler hızlıdır ancak yeniden kullanılabilirliği sınırlar. Evrensel seçici (<code>*</code>) veya nitelik seçicileri (özellikle karmaşık olanlar) dikkatli kullanılmalıdır.</li>
                         <li><strong>Dosya Boyutunu Küçültme (Minification):</strong> Üretim ortamına göndermeden önce CSS dosyalarındaki gereksiz boşlukları, yorumları ve satır sonlarını kaldırarak dosya boyutunu küçültün. Bunun için çeşitli online araçlar veya build araçları (Webpack, Gulp vb.) kullanılabilir.</li>
                         <li><strong>CSS Dosyalarını Birleştirme:</strong> Çok sayıda küçük CSS dosyası yerine, mantıksal olarak gruplanmış daha az sayıda CSS dosyası kullanmak HTTP istek sayısını azaltır. Build araçları bu birleştirmeyi otomatik yapabilir.</li>
                         <li><strong>Kritik CSS (Critical CSS):</strong> Sayfanın ilk yüklenmede görünen ("above the fold") bölümünü stilize etmek için gereken minimum CSS'i HTML içine (<code>&lt;style></code>) gömüp, geri kalan CSS'i asenkron olarak yüklemek ilk görüntülenme süresini (First Contentful Paint) iyileştirebilir. Bu genellikle otomatize edilmiş araçlarla yapılır.</li>
                         <li><strong>Kullanılmayan CSS'i Kaldırma:</strong> Projede artık kullanılmayan CSS kurallarını tespit edip (tarayıcı geliştirici araçları veya özel araçlarla) kaldırmak dosya boyutunu azaltır.</li>
                         <li><strong><code>@import</code> Yerine <code><link></code> Kullanın:</strong> CSS içinde <code>@import</code> kullanmak, dosyaların paralel olarak indirilmesini engelleyebilir ve performansı düşürebilir. Birden fazla CSS dosyasını HTML'deki <code><link></code> etiketleri ile bağlamak daha iyidir (veya dosyaları birleştirmek). </li>
                     </ul>
                 </details>

                 <details class="question-block">
                     <summary><h3>Erişilebilirlik (Accessibility - a11y) İpuçları</h3></summary>
                     <ul>
                         <li><strong>Renk Kontrastı:</strong> Metin rengi ile arka plan rengi arasında yeterli kontrast olduğundan emin olun (WCAG yönergelerine göre). Görme zorluğu yaşayan kullanıcılar için bu çok önemlidir. Kontrast kontrol araçları kullanın.</li>
                         <li><strong>Odak Stilleri (Focus Styles):</strong> Klavye ile gezinen kullanıcılar için hangi elemanın odaklanıldığını açıkça gösteren belirgin <code>:focus</code> stilleri sağlayın. Varsayılan odak stillerini tamamen kaldırmaktan (<code>outline: none;</code>) kaçının veya yerine daha belirgin özel bir stil ekleyin.</li>
                         <li><strong>İçeriği Gizlerken Dikkat Edin:</strong> Elemanları görsel olarak gizlemek için <code>display: none; </code> veya <code>visibility: hidden;</code> kullanmak, genellikle ekran okuyucuların da içeriğe erişmesini engeller. Eğer içerik ekran okuyucular tarafından okunmalı ama görsel olarak gizlenmeliyse, özel "visually-hidden" veya "sr-only" (screen reader only) CSS teknikleri kullanılmalıdır (örn: elemanı ekran dışına konumlandırma). </li>
                         <li><strong>CSS ile İçerik Eklemekten Kaçının:</strong> <code>content</code> özelliği ile (<code>::before</code>, <code>::after</code>) önemli içerik veya işlevsellik eklemekten kaçının, çünkü bu içerik ekran okuyucular tarafından her zaman algılanmayabilir. Dekoratif amaçlar veya yardımcı ikonlar için daha uygundur.</li>
                         <li><strong>Font Boyutları ve Okunabilirlik:</strong> Okunabilir font boyutları kullanın ve kullanıcıların metni yakınlaştırmasını engellemeyin (<code>user-scalable=no</code> kullanmaktan kaçının). Göreceli birimler (<code>em</code>, <code>rem</code>) kullanmak, kullanıcıların tarayıcı ayarlarıyla font boyutunu değiştirmesine olanak tanır.</li>
                         <li><strong>Duyarlı Tasarım:</strong> Sayfanın farklı ekran boyutlarında kullanılabilir ve okunabilir olduğundan emin olun.</li>
                     </ul>
                 </details>

                 <details class="question-block">
                    <summary><h3>Sonuç: Sürekli Öğrenme ve Pratik</h3></summary>
                    <p>
                        CSS, web tasarımının temelini oluşturan dinamik ve sürekli gelişen bir dildir. Bu rehber, temel kavramlardan modern tekniklere kadar geniş bir bakış sunmayı amaçlamıştır. Flexbox, Grid, CSS Değişkenleri, geçişler ve animasyonlar gibi modern özellikler, daha önce hiç olmadığı kadar esnek ve güçlü tasarımlar oluşturmamızı sağlıyor.
                    </p>
                    <p>
                        Ancak CSS dünyası sürekli yenileniyor. Yeni seçiciler, özellikler ve modüller ekleniyor. Bu nedenle, MDN Web Docs, CSS-Tricks, Smashing Magazine gibi güvenilir kaynakları takip etmek, yeni teknikleri denemek ve bolca pratik yapmak önemlidir. En iyi uygulamaları takip ederek, temiz, yönetilebilir, performanslı ve erişilebilir CSS kodları yazabilirsiniz.
                    </p>
                     <p>
                        Unutmayın, harika bir web sitesi sadece iyi bir yapıdan (HTML) ibaret değildir; aynı zamanda etkileyici bir sunum (CSS) ve akıcı bir davranış (JavaScript) gerektirir. Bu üç teknolojiyi uyum içinde kullanarak kullanıcılarınıza unutulmaz deneyimler sunabilirsiniz.
                    </p>
                 </details>

             </section>
        </div>
    </main>

    <div class="back-to-top-container">
        <a href="#pageTop" class="back-to-top" aria-label="Sayfanın başına dön">
            <i class="fas fa-chevron-up"></i>
        </a>
   </div>

    <footer id="mainFooter">
        <div class="container">
            <div class="footer-layout">
                <div class="footer-left-links">
                    <h4>Hızlı Bağlantılar</h4>
                    <ul class="footer-nav-links">
                        <li><a href="https://abdulkadirgungor.com/">Ana Sayfa</a></li>
                        <li><a href="https://abdulkadirgungor.com/cv" target="_blank" rel="noopener noreferrer">Özgeçmiş</a></li>
                        <li><a href="https://abdulkadirgungor.com/blog" target="_blank" rel="noopener noreferrer">Blog</a></li>
                    </ul>
                </div>
                <div class="footer-center-content">
                    <h4 class="sitemap-link-heading">
                        <a href="https://abdulkadirgungor.com/sitemap.xml" target="_blank" rel="noopener noreferrer">Sitemap</a>
                    </h4>
                    <p id="footerTextContent">
                        © {YEAR} Abdulkadir Güngör. Tüm Hakları Saklıdır.
                    </p>
                </div>
            </div>
        </div>
    </footer>
    
    <script src="../assets/js/script.js" defer></script>
</body>
</html>
