<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="siteTitle">Abstract Class vs Interface: Derinlemesine Karşılaştırma ve Kullanım Rehberi</title>
    <meta name="description" content="Nesne Yönelimli Programlama'nın (OOP) temel taşlarından Abstract Class (Soyut Sınıf) ve Interface (Arayüz) arasındaki farklar üzerine kapsamlı bir analiz. Bu detaylı rehber, iki yapının tanımından başlayarak kalıtım, implementasyon, erişim belirleyiciler, C# 8+ ile gelen default metotlar, performans etkileri, tasarım desenlerindeki rolleri ve SOLID prensipleriyle ilişkisine kadar her yönünü inceler. Hangi durumda hangisinin tercih edilmesi gerektiği, gerçek dünya örnekleri, sık yapılan hatalar ve mülakatlarda dikkat edilmesi gereken noktalarla zenginleştirilmiş bu kaynak, yazılım geliştiriciler için vazgeçilmez bir başvuru niteliğindedir.">
    <meta name="keywords" content="Abstract Class, Soyut Sınıf, Interface, Arayüz, Farkları, Karşılaştırma, OOP, Nesne Yönelimli Programlama, C#, Java, Yazılım Tasarımı, Software Design, Kalıtım, Inheritance, Çoklu Kalıtım, Multiple Inheritance, Implementasyon, Implementation, Erişim Belirleyiciler, Access Modifiers, Default Interface Methods, C# 8, Soyutlama, Abstraction, Polimorfizm, Polymorphism, Sözleşme, Contract, Tasarım Desenleri, Design Patterns, Strategy Pattern, Template Method Pattern, SOLID Prensipleri, Open/Closed Principle, Liskov Substitution Principle, Interface Segregation Principle, Dependency Inversion Principle, Bağımlılık Enjeksiyonu, Dependency Injection, IoC, Inversion of Control, Kod Kalitesi, Sürdürülebilirlik, Esneklik, Test Edilebilirlik, Mülakat Soruları, Yazılım Mühendisliği, .NET, Programlama, Yazılım Mimarisi, API Tasarımı, Diamond Problem, Elmas Problemi, Versiyonlama, API Evolution, Coupling, Cohesion, Encapsulation, Kapsülleme">
    <meta name="author" content="Abdulkadir Güngör">
    <link rel="canonical" href="https://abdulkadirgungor.com/blog/blog_page_3.html" />

    <link rel="icon" type="image/png" href="../assets/images/icons/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="../assets/images/icons/favicon.svg" />
    <link rel="shortcut icon" href="../assets/images/icons/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="../assets/images/icons/apple-touch-icon.png" />
    <link rel="manifest" href="../assets/images/icons/site.webmanifest" />

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="../assets/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <link rel="sitemap" type="application/xml" title="Sitemap" href="https://abdulkadirgungor.com/sitemap.xml">
    <link rel="sitemap" type="text/html" title="HTML Sitemap" href="https://abdulkadirgungor.com/sitemap.html">
    
    <script type="application/ld+json" id="siteData">
    {
      "@context": "https://schema.org",
      "@type": "BlogPosting",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://abdulkadirgungor.com/blog/blog_page_3.html"
      },
      "headline": "Abstract Class vs Interface: Derinlemesine Karşılaştırma ve Kullanım Rehberi",
      "name": "Abstract Class vs Interface: Derinlemesine Karşılaştırma | Abdulkadir Güngör", 
  "author": {
    "@type": "Person",
    "name": "Abdulkadir Güngör",
    "url": "https://abdulkadirgungor.com/",
    "image": "https://abdulkadirgungor.com/assets/images/cv-profile.jpg",
    "sameAs": [
      "https://www.linkedin.com/in/abdulkadir-güngör/",
      "https://github.com/abdulkadirgungor86",
      "https://github.com/abdulkadir-gungor",
      "https://scholar.google.com/citations?user=1Ov789YAAAAJ",
      "https://polen.itu.edu.tr/bitstreams/f268d04c-e4a9-49bd-b336-929c1e52e4b9/download",
      "https://books.google.com.tr/books?id=GWMhEAAAQBAJ",
      "https://books.google.com.tr/books?id=u0CLEAAAQBAJ",
      "https://www.wikidata.org/wiki/Q134932691",
      "https://www.imdb.com/name/nm17368974"
    ]
  },
      "publisher": {
        "@type": "Organization",
        "name": "Abdulkadir Güngör",
        "logo": {
          "@type": "ImageObject",
          "url": "https://abdulkadirgungor.com/assets/images/icons/favicon-96x96.png" 
        }
      },
      "datePublished": "2025-05-13", 
      "dateModified": "2025-05-13", 
      "description": "Nesne Yönelimli Programlama'nın (OOP) temel taşlarından Abstract Class (Soyut Sınıf) ve Interface (Arayüz) arasındaki farklar üzerine kapsamlı bir analiz.",
      "isPartOf": {
        "@type": "WebSite",
        "@id": "https://abdulkadirgungor.com/"
      }
    }
    </script>

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-5GFQC3DYZF"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-5GFQC3DYZF');
    </script>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-5L6M34JW');</script>
    
</head>
<body id="pageTop"> 
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5L6M34JW"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    
    <main class="section-padding">
        <div class="container">
            <article id="giris" class="content-section intro-section">
                <h1>Abstract Class ve Interface: OOP Dünyasında Derin Bir Yolculuk</h1>
                <p>
                    Nesne Yönelimli Programlama (OOP), modern yazılım geliştirmenin temel direklerinden biridir. Bu paradigmanın sunduğu soyutlama (abstraction), kapsülleme (encapsulation), kalıtım (inheritance) ve çok biçimlilik (polymorphism) gibi güçlü mekanizmalar, karmaşık sistemleri daha yönetilebilir, modüler ve anlaşılır hale getirmemizi sağlar. OOP'nin bu temel kavramlarını hayata geçirirken karşımıza çıkan en önemli ve bazen kafa karıştırıcı olabilen iki yapı ise <strong>Abstract Class (Soyut Sınıf)</strong> ve <strong>Interface (Arayüz)</strong>'dir. Özellikle OOP'ye yeni başlayan veya bilgilerini derinleştirmek isteyen geliştiriciler için bu iki yapı arasındaki farkları, benzerlikleri ve kullanım amaçlarını net bir şekilde anlamak, doğru tasarım kararları alabilmek adına kritik bir öneme sahiptir.
                </p>
                <p>
                    Sıklıkla "Abstract class mı kullanmalıyım, yoksa interface mi?" sorusuyla karşı karşıya kalırız. Bu soru, sadece teknik bir detay sorgusu değil, aynı zamanda tasarladığımız sistemin gelecekteki esnekliğini, genişletilebilirliğini ve bakım kolaylığını doğrudan etkileyen stratejik bir tasarım kararıdır. Yanlış bir seçim, ileride kod tekrarına, sıkı bağımlılıklara (tight coupling), test zorluklarına ve hatta SOLID gibi temel tasarım prensiplerinin ihlaline yol açabilir. Yazılım mülakatlarında da bu konunun sıkça sorulmasının temel nedeni, adayın OOP'nin temel mekanizmalarına ve tasarım prensiplerine ne kadar hakim olduğunu ölçmektir.
                </p>
                 <p>
                    Bu kapsamlı makalede, Abstract Class ve Interface kavramlarını sadece yüzeyel farklarıyla değil, tüm derinliğiyle ele alacağız. Tarihsel gelişimlerinden başlayarak, temel tanımlarına, yapısal farklılıklarına (üye türleri, erişim belirleyiciler, kalıtım yetenekleri), implementasyon zorunluluklarına, C# 8 ve sonrası dillerdeki evrimlerine (default interface methods), performans etkilerine, tasarım desenlerindeki rollerine ve SOLID prensipleriyle olan karmaşık ilişkilerine kadar pek çok konuya değineceğiz. Amacımız, bu iki güçlü soyutlama aracını ne zaman, neden ve nasıl kullanmanız gerektiği konusunda size net bir vizyon sunmak ve kodlama pratiğinizde daha bilinçli, daha sağlam tasarımlar yapmanıza yardımcı olmaktır. Örnek kod parçaları, detaylı açıklamalar ve pratik senaryolarla zenginleştirilmiş bu yolculukta, abstract class ve interface arasındaki sis perdesini tamamen aralamayı hedefliyoruz.
                </p>
            </article>

            <section id="temel-farklar" class="content-section">
                <h2>Temel Farklılıklar: İlk Bakışta Ayırt Edici Özellikler</h2>
                <p>Her iki yapı da soyutlamayı desteklese ve doğrudan örneklenemese de (`new` anahtar kelimesi ile nesneleri oluşturulamaz), aralarında hem sözdizimsel hem de kavramsal olarak önemli farklar bulunur. Bu farkları anlamak, doğru aracı seçmenin ilk adımıdır.</p>

                <details class="question-block">
                    <summary><h3>1. Örneklenememe (Non-Instantiable) Ortaklığı ve Nedeni</h3></summary>
                    <p>
                        Hem abstract class'lar hem de interface'ler, OOP'de soyut kavramları veya tamamlanmamış şablonları temsil ederler. Bu nedenle, <code>new</code> anahtar kelimesi kullanılarak doğrudan bir abstract class veya interface örneği oluşturulamaz. Derleyici bu tür bir girişime izin vermez (örneğin, C#'ta "CS0144: Cannot create an instance of the abstract class or interface 'TypeName'" hatası alınır).
                    </p>
                    <p>
                        <strong>Neden Örneklenemezler?</strong>
                        <ul>
                            <li><strong>Abstract Class'lar:</strong> Genellikle en az bir <code>abstract</code> (yani gövdesiz) üye içerirler. Bu üyelerin implementasyonu türetilmiş sınıflara bırakılmıştır. Gövdesi olmayan bir metodun nasıl çağrılacağı belirsiz olduğundan, bu tür "eksik" bir sınıftan nesne yaratmak mantıksal olarak mümkün değildir. Tüm üyeleri somut olsa bile, eğer sınıf <code>abstract</code> olarak işaretlenmişse, tasarımcının niyetinin ondan doğrudan nesne yaratılmaması, sadece bir temel (base) olarak kullanılması olduğu anlaşılır.</li>
                            <li><strong>Interface'ler:</strong> Geleneksel olarak (C# 8 öncesi), interface'ler hiçbir implementasyon içermezler; sadece metot imzaları, property'ler, event'ler ve indexer'lar gibi bir "sözleşme" tanımlarlar. İçinde hiçbir davranışsal mantık barındırmayan bir yapıdan nesne oluşturmanın bir anlamı yoktur. C# 8 ile gelen default metotlar implementasyon içerse de, interface'in temel amacı hala bir sözleşme tanımlamaktır ve doğrudan örneklenememe kuralı devam eder.</li>
                        </ul>
                        Bu örneklenememe özelliği, her iki yapının da somut (concrete) sınıflar tarafından "gerçekleştirilmesi" (implemente edilmesi veya kalıtım alınması) gerektiğini vurgular. Onlar, somut nesnelerin nasıl davranması veya ne tür özelliklere sahip olması gerektiğine dair birer plan veya kontrattır.
                    </p>
                </details>

                <details class="question-block" id="kalitim-ve-cokluluk">
                    <summary><h3>2. Kalıtım Yetenekleri: Tek Miras vs Çoklu Sözleşme</h3></summary>
                    <p>
                        Abstract class ve interface arasındaki en temel ve belirleyici farklardan biri, bir sınıfın onlardan nasıl kalıtım alabildiğidir. Bu fark, tasarım esnekliği açısından ciddi sonuçlar doğurur.
                    </p>
                    <p>
                        <strong>Abstract Class: Tek Sınıf Kalıtımı (Single Class Inheritance)</strong>
                        <ul>
                            <li>C# ve Java gibi birçok popüler OOP dili, bir sınıfın yalnızca <strong>bir</strong> başka sınıftan (abstract veya concrete) doğrudan kalıtım almasına izin verir. Bu kural, "tekli sınıf kalıtımı" olarak bilinir.</li>
                            <li><strong>Neden Tek Kalıtım?</strong> Bu kısıtlamanın temel nedeni, "Elmas Problemi" (Diamond Problem) olarak bilinen potansiyel bir belirsizliği önlemektir. Eğer bir sınıf, aynı metodu farklı şekillerde implemente eden iki ayrı sınıftan kalıtım alabilseydi, derleyici veya çalışma zamanı hangi implementasyonun kullanılacağını bilemezdi. Bu durum karmaşıklığa ve öngörülemez davranışlara yol açardı. Tekli sınıf kalıtımı bu belirsizliği ortadan kaldırır.</li>
                            <li><strong>Sonuçları:</strong> Bir sınıf hiyerarşisi tasarlarken, bir sınıfın temel kimliğini ("is-a" ilişkisi) en iyi temsil eden tek bir abstract (veya concrete) sınıfı seçmeniz gerekir. Örneğin, bir <code>Kopek</code> sınıfı <code>Hayvan</code> abstract sınıfından kalıtım alabilir, ancak aynı anda hem <code>Hayvan</code> hem de <code>Oyuncak</code> sınıfından kalıtım alamaz (eğer ikisi de sınıf ise). Bu, tasarımda bazen kısıtlayıcı olabilir.</li>
                        </ul>
                    </p>
                     <p>
                        <strong>Interface: Çoklu Arayüz Implementasyonu (Multiple Interface Implementation)</strong>
                        <ul>
                            <li>Aynı diller (C#, Java vb.), bir sınıfın <strong>birden fazla</strong> interface'i aynı anda implemente etmesine izin verir.</li>
                            <li><strong>Neden Çoklu Implementasyon?</strong> Geleneksel olarak interface'ler implementasyon içermediği için (sadece metot imzaları), Elmas Problemi burada ortaya çıkmaz. Bir sınıf, farklı interface'lerden gelen aynı imzaya sahip metotları implemente etmek zorunda kalsa bile, implementasyonun kendisi o sınıfa aittir ve bir belirsizlik oluşmaz. (C# 8 default metotları bu durumu biraz karmaşıklaştırsa da, çözümler mevcuttur, örneğin explicit interface implementation).</li>
                            <li><strong>Sonuçları:</strong> Interface'ler, bir sınıfa farklı "yetenekler" veya "roller" kazandırmak için son derece esnek bir mekanizma sunar. Bir sınıfın ne "olduğu" (abstract class ile tanımlanan kimlik) dışında, ne "yapabildiğini" (interface'ler ile tanımlanan yetenekler) de tanımlayabiliriz. Örneğin, bir <code>AkilliTelefon</code> sınıfı <code>Hayvan</code> sınıfından türeyemez ama <code>ICallable</code> (aranabilir), <code>IBrowsable</code> (gezilebilir), <code>ITakePicture</code> (fotoğraf çekebilir), <code>IPlayMusic</code> (müzik çalabilir) gibi birden fazla interface'i implemente ederek çok yönlü bir nesne haline gelebilir. Bu, yeteneklerin kompozisyonuna olanak tanır ve daha modüler tasarımlar sağlar.</li>
                        </ul>
                    </p>
                    <p>
                        Bu temel fark, genellikle "Abstract class 'is-a' (bir türüdür) ilişkisini, interface 'can-do' (yapabilir) veya 'has-a' (sahiptir) ilişkisini modeller" şeklinde özetlenir. Bir <code>Kopek</code> bir <code>Hayvan</code>'dır (is-a), ama aynı zamanda <code>IKuyrukSallayabilir</code> (can-do) yeteneğine de sahip olabilir.
                    </p>
                </details>

                <details class="question-block" id="uyeler-ve-implementasyon">
                    <summary><h3>3. Üye Tanımları ve Implementasyon: Boş Sözleşme mi, Kısmi Uygulama mı?</h3></summary>
                     <p>
                        İki yapı arasındaki bir diğer kritik ayrım, içerebilecekleri üye türleri ve bu üyelerin implementasyon durumlarıdır.
                    </p>
                    <p>
                        <strong>Interface: Sözleşme Odaklı Üyeler</strong>
                        <ul>
                            <li><strong>Geleneksel (C# 8 Öncesi):</strong> Interface'ler sadece üye imzalarını tanımlayabilirdi:
                                <ul>
                                    <li>Metot imzaları (gövdesiz)</li>
                                    <li>Property imzaları (get/set blokları gövdesiz)</li>
                                    <li>Event imzaları</li>
                                    <li>Indexer imzaları</li>
                                </ul>
                                Kesinlikle implementasyon (metot gövdesi, property'ler için otomatik veya özel get/set mantığı) içeremezlerdi. Alanlar (fields), yani sınıfın durumunu tutan değişkenler, asla tanımlanamazdı. Tüm üyeler varsayılan olarak <code>public</code> kabul edilir ve erişim belirleyici yazılamazdı.</li>
                            <li><strong>Modern (C# 8 ve Sonrası):</strong> C# 8 ile birlikte interface'lere önemli yenilikler geldi:
                                <ul>
                                    <li><strong>Default Implementations (Varsayılan Uygulamalar):</strong> Interface'ler artık metotlar ve property'ler için varsayılan (gövdeli) implementasyonlar içerebilir. Bu, bir interface'e yeni bir üye eklendiğinde, mevcut tüm implemente eden sınıfların kırılmasını önlemek amacıyla eklenmiştir. Eğer implemente eden sınıf bu yeni metodu override etmezse, default implementasyon kullanılır.</li>
                                    <li><strong>Static Üyeler:</strong> Interface'ler artık <code>static</code> metotlar, property'ler, event'ler ve hatta <code>static</code> constructor'lar içerebilir. Bu, yardımcı metotları veya fabrika desenlerini doğrudan interface içinde tanımlamayı sağlar.</li>
                                    <li><strong>Erişim Belirleyiciler (Kısıtlı):</strong> Default implementasyonlar ve static üyeler için <code>public</code>, <code>private</code>, <code>protected</code>, <code>internal</code> gibi erişim belirleyiciler kullanılabilir. Ancak, geleneksel sözleşme üyeleri (gövdesiz olanlar) hala <code>public</code> kabul edilir.</li>
                                </ul>
                                Bu yenilikler interface'leri daha güçlü hale getirse de, temel amacının hala bir "sözleşme" tanımlamak olduğu unutulmamalıdır. Durum (state), yani alanlar (fields), hala interface'lerde doğrudan tanımlanamaz.</li>
                        </ul>
                    </p>
                    <p>
                        <strong>Abstract Class: Esnek Üye Tanımları ve Kısmi Uygulama</strong>
                        <ul>
                            <li>Abstract class'lar, üye tanımlama konusunda çok daha fazla esneklik sunar:
                                <ul>
                                    <li><strong>Abstract Üyeler:</strong> <code>abstract</code> anahtar kelimesi ile işaretlenmiş, gövdesi olmayan üyeler (metotlar, property'ler, event'ler, indexer'lar). Bunlar, türetilmiş sınıflar tarafından <strong>zorunlu olarak</strong> implemente edilmelidir (override edilmelidir).</li>
                                    <li><strong>Concrete (Somut) Üyeler:</strong> Gövdesi olan, normal metotlar ve property'ler. Bunlar türetilmiş sınıflar tarafından doğrudan kullanılabilir.</li>
                                    <li><strong>Virtual Üyeler:</strong> <code>virtual</code> anahtar kelimesi ile işaretlenmiş, gövdesi olan üyeler. Türetilmiş sınıflar bu üyeleri isteğe bağlı olarak <code>override</code> ederek davranışlarını değiştirebilirler. Eğer override edilmezse, temel sınıftaki implementasyon kullanılır.</li>
                                    <li><strong>Alanlar (Fields):</strong> Abstract class'lar, sınıfın durumunu tutmak için normal alanlar (instance veya static değişkenler) tanımlayabilir. Bu, interface'lerin yapamadığı önemli bir özelliktir.</li>
                                    <li><strong>Constructor'lar:</strong> Abstract class'lar constructor (yapıcı metot) tanımlayabilir. Bu constructor'lar doğrudan <code>new</code> ile çağrılamasa da, türetilmiş sınıfların constructor'ları tarafından <code>base()</code> anahtar kelimesi ile çağrılarak temel sınıfın başlatılması için kullanılır.</li>
                                    <li><strong>Erişim Belirleyiciler:</strong> Abstract class üyeleri, standart sınıf üyeleri gibi <code>public</code>, <code>protected</code>, <code>internal</code>, <code>private</code> gibi tüm erişim belirleyicileri kullanabilir. Bu, kapsüllemeyi (encapsulation) daha detaylı kontrol etme imkanı sunar.</li>
                                </ul>
                            </li>
                            <li><strong>Sonuçları:</strong> Abstract class'lar, bir sınıf hiyerarşisi için ortak bir temel oluşturmak, paylaşılan kod ve durumu (state) yönetmek ve türetilmiş sınıflara belirli implementasyonları zorunlu kılarken bazılarını isteğe bağlı bırakmak için idealdir. Bir nevi "kısmen doldurulmuş bir şablon" görevi görürler.</li>
                        </ul>
                    </p>
                     <p>
                        <strong>Implementasyon Zorunluluğu Farkı Özeti:</strong>
                        <ul>
                            <li>Bir sınıf bir interface'i implemente ettiğinde, interface'deki <strong>tüm</strong> (varsayılan implementasyonu olmayan) üyeleri implemente etmek <strong>zorundadır</strong>.</li>
                            <li>Bir sınıf bir abstract class'tan türediğinde, sadece temel sınıftaki <strong><code>abstract</code></strong> olarak işaretlenmiş üyeleri implemente etmek (override etmek) <strong>zorundadır</strong>. <code>virtual</code> üyeleri isteğe bağlı olarak override edebilir, somut üyeleri ise doğrudan kullanabilir.</li>
                        </ul>
                    </p>
                </details>

                <details class="question-block">
                     <summary><h3>4. Temel Amaç: Sözleşme mi, Kimlik ve Şablon mu?</h3></summary>
                     <p>
                         Teknik farklılıkların ötesinde, iki yapının felsefi olarak temsil ettiği amaçlar da farklıdır:
                     </p>
                     <p>
                         <strong>Interface: Sözleşme (Contract) ve Yetenek (Capability) Tanımı</strong>
                         <ul>
                             <li>Interface'in birincil amacı, bir sınıfın dış dünyaya karşı uyması gereken bir <strong>sözleşmeyi</strong> tanımlamaktır. Bu sözleşme, sınıfın belirli metotları, property'leri veya event'leri sağlayacağını garanti eder.</li>
                             <li>Interface'ler, bir nesnenin belirli bir <strong>yeteneğe</strong> sahip olduğunu belirtmek için kullanılır. Örneğin, <code>IEnumerable</code> interface'i bir nesnenin elemanlarının döngüyle gezilebileceğini, <code>IDisposable</code> bir nesnenin yönetilmeyen kaynakları serbest bırakmak için bir mekanizmaya sahip olduğunu, <code>IComparable</code> ise bir nesnenin başka bir nesneyle karşılaştırılabileceğini belirtir.</li>
                             <li>Bu "yetenek" odaklı yaklaşım, farklı hiyerarşilerden gelen sınıfların ortak bir davranışı paylaşmasını sağlar. Bir <code>Dosya</code> sınıfı da, bir <code>VeritabaniBaglantisi</code> sınıfı da <code>IDisposable</code> olabilir, ancak aralarında "is-a" ilişkisi yoktur.</li>
                             <li>Interface'ler, sistemin farklı parçaları arasında <strong>gevşek bağlılığı (loose coupling)</strong> teşvik eder. Bileşenler, somut sınıflara değil, interface'lere bağımlı olarak tasarlandığında, implementasyon detayları kolayca değiştirilebilir veya farklı implementasyonlar takılabilir (Dependency Inversion Principle ile yakından ilişkilidir).</li>
                         </ul>
                     </p>
                     <p>
                         <strong>Abstract Class: Kimlik (Identity) ve Şablon (Template) Tanımı</strong>
                         <ul>
                             <li>Abstract class, genellikle bir grup ilgili sınıf için ortak bir <strong>kimlik</strong> veya temel tür (base type) tanımlamak amacıyla kullanılır. Bu, güçlü bir "is-a" ilişkisini temsil eder. <code>Kedi</code> ve <code>Kopek</code> sınıfları, <code>Hayvan</code> abstract sınıfından türeyerek birer "Hayvan" olduklarını belirtirler.</li>
                             <li>Ortak özellikleri (alanlar) ve davranışları (somut veya virtual metotlar) barındırarak türetilmiş sınıflar için bir <strong>şablon</strong> görevi görür. Bu, kod tekrarını (DRY prensibi) azaltır ve ortak mantığı tek bir yerde toplar.</li>
                             <li><code>abstract</code> metotlar aracılığıyla, şablonun belirli kısımlarının türetilmiş sınıflar tarafından doldurulmasını zorunlu kılar. Bu, "Template Method" tasarım deseninin uygulanmasını kolaylaştırır; temel sınıf genel algoritmanın iskeletini tanımlar, alt sınıflar ise algoritmanın belirli adımlarını özelleştirir.</li>
                             <li>Abstract class'lar, durum (state) bilgisi taşıyabildikleri için, ortak özelliklere sahip nesneler modellemek için daha uygundur.</li>
                         </ul>
                     </p>
                     <p>Özetle, "Bu nesne ne yapabilir?" sorusuna cevap arıyorsanız interface, "Bu nesne nedir ve temel ortak özellikleri/davranışları nelerdir?" sorusuna cevap arıyorsanız abstract class daha uygun bir başlangıç noktasıdır.</p>
                 </details>

            </section>

            <section id="csharp8-devrimi" class="content-section">
                <h2>C# 8 ve Sonrası: Interface'lerin Evrimi ve Etkileri</h2>
                <p>C# 8 sürümü, .NET ekosisteminde interface kavramına yönelik önemli ve tartışmalı yenilikler getirdi: Default Interface Methods (Varsayılan Arayüz Metotları) ve static üye desteği. Bu yenilikler, interface'lerin geleneksel "sadece sözleşme" rolünü genişleterek, abstract class'larla arasındaki çizgiyi bir miktar bulanıklaştırdı.</p>

                <details class="question-block">
                    <summary><h3>Default Interface Methods: Nedir, Neden ve Sonuçları?</h3></summary>
                    <p>
                        <strong>Nedir?</strong> C# 8'den itibaren, interface'ler içerisinde metotlar, property'ler, indexer'lar ve event'ler için varsayılan (gövdeli) implementasyonlar tanımlanabilir. Bu, <code>abstract</code> olmayan bir metodu bir interface içine yazabilmek anlamına gelir.
                    </p>
                    <p>
                        <strong>Neden Getirildi?</strong> Bu özelliğin temel motivasyonu, API evrimini kolaylaştırmaktır. Bir interface yaygın olarak kullanılıyorsa (örneğin, .NET Base Class Library'deki gibi), bu interface'e yeni bir metot eklemek, onu implemente eden mevcut tüm sınıfların kodunu kırar (çünkü yeni metodu implemente etmeleri gerekir). Default implementasyon sayesinde, interface'e yeni bir metot varsayılan bir gövdeyle eklenebilir. Mevcut sınıflar bu metodu implemente etmezse, varsayılan implementasyon kullanılır ve kodları kırılmaz. Bu, özellikle kütüphane geliştiricileri için büyük bir avantajdır. Ayrıca, Java'daki <code>default methods</code> veya Swift'teki <code>protocol extensions</code> gibi diğer dillerdeki benzer mekanizmalara uyum sağlama amacı da taşır ve "Traits" benzeri bir yapıya olanak tanır.
                    </p>
                    <p>
                        <strong>Sonuçları ve Tartışmalar:</strong>
                        <ul>
                            <li><strong>Abstract Class Benzerliği:</strong> Implementasyon içerebilme yeteneği, interface'leri abstract class'lara daha çok yaklaştırmıştır. Artık interface'ler de bir miktar davranışsal kod barındırabilir.</li>
                            <li><strong>Elmas Problemi Riski?:</strong> Bir sınıf, aynı default metodu farklı şekillerde implemente eden iki interface'i implemente ederse ne olur? C# bu durumu yönetmek için kurallar getirmiştir. Sınıf, çakışan metodu kendisi <code>override</code> etmek zorundadır, aksi takdirde derleme hatası alınır. Bu, Elmas Problemi'nin kontrol altında tutulmasını sağlar.</li>
                            <li><strong>Tasarım Felsefesi:</strong> Bazı geliştiriciler, bu özelliğin interface'lerin temel "sözleşme" felsefesini zayıflattığını ve kötüye kullanıma açık olduğunu savunur. Interface'lerin implementasyon detaylarından mümkün olduğunca uzak durması gerektiği düşüncesi hakimdir.</li>
                            <li><strong>Ne Zaman Kullanılmalı?</strong> Default metotlar, öncelikle API versiyonlama ve geriye uyumluluk sorunlarını çözmek için düşünülmelidir. İkincil olarak, bir grup ilgili interface metodu için ortak, basit bir varsayılan davranış sağlamak amacıyla kullanılabilir. Ancak, karmaşık mantık veya durum yönetimi içeren implementasyonlar için hala abstract class'lar daha uygun bir seçenektir.</li>
                        </ul>
                    </p>
                </details>

                 <details class="question-block">
                    <summary><h3>Static Üyeler ve Erişim Belirleyiciler</h3></summary>
                    <p>
                        C# 8 ile gelen diğer bir yenilik, interface'lerin <code>static</code> üyeler (metotlar, property'ler vb.) içerebilmesidir. Bu, genellikle interface ile ilgili yardımcı (utility) metotları veya fabrika (factory) metotlarını doğrudan interface'in kendisi üzerinde tanımlamak için kullanışlıdır. Örneğin, <code>IParsable<T>.Parse(string s)</code> gibi bir static metot, string'i ilgili tipe parse etmek için standart bir yol sunabilir.
                    </p>
                    <p>
                        Ayrıca, default implementasyonlar ve static üyeler için <code>public</code>, <code>private</code>, <code>protected</code> gibi erişim belirleyiciler de kullanılabilir hale gelmiştir. <code>private</code> static metotlar, default implementasyonlar için yardımcı fonksiyonlar olarak kullanılabilirken, <code>protected</code> üyeler (henüz C# tarafından tam desteklenmese de gelecek versiyonlarda düşünülebilir) kalıtım senaryolarında rol oynayabilir. Bu, interface'lerin kapsülleme yeteneklerini bir miktar artırır, ancak yine de temel amaç sözleşme tanımıdır.
                    </p>
                     <p>
                        <strong>Önemli Not:</strong> Bu modern özelliklere rağmen, interface'ler hala doğrudan <strong>instance alanları (fields)</strong> tanımlayamazlar. Yani, nesnenin durumunu (state) doğrudan tutamazlar. Bu, abstract class'larla aralarındaki en önemli yapısal farklardan biri olarak kalmaya devam etmektedir.
                    </p>
                </details>

            </section>

            <section id="kullanim-senaryolari" class="content-section">
                 <h2>Ne Zaman Hangisi Kullanılmalı? Pratik Karar Verme Rehberi</h2>
                 <p>Teorik farklılıkları anladıktan sonra, asıl önemli soru şudur: Gerçek dünya projelerinde hangi durumda abstract class, hangi durumda interface tercih etmeliyiz? İşte karar vermenize yardımcı olacak bazı pratik yönergeler ve senaryolar:</p>

                 <details class="question-block">
                     <summary><h3>Interface Tercih Edilmesi Gereken Durumlar</h3></summary>
                     <ul>
                         <li><strong>Farklı Hiyerarşilerde Ortak Yetenek Tanımlama:</strong> Birbirleriyle doğrudan "is-a" ilişkisi olmayan, farklı sınıf hiyerarşilerinden gelen nesnelere ortak bir yetenek (capability) veya rol kazandırmak istediğinizde interface idealdir. Örneğin, hem <code>FileStream</code> hem de <code>NetworkStream</code> <code>IDisposable</code> olabilir; hem <code>Button</code> hem de <code>MenuItem</code> <code>IClickable</code> olabilir; hem <code>Customer</code> hem de <code>Product</code> <code>ISearchable</code> olabilir.</li>
                         <li><strong>Çoklu "Tür" Kalıtımı İhtiyacı:</strong> Bir sınıfın birden fazla sözleşmeye uyması veya birden fazla rolü üstlenmesi gerektiğinde, çoklu interface implementasyonu tek seçenektir (çünkü tekli sınıf kalıtımı kuralı vardır). Bir <code>ReportGenerator</code> sınıfı hem <code>IGeneratePdf</code> hem de <code>IGenerateExcel</code> interface'lerini implemente edebilir.</li>
                         <li><strong>Maksimum Gevşek Bağlılık (Loose Coupling) Hedefi:</strong> Sistem bileşenleri arasındaki bağımlılıkları en aza indirmek ve implementasyon detaylarını soyutlamak istediğinizde interface'ler tercih edilir. Bileşenler birbirleriyle sadece interface sözleşmeleri üzerinden iletişim kurduğunda, bir bileşenin iç implementasyonunu değiştirmek diğerlerini etkilemez (Dependency Inversion Principle). Bu, özellikle büyük, modüler sistemlerde ve birim testlerinde (mocking/stubbing için) çok önemlidir.</li>
                         <li><strong>API Sözleşmesi Tanımlama:</strong> Bir kütüphanenin, framework'ün veya servisin dış dünyaya açılan public API'sini tanımlarken interface'ler standart bir yöntemdir. Bu, API'yi kullananların belirli bir implementasyona değil, kararlı bir sözleşmeye bağlanmasını sağlar.</li>
                         <li><strong>Değer Türleri (Structs) İçin Sözleşme:</strong> Struct'lar (değer türleri) sınıflardan kalıtım alamazlar ama interface'leri implemente edebilirler. Bu sayede struct'lara da belirli yetenekler kazandırılabilir (örneğin, <code>IEquatable<T></code> veya <code>IComparable<T></code>).</li>
                         <li><strong>Durum (State) Paylaşımı Gerekmediğinde:</strong> Eğer türetilmiş sınıflar arasında ortak veri veya durum paylaşımı ihtiyacı yoksa, sadece davranışsal bir sözleşme yeterliyse interface genellikle daha temiz bir çözümdür.</li>
                     </ul>
                 </details>

                <details class="question-block">
                     <summary><h3>Abstract Class Tercih Edilmesi Gereken Durumlar</h3></summary>
                     <ul>
                         <li><strong>Yakından İlişkili Sınıflar İçin Ortak Temel Oluşturma:</strong> Bir grup sınıf arasında net bir "is-a" ilişkisi varsa ve bu sınıflar önemli ölçüde ortak kod (metot implementasyonları) veya ortak durum (alanlar/fields) paylaşıyorsa, abstract class kod tekrarını önlemek ve ortak yapıyı merkezileştirmek için idealdir. Örneğin, <code>Shape</code> (Şekil) abstract sınıfı, <code>Circle</code> (Daire), <code>Rectangle</code> (Dikdörtgen) gibi sınıflar için ortak bir <code>Color</code> property'si veya <code>Move(x, y)</code> metodu sağlayabilir.</li>
                         <li><strong>Kısmi (Varsayılan) Implementasyon Sağlama:</strong> Türetilmiş sınıflara bazı metotlar için varsayılan bir davranış sunmak, ancak bazılarını (<code>abstract</code> olanları) implemente etmeye zorlamak istediğinizde abstract class kullanılır. Bu, bir algoritmanın veya sürecin genel iskeletini tanımlayıp belirli adımları alt sınıflara bırakan Template Method tasarım deseni için mükemmeldir.</li>
                         <li><strong>Durum (State) Yönetimi Gerektiğinde:</strong> Türetilmiş sınıfların paylaşması gereken ortak alanlar (instance variables) varsa, abstract class bunları tanımlayabilir. Interface'ler instance alanı tanımlayamaz.</li>
                         <li><strong>Non-public Üyelere İhtiyaç Duyulduğunda:</strong> Temel sınıfın implementasyon detaylarını gizlemek veya türetilmiş sınıflara özel yardımcı metotlar (<code>protected</code>) sağlamak istediğinizde abstract class'ların erişim belirleyici esnekliği avantaj sağlar. Interface üyeleri (sözleşme kısmı) genellikle public'tir.</li>
                         <li><strong>Versiyonlama ve Evrim Kolaylığı (Kısmen):</strong> Bir abstract class'a yeni bir somut (concrete) veya virtual metot eklemek, mevcut türetilmiş sınıfları genellikle kırmaz (çünkü implementasyon zorunluluğu getirmez). Bu, C# 8 öncesi interface'lere göre bir avantajdı. (Ancak C# 8 default metotları bu farkı azaltmıştır).</li>
                         <li><strong>Constructor Kontrolü:</strong> Türetilmiş sınıfların nasıl başlatılacağını kontrol etmek için constructor'lar (belki <code>protected</code> yapılarak) kullanılabilir.</li>
                     </ul>
                 </details>

                 <details class="question-block">
                     <summary><h3>Hibrit Yaklaşım: Birlikte Kullanım</h3></summary>
                     <p>
                         Çoğu zaman en iyi tasarım, abstract class ve interface'lerin birlikte kullanılmasını içerir. Bir sınıf, temel kimliğini ve ortak davranışlarını bir abstract class'tan alırken, ek yetenekler veya farklı roller için bir veya daha fazla interface'i implemente edebilir.
                     </p>
                     <p>
                         Örnek: Bir <code>VeritabaniLogger</code> sınıfı, loglama mekanizmasının temel yapısını ve belki bazı ortak yardımcı metotları sağlayan bir <code>BaseLogger</code> abstract sınıfından türeyebilir. Aynı zamanda, tüm logger'ların uyması gereken genel loglama sözleşmesini tanımlayan <code>ILogger</code> interface'ini implemente edebilir. Hatta log mesajlarını formatlama yeteneği için <code>IMessageFormatter</code> gibi başka bir interface'i de implemente edebilir.
                     </p>
                     <pre><code class="language-csharp">
public abstract class BaseLogger : ILogger 
{ 
    // Ortak loglama mantığı veya yardımcı metotlar
    protected abstract void WriteLog(string message); // Alt sınıflar bunu implemente etmeli
    // ILogger'dan gelen metotların bazılarını burada implemente edebilir.
    public virtual void Log(string message) 
    {
        // belki ön işlem
        WriteLog(message);
        // belki son işlem
    }
}

public class VeritabaniLogger : BaseLogger, IMessageFormatter 
{ 
    public override void Log(string message) // BaseLogger'daki virtual metodu override ediyor
    {
        string formattedMessage = FormatMessage(message); // IMessageFormatter'dan
        WriteLog(formattedMessage); // BaseLogger'daki abstract metodu çağırıyor
    }

    protected override void WriteLog(string message) 
    { 
        Console.WriteLine($"Veritabanına yazılıyor: {message}"); 
    } 

    public string FormatMessage(string message)
    {
        return $"[{DateTime.Now}] - {message.ToUpper()}";
    }
}
                     </code></pre>
                     <p>Bu hibrit yaklaşım, hem kod tekrarını önleme ve ortak yapı sağlama (abstract class avantajı) hem de esnek sözleşmeler ve yetenek kompozisyonu (interface avantajı) sunar.</p>
                 </details>

                 <details class="question-block">
                     <summary><h3>Karar Ağacı Özeti</h3></summary>
                     <ol>
                         <li><strong>"is-a" ilişkisi mi, "can-do" ilişkisi mi?</strong> Eğer sınıflar arasında güçlü bir "türüdür" ilişkisi ve ortak temel varsa -> Abstract Class düşünün. Eğer sadece bir "yeteneği yapabilir" durumu varsa -> Interface düşünün.</li>
                         <li><strong>Birden fazla "tür" mü gerekiyor?</strong> Evet ise -> Interface kullanmak zorundasınız (veya kompozisyon gibi başka desenler).</li>
                         <li><strong>Ortak implementasyon kodu veya durum (state) paylaşımı gerekiyor mu?</strong> Evet ise -> Abstract Class daha uygun olabilir. Hayır ise -> Interface genellikle daha iyidir.</li>
                         <li><strong>Gelecekte çok farklı implementasyonlar mı bekleniyor?</strong> Evet ise -> Interface daha fazla esneklik sunar.</li>
                         <li><strong>Değer türleri (structs) mi implemente edecek?</strong> Evet ise -> Interface kullanmalısınız.</li>
                     </ol>
                     <p>Unutmayın ki bunlar katı kurallar değil, yol gösterici ilkelerdir. Bazen gri alanlar olabilir ve en iyi seçim, projenin özel bağlamına ve hedeflerine bağlıdır.</p>
                 </details>
            </section>

            <section id="solid-baglantisi" class="content-section">
                <h2>SOLID Prensipleri ile İlişkisi: Tasarımın Omurgası</h2>
                <p>Abstract class ve interface kavramları, SOLID tasarım prensipleriyle derinden bağlantılıdır ve bu prensiplerin birçoğunun hayata geçirilmesinde kilit rol oynarlar.</p>
                <ul>
                    <li><strong>Open/Closed Principle (OCP):</strong> Hem interface'ler hem de abstract class'lar OCP'yi desteklemek için kullanılır. Yeni işlevsellik, mevcut interface'i implemente eden yeni bir sınıf ekleyerek veya mevcut abstract class'tan yeni bir sınıf türeterek (ve <code>abstract</code> metotları implemente ederek veya <code>virtual</code> metotları override ederek) eklenebilir. Her iki durumda da mevcut kodun değiştirilmesi gerekmez. Interface'ler genellikle daha fazla esneklik sunar.</li>
                    <li><strong>Liskov Substitution Principle (LSP):</strong> Bu prensip özellikle abstract class kalıtımıyla ilgilidir. Abstract class'tan türeyen sınıfların, temel sınıfın yerine sorunsuzca geçebilmesi gerekir. Interface implementasyonlarında da, implemente eden sınıfın interface sözleşmesine tam olarak uyması beklenir, bu da LSP ile uyumlu bir davranıştır.</li>
                    <li><strong>Interface Segregation Principle (ISP):</strong> Bu prensip doğrudan interface tasarımıyla ilgilidir. Büyük, "şişman" interface'ler yerine küçük, amaca özel interface'ler oluşturulmasını savunur. Abstract class'lar için doğrudan bir karşılığı olmasa da, bir abstract class'ın çok fazla ilgisiz sorumluluğu üstlenmesi de benzer sorunlara yol açabilir (SRP ihlali).</li>
                    <li><strong>Dependency Inversion Principle (DIP):</strong> Bu prensibin temel taşı soyutlamalardır. Yüksek seviyeli modüllerin düşük seviyeli modüllere değil, soyutlamalara (interface veya abstract class) bağımlı olması gerektiğini söyler. Interface'ler, genellikle somut implementasyonlardan tamamen bağımsız oldukları için DIP'yi uygulamada daha yaygın olarak tercih edilir ve daha iyi bir ayrıştırma (decoupling) sağlarlar. Ancak abstract class'lar da soyutlama katmanı olarak kullanılabilir.</li>
                </ul>
                <p>SOLID prensiplerine uygun tasarımlar yaparken, abstract class ve interface'leri doğru yerlerde ve doğru şekilde kullanmak esastır.</p>
            </section>

            <section id="performans-ve-diger" class="content-section">
                <h2>Performans, Versiyonlama ve Diğer Önemli Hususlar</h2>
                <p>Abstract class ve interface seçimini etkileyebilecek bazı ek faktörler de bulunmaktadır.</p>
                 <details class="question-block">
                    <summary><h3>Performans Etkileri: Gerçek mi, Efsane mi?</h3></summary>
                    <p>
                        Geçmişte, interface metot çağrılarının (interface dispatch) virtual metot çağrılarına (virtual dispatch) göre küçük bir performans ek yükü olduğu konuşulurdu. Bunun nedeni, çalışma zamanının doğru interface implementasyonunu bulmak için ek bir arama yapması gerekebilmesiydi. Ancak, modern .NET (ve Java) çalışma zamanları (CLR/JVM) bu konuda oldukça optimize edilmiştir. Just-In-Time (JIT) derleyicileri, birçok durumda interface çağrılarını doğrudan veya virtual çağrılar kadar verimli hale getirebilen optimizasyonlar (örneğin, devirtualization) yapar.
                    </p>
                    <p>
                        <strong>Sonuç:</strong> Çoğu uygulama için abstract class ve interface arasındaki potansiyel performans farkı <strong>ihmal edilebilir düzeydedir</strong>. Performansın <em>aşırı</em> kritik olduğu çok nadir senaryolar dışında (örneğin, ultra düşük gecikmeli sistemler, oyun motorlarının en iç döngüleri), performans kaygısıyla interface yerine abstract class seçmek genellikle <strong>yanlış bir optimizasyondur</strong>. Tasarımın doğruluğu, esnekliği ve sürdürülebilirliği çok daha önemlidir. Performans sorunları yaşanıyorsa, bunun nedeni genellikle algoritma seçimi, veritabanı erişimi, ağ gecikmesi gibi daha büyük faktörlerdir ve bu darboğazlar profil araçlarıyla tespit edilip giderilmelidir.
                    </p>
                </details>

                <details class="question-block">
                    <summary><h3>Versiyonlama ve API Evrimi</h3></summary>
                    <p>
                        Bir kütüphane veya API geliştirirken, zamanla bu API'yi geliştirme ve yeni özellikler ekleme ihtiyacı doğar. Bu noktada abstract class ve interface'lerin versiyonlama davranışları farklılık gösterir:
                    </p>
                    <ul>
                        <li><strong>Abstract Class'a Yeni Metot Ekleme:</strong> Eğer abstract class'a yeni bir <strong>somut (concrete)</strong> veya <strong>virtual</strong> metot eklerseniz, bu genellikle mevcut türetilmiş sınıfları kırmaz. Türetilmiş sınıflar bu yeni metodu implemente etmek zorunda değildir (isterlerse override edebilirler). Ancak, yeni bir <strong>abstract</strong> metot eklerseniz, mevcut tüm türetilmiş sınıfların bu metodu implemente etmesi gerekir ve bu bir "breaking change" (kırılma yaratan değişiklik) olur.</li>
                        <li><strong>Interface'e Yeni Metot Ekleme (C# 8 Öncesi):</strong> Geleneksel olarak, bir interface'e yeni bir metot eklemek, o interface'i implemente eden mevcut tüm sınıfların kodunu <strong>kırardı</strong>, çünkü hepsi yeni metodu implemente etmek zorunda kalırdı. Bu, interface'lerin evrimini zorlaştıran önemli bir sorundu.</li>
                        <li><strong>Interface'e Yeni Metot Ekleme (C# 8 ve Sonrası):</strong> Default interface methods bu sorunu çözmek için getirildi. Artık bir interface'e varsayılan bir implementasyonla yeni bir metot ekleyebilirsiniz. Mevcut sınıflar bu metodu implemente etmezse, varsayılan implementasyon kullanılır ve kodları kırılmaz. Bu, interface'lerin versiyonlanmasını çok daha kolay hale getirmiştir.</li>
                    </ul>
                    <p>
                        Sonuç olarak, C# 8 ve sonrası için interface'ler de versiyonlama açısından abstract class'lar kadar (hatta bazen daha) esnek hale gelmiştir. Ancak yine de, API tasarımı yaparken gelecekteki olası değişiklikleri öngörmek ve arayüzleri dikkatli tasarlamak önemlidir (örneğin, ISP'ye uymak).
                    </p>
                </details>

                 <details class="question-block">
                    <summary><h3>Kod Örnekleri ve Açıklamaları (Genişletilmiş)</h3></summary>
                    <p>Bu bölümde, abstract class ve interface kullanımını gösteren bazı C# kod örnekleri ve bunların açıklamalarını bulabilirsiniz.</p>

                    <p><strong>Örnek 1: <code>IPerson</code> Arayüzü ve <code>Person</code> Soyut Sınıfı</strong></p>
                    <pre><code class="language-csharp">
// IPerson.cs - Sadece sözleşmeyi tanımlar
public interface IPerson
{
    string Name { get; set; }
    int Age { get; set; }
    string GetDetails(); // Tüm implemente eden sınıflar bunu sağlamalı
}

// Person.cs - Ortak temel ve kısmi implementasyon
public abstract class Person : IPerson
{
    public string Name { get; set; }
    public int Age { get; set; }

    // Constructor
    protected Person(string name, int age)
    {
        Name = name;
        Age = age;
    }

    // Somut metot (tüm Person türevleri için ortak)
    public virtual string Greet() // virtual: override edilebilir
    {
        return $"Merhaba, benim adım {Name}.";
    }

    // Soyut metot (IPerson'dan gelen ve türevlerin sağlaması gereken)
    public abstract string GetDetails(); 
}
                    </code></pre>
                    <p>Burada <code>IPerson</code>, bir kişinin sahip olması gereken temel özellikleri (Name, Age) ve bir metodu (GetDetails) tanımlayan bir sözleşmedir. <code>Person</code> ise bu sözleşmeyi (kısmen) uygulayan ve aynı zamanda kendi somut (<code>Greet</code>) ve soyut (<code>GetDetails</code>) üyelerini barındıran bir temel sınıftır. <code>Greet</code> metodu <code>virtual</code> olduğu için türetilmiş sınıflar tarafından isteğe bağlı olarak ezilebilir.</p>

                    <p><strong>Örnek 2: <code>Employee</code> ve <code>Student</code> Sınıfları</strong></p>
                    <pre><code class="language-csharp">
public class Employee : Person
{
    public string Department { get; set; }

    public Employee(string name, int age, string department) 
        : base(name, age) // Temel sınıfın constructor'ını çağırır
    {
        Department = department;
    }

    // Person'daki abstract GetDetails metodunun zorunlu implementasyonu
    public override string GetDetails()
    {
        return $"Çalışan: {Name}, Yaş: {Age}, Departman: {Department}";
    }

    // Person'daki virtual Greet metodunun isteğe bağlı override'ı
    public override string Greet()
    {
        return base.Greet() + $" {Department} bölümünde çalışıyorum.";
    }
}

public class Student : Person, IStudentCommands // Hem Person'dan türer hem de IStudentCommands implemente eder
{
    public string Major { get; set; }

    public Student(string name, int age, string major) : base(name, age)
    {
        Major = major;
    }

    public override string GetDetails()
    {
        return $"Öğrenci: {Name}, Yaş: {Age}, Bölüm: {Major}";
    }

    // IStudentCommands'den gelen metot
    public void Study()
    {
        Console.WriteLine($"{Name} ders çalışıyor...");
    }
}

// Ek bir yetenek için interface
public interface IStudentCommands 
{
    void Study();
}
                    </code></pre>
                    <p><code>Employee</code> ve <code>Student</code>, <code>Person</code> abstract sınıfından türemiştir, bu da onların birer "Person" olduğunu belirtir. Her ikisi de <code>GetDetails</code> abstract metodunu override etmek zorundadır. <code>Employee</code>, <code>Greet</code> metodunu da override ederek davranışını özelleştirmiştir. <code>Student</code> sınıfı ayrıca <code>IStudentCommands</code> interface'ini implemente ederek ek bir "Study" yeteneği kazanmıştır. Bu, hibrit kullanıma iyi bir örnektir.</p>
                    
                    <p><strong>Kullanım Örneği:</strong></p>
                     <pre><code class="language-csharp">
// Program.cs
static void Main(string[] args)
{
    IPerson emp = new Employee("Ali Veli", 30, "IT");
    IPerson std = new Student("Ayşe Kaya", 20, "Bilgisayar Müh.");

    Console.WriteLine(emp.GetDetails()); // Çalışan: Ali Veli, Yaş: 30, Departman: IT
    Console.WriteLine(emp.Greet());      // Merhaba, benim adım Ali Veli. IT bölümünde çalışıyorum.

    Console.WriteLine(std.GetDetails()); // Öğrenci: Ayşe Kaya, Yaş: 20, Bölüm: Bilgisayar Müh.
    Console.WriteLine(std.Greet());      // Merhaba, benim adım Ayşe Kaya. (Temel sınıfın Greet'i)

    if (std is IStudentCommands studentCommands)
    {
        studentCommands.Study(); // Ayşe Kaya ders çalışıyor...
    }

    // Default Interface Method Örneği (C# 8+)
    IShape circle = new Circle { Radius = 5 };
    Console.WriteLine($"Daire Alanı: {circle.CalculateArea()}");
    circle.PrintDescription(); // Default implementasyon çağrılır
}

// C# 8+ Default Interface Method örneği
public interface IShape
{
    double CalculateArea(); // Abstract-like
    void PrintDescription() // Default implementation
    {
        Console.WriteLine("Bu bir geometrik şekildir.");
    }
}
public class Circle : IShape
{
    public double Radius { get; set; }
    public double CalculateArea() => Math.PI * Radius * Radius;
    // PrintDescription'ı implemente etmek zorunda değil, default olanı kullanabilir.
    // İsterse override edebilir: public void PrintDescription() { Console.WriteLine("Bu bir dairedir."); }
}
                    </code></pre>
                    <p>Bu örnekler, abstract class ve interface'in farklı senaryolarda nasıl kullanılabileceğini ve birlikte çalışarak esnek ve güçlü tasarımlar oluşturulabileceğini göstermektedir.</p>
                 </details>

            </section>

            <section id="sonuc" class="content-section conclusion-section">
                <h2>Sonuç: Bilinçli Tasarımın Gücü</h2>
                <p>
                    Abstract class ve interface, Nesne Yönelimli Programlama'nın sunduğu soyutlama mekanizmalarının temel yapı taşlarıdır. Her ikisi de kodun daha modüler, esnek ve yönetilebilir olmasına katkıda bulunsa da, farklı amaçlara hizmet ederler ve farklı senaryolarda parlarlar. Interface'ler, genellikle farklı hiyerarşiler arasında ortak yetenekleri tanımlayan "sözleşmeler" olarak işlev görürken ve çoklu kalıtıma izin vererek esneklik sağlarken; abstract class'lar, yakından ilişkili sınıflar için ortak bir kimlik, durum ve kısmi implementasyon sunan "şablonlar" olarak görev yaparlar.
                </p>
                <p>
                    C# 8 ile gelen default interface metotları gibi yenilikler, bu iki yapı arasındaki çizgiyi bir miktar bulanıklaştırsa da, temel felsefeleri ve en uygun kullanım alanları büyük ölçüde aynı kalmıştır. Interface'ler hala durum bilgisi taşıyamaz ve öncelikli olarak sözleşme tanımlamaya odaklanırken, abstract class'lar durum yönetimi ve ortak temel implementasyon sağlama konusunda daha güçlüdür.
                </p>
                <p>
                    "Hangisini kullanmalıyım?" sorusunun tek bir doğru cevabı yoktur. Cevap, projenizin özel gereksinimlerine, tasarladığınız hiyerarşinin doğasına, gelecekteki genişleme beklentilerinize ve ulaşmak istediğiniz tasarım hedeflerine (örneğin, ne kadar gevşek bağlılık istediğinize) bağlıdır. Çoğu zaman en iyi çözümler, bu iki yapının akıllıca bir kombinasyonunu içerir.
                </p>
                <p>
                    Bu derinlemesine incelemenin, abstract class ve interface arasındaki farkları netleştirmenize, her birinin güçlü ve zayıf yönlerini anlamanıza ve projelerinizde daha bilinçli, daha sağlam ve daha sürdürülebilir tasarım kararları almanıza yardımcı olacağını umuyoruz. Unutmayın ki bu yapıları etkin bir şekilde kullanmak, sadece daha iyi kod yazmak değil, aynı zamanda daha iyi bir yazılım mühendisi olmak anlamına gelir. OOP'nin bu temel araçlarına hakim olmak, karmaşık problemleri zarif ve etkili çözümlere dönüştürme yeteneğinizi doğrudan artıracaktır.
                </p>
            </section>
        </div>
    </main>

    <div class="back-to-top-container">
        <a href="#pageTop" class="back-to-top" aria-label="Sayfanın başına dön">
            <i class="fas fa-chevron-up"></i>
        </a>
   </div>

    <footer id="mainFooter">
        <div class="container">
            <div class="footer-layout">
                <div class="footer-left-links">
                    <h4>Hızlı Bağlantılar</h4>
                    <ul class="footer-nav-links">
                        <li><a href="https://abdulkadirgungor.com/">Ana Sayfa</a></li>
                        <li><a href="https://abdulkadirgungor.com/cv" target="_blank" rel="noopener noreferrer">Özgeçmiş</a></li>
                        <li><a href="https://abdulkadirgungor.com/blog" target="_blank" rel="noopener noreferrer">Blog</a></li>
                    </ul>
                </div>
                <div class="footer-center-content">
                    <h4 class="sitemap-link-heading">
                        <a href="https://abdulkadirgungor.com/sitemap.xml" target="_blank" rel="noopener noreferrer">Sitemap</a>
                    </h4>
                    <p id="footerTextContent">
                        © {YEAR} Abdulkadir Güngör. Tüm Hakları Saklıdır.
                    </p>
                </div>
            </div>
        </div>
    </footer>
    
    <script src="../assets/js/script.js" defer></script>
</body>
</html>
